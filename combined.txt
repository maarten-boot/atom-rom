;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;              ****************************************
;              * Disassembly of Atom Operating System *
;              *           from #C000 to #CFFF        *
;              ****************************************
;
;1985-05-06	Version 1.0
;1993-08-25	Version 1.1 Minor corrections by KH:
;	C08D:	.BYTE	"*E",	$F0	;  ASTERISK MISSING FROM ORIGINAL DISASSEMBLY!
;	C09C:	.BYTE	"INT",	$C3	;; error in original disassembly
;	C09C:	.BYTE	"INK",	$C3	;; more likely end of LINK command
;	Noted conflict between original disassembly and some ROM binaries at:
;	CBB6  99 62 02  STA #262,Y	; 62 not 61
;	CBBB  99 6d 02  STA #26D,Y	; 6D not 6C
;
;
;
;  Interpreter Command Lookup Table
;  --------------------------------
;
;- Each sub table is terminated by a negative byte.
;- A termination byte of #FF causes BRK to be executed on failure.
;
C000  3C 3D 3E FE                                      <=>.
C004  2D 2B C8 23 28 21 3F 52 54 4C 43 41 50 45 47 42  -+.#(!?RTLCAPEGB
C014  46 F0                                            F.
C016  54 FF                                            T.
C018  4F CB                                            O.
C01A  53 CB                                            S.
C01C  54 45 50 CB                                      TEP.
C020  54 C3                                            T.
C022  48 45 4E C3                                      HEN.
C026  22 24 CE CE CC                                   "$...
C02B  24 2C C5                                         $.,
C02E  24 26 3B 0D 2C C3 C5 C2                          $&;.,...
C036  3E C7                                            >.
C038  3D C7 C7 C7                                      =...
C03C  3D C7 C7 C8                                      =...
C040  52 C7 C7                                         R..
C043  4F 41 FE                                         OA.
C046  24 C7                                            $.
C048  48 C9                                            H.
C04A  45 4E C9                                         EN.
C04D  4E 44 C7 C9 C9 C9 C9                             ND.....
C054  4E 44 C9                                         ND.
C057  4F 50 C9                                         OP.
C05A  4F 55 4E 54 C9                                   OUNT.
C05F  42 53 C9                                         BS.
C062  54 52 CF                                         TR.
C065  58 54 CF                                         XT.
C068  45 54 CF                                         ET.
C06B  47 45 54 CF                                      GET.
C06F  49 4E CF                                         IN.
C072  4F 55 54 CF C3 C3                                OUT...
C078  52 49 4E 54 C3                                   RINT.
C07D  4E 4C 55 4E 49 47 52 46 21 3F 24 50 44 4C 53 42  NLUNIGRF!?$PDLSB
C08D  2A 45 F0                                         *E.

C090  41 56 45 CF                                      AVE.
C094  45 57 C2                                         EW.
C097  4F CC                                            O.
C099  45 54 C3                                         ET.
C09C  49 4E 4B C3                                      INK.

C0A0  49 53 54 CA                                      IST.
C0A4  4F 41 44 CE                                      OAD.
C0A8  4E 54 49 4C CC                                   NTIL.
C0AD  45 58 54 CA                                      EXT.
C0B1  46 C5                                            F.
C0B3  4E 50 55 54 CC                                   NPUT.
C0B8  4F 53 55 42 CB                                   OSUB.
C0BD  4F 54 4F CC  OTO.
C0C1  45 54 55 52 4E CB                                ETURN.
C0C7  45 4D C5                                         EM.
C0CA  55 4E F1                                         UN.
C0CD  4F 52 CB                                         OR.
C0D0  4E 44 CD                                         ND.
C0D2  47 45 54 CF                                      GET.
C0D6  50 55 54 CF                                      PUT.
C0DA  48 55 54 CF                                      HUT.
C0DF  50 55 54 CF                                      PUT.
C0E3  54 52 CF                                         TR.
C0E6  55 54 CF C3 C4 CD C4                             UT.....
C0ED  2C FE                                            ,.


  Jump Address and Return Branch Table
  ------------------------------------

C0EF  36                                               6
C0F0  3B 3C C0 3F 06 DC 50 51 52 53 54 57 4A 5A 5F 62  ;<.?..PQRSTWJZ_b
C100  65 68 6B 6F 2E 18 AC 17 81 1C BE 17 17 17 A2 22  ehko..........."
C110  1B 17 17 17 1B 29 28 B6 BF B6 2A B7 58 76 77 34  .....)(...*.Xvw4
C120  34 7C 3F 4A 78 38 6D 3A 64 74 5B 3E 7B 82 C1 45  4|?Jx8m:dt[>{..E
C130  22 31 40 4D 4D 42 53 15 D2 15 15 BD 45 45 14 0A  "1@MMBS.....EE..
C140  44 5F 4C 15 15 86 15 15 73 48 15 15 15 7A 15 15  D_L.....sH...z..
C150  02 15 15 29 15 15 28 15 15 66 15 15 15 5B 72 15  ...)..(..f...[r.
C160  A6 15 15 15 A7 90 35 E3 8F 8F 8F 34 94 A0 A8 AD  ......5....4....
C170  B1 BD C1 CD E9 EA EB 78 97 99 D3 DF EC D0 4B 8F  .......x......K.
C180  8F 8F 0A 8F AD AD 8F F0 9C 8F 25 8F 8F 8F B2 A4  ..........%.....
C190  9C 8F 51 99 8F 8F ED 8F 8F 8F 8F D2 8F 8F 8F CD  ..Q.............
C1A0  B3 66 8F 8F 8F 8F 81 8F 8F 8F 8F D2 8F B8 8F 05  .f..............
C1B0  CA C7 8F 8F 8F EC 8F 8F 75 8F 8F 41 8F 8F 57 8F  ........u..A..W.
C1C0  8F 98 D7 8F 8F E3 DB 8F 8F C5 90 8F 8F B6 8F 8F  ................
C1D0  8F 8F E6 8F 47 8F 8F 95 EE 06 5C 0F 35           ....G.....\.5
;  Interpreter Single Byte Command Lookup Table
;  --------------------------------------------
C1DD  2D 2B 7C 3A FE                                   -+|:.
C1E2  2A 2F 25 21 3F 26 FE                             */%!?&.
C1E9  29 FF                                            ).
C1EB  3D FF                                            =.
C1ED  21 3F 24 FF                                      !?$.
C1F1  3D 21 3F FF                                      =!?.
C1F5  27 22 FE                                         '".
;  LSB Execution Address Table for Single Byte Commands
;  ----------------------------------------------------
C1F8                          B7 9A D3 EF EF 13 5E 70
C200  B3 9C 7B 7B 78 78 78 78 EE 06 5C 5C E5 75 7B 7B
C210  6F 7A
;  MSB Execution Address Table for Single Byte Commands
;  ----------------------------------------------------
C212        C7 C7 C7 C7 C7 C8 C8 C8 C8 C8 C8 C8 C2 C2
C220  C2 C2 C3 C4 CD CD C3 CD CD CD C3 C3              ............
;  Function Interpreter subroutine
;  -------------------------------
;- Evaluates an arbitrarily complex function pointed to by (5),Y where Y=?3
;  and stores the result on the Workspace Stack pointed to by ?4.
C22C  20 3E CF  JSR #CF3E       Get <factor> into Y register
C22F  84 0F     STY #F          Hex print flag, updated by comma
;  Search for ',' subroutine
;  -------------------------
C231  A2 ED     LDX @#ED        Set table pointer to #C0ED to search for ',' only
;  Interpreter subroutine
;  ----------------------
;- Interprets the command word at #C0EE,X against text at (#5),?3
C233  A4 03     LDY #3          Get the interpreter pointer
;
;    SKIP ANY PRECEDING SPACES
C235  88        DEY
C236  C8        INY             Point to the next character in text
C237  B1 05     LDA (#5),Y      ..and fetch it
C239  C9 20     CMP @#20        Is it <SPC> ?
C23B  F0 F9     BEQ #C236       ..yes, skip to next character
;    GET FIRST CHARACTER MATCH
C23D  84 5E     STY #5E         Save current interpreter index
C23F  85 52     STA #52         Save character under interpretation
C241  E8        INX             Point to next character in command table
C242  BD FF BF  LDA #BFFF,X     ..and fetch it
C245  30 24     BMI #C26B       ..a negative byte indicates the end of the initial letter table
C247  C5 52     CMP #52         Same as character under interpretation ?
C249  D0 F6     BNE #C241       ..no, try next initial letter
;     MATCH THE REST OF THE COMMAND WORD
C24B  BD EE C0  LDA #C0EE,X     Get index to rest-of-command-word table
C24E  AA        TAX             This is now the new table pointer
C24F  E8        INX             Point to the next character in the table
C250  C8        INY             Point to the next character under analysis
C251  BD FF BF  LDA #BFFF,X     Fetch the next command table character
C254  30 15     BMI #C26B       ..a negative byte means either a successful match of end of command table
C256  D1 05     CMP (#5),Y      Same as character under interpretation ?
C258  F0 F5     BEQ #C24F       ..yes, now try to match the next character
C25A  B1 05     LDA (#5),Y      ..no, get the failed character under interpretation
C25C  C9 2E     CMP @#2E        Is it '.' indicating an abbreviation ?
C25E  F0 04     BEQ #C264       ..yes, so it's a successful match
C260  A4 5E     LDY #5E         ..no, so reset the interpreter pointer
C262  10 E7     BPL #C24B       ..and try to match the next word in the command table
;    SUCCESSFUL ABREVIATED MATCH - SKIP TO THE END OF THE COMMAND WORD IN THE TABLE
C264  E8        INX             Point to the next character in the table
C265  BD FF BF  LDA #BFFF,X     ..and fetch it
C268  10 FA     BPL #C264       Keep incrementing to reach the command word's negative termination byte
C26A  C8        INY             Point to the next character under analysis
;   Test for success or failure
C26B  C9 FE     CMP @#FE        reached the end of the command table ?
C26D  B0 3B     BCS #C2AA       ..yes, return or execute BRK as required
;    GET THE COMMAND WORD'S JUMP ADDRESS INTO ZERO PAGE AND JUMP TO IT
C26F  85 53     STA #53         Termination byte is the MSB jump address
C271  BD EE C0  LDA #C0EE,X     Get the LSB jump address from the table
C274  90 29     BCC #C29F       Dump it to #52, update #3 and #4 and jump to the command address ow in (#52)
C276  A6 04     LDX #4
C278  60        RTS

;
;  Search for '=' subroutine
;  -------------------------
; - Looks for '=', skipping leading spaces, in text pointed to by (5),Y where Y=?3.
;- Executes BRK if the first non space character is not '='.
;- Returns with Y register pointing to the next character.
;- Returns with the interpreter pointer ?3 updated.
;- Returns with X register loaded with the w/s pointer ?4.
;
C279  A2 0E     LDX @#E         Point to '=' at #C1EB

;  Single Byte Command Interpreter
;  -------------------------------
;- Interpretes the single byte symbols at #C1DD.
;- Enter with X register pointing to the symbol table to be used.
C27B  A4 03     LDY #3          Get the interpreter pointer
C27D  88        DEY
C27E  C8        INY
C27F  B1 05     LDA (#5),Y      Get the next character from text
C281  C9 20     CMP @#20        Is it <spc> ?
C283  F0 F9     BEQ #C27E       ..yes, skip preceding spaces
C285  DD DD C1  CMP #C1DD,X     Is it this single byte symbol ?
C288  F0 0C     BEQ #C296       ..yes, go fetch its jump address
C28A  85 52     STA #52         ..no, save the character under analysis
C28C  E8        INX             Point to the next table symbol
C28D  BD DD C1  LDA #C1DD,X     ..and fetch it
C290  30 16     BMI #C2A8       ..a negative byte means the end of table
                                termination byte has been reached
C292  C5 52     CMP #52         Does this symbol match the text ?
C294  D0 F6     BNE #C28C       ..no, try the next symbol

                                MATCHED SYMBOL - FETCH JUMP ADDRESS

C296  BD 12 C2  LDA #C212,X     Get the MSB jump address
C299  85 53     STA #53         ..into workspace
C29B  BD F8 C1  LDA #C1F8,X     Get the LSB jump address
C29E  C8        INY             Increment the text pointer past the                                 character just successfully interpreted
C29F  85 52     STA #52         Dump the MSB jump address to workspace
C2A1  84 03     STY #3          Update the interpreter pointer
C2A3  A6 04     LDX #4          Get the current workspace pointer
C2A5  6C 52 00  JMP (#52)       ..and jump

                                END OF TABLE ACTION

C2A8  C9 FE     CMP @#FE        Non-destructive failure ?
C2AA  F0 CA     BEQ #C276       ..yes, load workspace pointer and return
C2AC  00        BRK             ..no, error 174


  Execute the command 'NEW'
  -------------------------

- Resets the print field length LSB variable '@' to the default of 8.
- Exits back to direct mode.

C2AD  20 E4 C4  JSR #C4E4       Perform the interpreter post test
C2B0  D0 04     BNE #C2B6


  'Cold Start' routine - Text at #2900
  ------------------------------------

- Comes from BREAK routine  at #FF94.
- Points the text pointer ?#12 at #2900 and performs a 'NEW'.

C2B2  A9 29     LDA @#29
C2B4  85 12     STA #12         Set text pointer to page #29


  'Cold Start' routine - unspecified text Space
  ---------------------------------------------

- If coming from the BREAK routine at #FF97, the text space is #8200.
- Performs an 'NEW' at the current text space.

C2B6  A9 0D     LDA @#D
C2B8  A4 12     LDY #12         Get the text page
C2BA  84 0E     STY #E          Set MSB TOP to the start of text
C2BC  A0 00     LDY @#0
C2BE  84 0D     STY #D          Set LSB TOP to the start of text
C2C0  91 0D     STA (#D),Y      First byte of text is #D
C2C2  A9 FF     LDA @#FF        Get a text terminator
C2C4  C8        INY             Point to the second byte of text
C2C5  91 0D     STA (#D),Y      ..and dump the terminator
C2C7  C8        INY             Point to the third byte of text
C2C8  84 0D     STY #D          ..and set LSB TOP
C2CA  A9 08     LDA @#8         Get the default print length
C2CC  8D 21 03  STA #321        ..and set LSB integer variable '@'


  Direct Command Handler
  ----------------------

- Entered after a command execution or at the end of a program.

C2CF  A9 3E     LDA @#3E        Get '>'
C2D1  D8        CLD
C2D2  20 0F CD  JSR #CD0F       Print the contents of the accumulator and get a line of text terminated by <CR> from the keyboard into the #100 buffer

;    INITIALISE THE (5),Y TEXT POINTER TO THE START OF THE #100 BUFFER

C2D5  A2 01     LDX @#1
C2D7  86 06     STX #6
C2D9  CA        DEX
C2DA  86 05     STX #5
;   CLEAR LINE NUMBER TO ZERO - DIRECT MODE

C2DC  86 01     STX #1          Clear the MSB line number
C2DE  86 02     STX #2          Clear the LSB line number

                                SET BRKVEC TO THE DEFAULT ROUTINE AT #C9D8

C2E0  A9 D8     LDA @#D8
C2E2  8D 02 02  STA #202
C2E5  A9 C9     LDA @#C9
C2E7  8D 03 02  STA #203

                                SET THE BASIC ERROR HANDLER TO THE
                                DEFAULT TEXT AT #C9E7

C2EA  A9 E7     LDA @#E7
C2EC  85 10     STA #10
C2EE  A9 C9     LDA @#C9
C2F0  85 11     STA #11

                                EXECUTE THE TEXT POINTED BTO BY (5),Y

C2F2  A2 FF     LDX @#FF
C2F4  9A        TXS             Reset the stack poimter
C2F5  A9 00     LDA @#0
C2F7  85 04     STA #4          Reset the workspace stack poimter
C2F9  85 03     STA #3          Reset the interpreter index
C2FB  85 15     STA #15         Reset the FOR..NEXT stack poimter
C2FD  85 13     STA #13         Reset the GOSUB..RETURN stack poimter
C2FF  85 14     STA #14         Reset the DO..UNTIL stack poimter
C301  A2 34     LDX @#34

                                CLEAR THE LABEL (@ to z) ADDRESS STACK

C303  9D 8C 03  STA #38C,X
C306  CA        DEX
C307  D0 FA     BNE #C303

C309  20 34 C4  JSR #C434       If the first non space character is                                 alphabetic and the the subsequent                                 is not (but is not '.')
C30C  B0 21     BCS #C32F       ..then interpret a simple integer variable                                 definition

                                CHECK FOR TEXT LINE ENTRY OR DELETION

C30E  20 6A C4  JSR #C46A       interpret a decimal string as a number                                 into the w/s stack, and increment ?4
C311  90 03     BCC #C316       ..invalid number
C313  4C C9 CD  JMP #CDC9       Deal with line insertion and removal

                                EXECUTE A DIRECT COMMAND AT #100

C316  A2 7D     LDX @#7D        Set the interpreter table pointer to #C???
C318  4C 33 C2  JMP #C233       ..and interpret & execute the command


  Execute the command 'THEN'
  --------------------------

C31B  20 34 C4  JSR #C434       If the first non space character is                                 alphabetic and the the subsequent                                 is not (but is not '.')
C31E  B0 0F     BCS #C32F       ..then treat this as an integer variable                                 assignment
C320  A2 7F     LDX @#7F        Set the interpreter table pointer to #C???
C322  4C 33 C2  JMP #C233       ..and interpret & execute the command


  Execute the command 'LET'
  -------------------------

C325  20 34 C4  JSR #C434       If the first non space character is                                 alphabetic and the the subsequent                                 is not (but is not '.')
C328  B0 05     BCS #C32F       ..then interpret a simple integer variable
C32A  A2 10     LDX @#10        Otherwise set the table pointer
C32C  4C 7B C2  JMP #C27B       ..and interpret a ?, ! or $ definition

                                EXECUTE {simple integer variable} =, ? OR
                                ! ASSIGNMENT

C32F  A2 14     LDX @#14        Set table pointer to
C331  4C 7B C2  JMP #C27B       Search for & execute '=', '?' or '!'


  Execute the command 'PRINT'
  ---------------------------

C334  38        SEC
C335  66 0F     ROR #F          Set bit 7 of the hex print flag to get
                                the default decimal print mode
C337  20 72 C3  JSR #C372
C33A  A2 2E     LDX @#2E        Set the interpreter table pointer to #C???
C33C  4C 33 C2  JMP #C233       ..and interpret & execute '=', '?' or '!'


  Execute and Print an Arbitrarily Complex Expression
  ---------------------------------------------------

C33F  20 8B C7  JSR #C78B       Evaluate an arbitrarily complex expression, followed by a single byte symbol, followed by '<', '=' or '>'
C342  20 CB C3  JSR #C3CB       Copy the last level of the w/s stack to #52(LSB)..#55(MSB) & increment w/s pointer
C345  A5 0F     LDA #F          Print in decimal ?
C347  30 21     BMI #C36A       ..yes, branch to decimal print routine


  Print the 4 byte Word at #52..#55 in Hexadecimal subroutine
  -----------------------------------------------------------

  - Prints the word #52(LSB) to #55(MSB) as a 4 byte hex word in field
    size @ suppressing any leading zeros.
  - Destroys A,X,Y registers.

C349  A2 00     LDX @#0
C34B  86 27     STX #27         Clear the negative flag used by the print routine at #C5C8
C34D  A0 00     LDY @#0         Clear index to the 4-byte word
C34F  B9 52 00  LDA #52,Y       Get the current byte of the word
C352  48        PHA             Save a copy for upper nibble conversion
C353  29 0F     AND @#F         Mask off the upper nibble
C355  95 45     STA #45,X       ..and dump the lower nibble to w/s
C357  68        PLA             Restore the copy
C358  4A        LSR A )
C359  4A        LSR A )
C35A  4A        LSR A )
C35B  4A        LSR A ) Bring the upper nibble down to the lower nibble
C35C  E8        INX             Increment the w/s pointer
C35D  95 45     STA #45,X       ..and dump the converted upper nibble
C35F  E8        INX             Increment the w/s pointe for the next byte
C360  C8        INY             Point to the next byte of theword
C361  C0 04     CPY @#4         Done all $ bytes ?
C363  90 EA     BCC #C34F       ..no, go for the next one
C365  20 C8 C5  JSR #C5C8       Print the digit stream suppressing leading zeros
C368  30 CD     BMI #C337       Branch ALWAYS to interpret the next item in the print stream


  Decimal print routine
  ---------------------

C36A  20 89 C5  JSR #C589       Print the lowest level of the w/s stack as                                 a signed decimal number in field size @
C36D  30 C8     BMI #C337       Branch ALWAYS to interpret the next item                                 in the print stream


C36F  20 54 CD  JSR #CD54       Send <CR><LF> to OSWRCH
C372  A2 18     LDX @#18        Set the interpreter table pointer to #C???
C374  4C 7B C2  JMP #C27B       ..and interpret 'O' ??


  ??? Print routine ???
  ---------------------

C377  20 4C CA  JSR #CA4C       Increment COUNT and send the contents of
                                the accumulator to OSWRCH
C37A  B1 05     LDA (#5),Y
C37C  C8        INY
C37D  C9 0D     CMP @#D
C37F  F0 1C     BEQ #C39D
C381  84 03     STY #3
C383  C9 22     CMP @#22
C385  D0 F0     BNE #C377
C387  B1 05     LDA (#5),Y
C389  C9 22     CMP @#22
C38B  D0 E5     BNE #C372
C38D  C8        INY
C38E  B0 E7     BCS #C377
C390  20 8B C7  JSR #C78B
C393  20 CB C3  JSR #C3CB
C396  05 54     ORA #54
C398  05 53     ORA #53
C39A  F0 0E     BEQ #C3AA
C39C  A0 00     LDY @#0
C39E  B1 52     LDA (#52),Y
C3A0  C9 0D     CMP @#D
C3A2  F0 93     BEQ #C337
C3A4  20 4C CA  JSR #CA4C
C3A7  C8        INY
C3A8  D0 F4     BNE #C39E
C3AA  A5 52     LDA #52
C3AC  20 4C CA  JSR #CA4C
C3AF  4C 37 C3  JMP #C337


  Execute the command 'LINK'
  --------------------------

C3B2  20 C8 C3  JSR #C3C8       Evaluate an arbitrarily complex function                                 to #52(LSB)..#55(MSB)
C3B5  20 E4 C4  JSR #C4E4       Do interpreter post-test
C3B8  AD 22 03  LDA #322        Load accumulator with LSB integer 'A'
C3BB  AE 39 03  LDX #339        Load X register with LSB integer 'X'
C3BE  AC 3A 03  LDY #33A        Load Y register with LSB integer 'Y'
C3C1  20 A5 C2  JSR #C2A5       Indirect jump to (#52)
C3C4  D8        CLD             Ensure binary mode after nasty user's prog
C3C5  4C 5B C5  JMP #C55B       Return to execute the next command whether                                 by program execution or in direct mode


  Function Interpreter subroutine
  -------------------------------

- Evaluates an arbitrarily complex function pointed to by (5),Y where y=?3
  and stores the result on the Workspace Stack pointed to by ?4 and also
  on the arithmetic workspace stack at #52(LSB)..#55(MSB).
- The (5),Y pointer is consolidated before return, so that (5),0 points to
  the last character in the string interpreted.
- The workspace stack pointer ?4 is NOT incremented.

C3C8  20 BC C8  JSR #C8BC       Evaluate an arbitrarily complex numeric                                 expression pointed to by (5),Y


  Copy Current Level of the Workspace Stack to #52..#55 subroutine
  ----------------------------------------------------------------

- Enter with the X register pointing to the current level of the workspace
  stack, so that level (X-1) is copied to #52(LSB)..#55(MSB).
- The workspace stack pointer ?4 is updated and decremented.

C3CB  A0 52     LDY @#52


  Copy Current Level of the Workspace Stack to zero page subroutine
  -----------------------------------------------------------------

- Enter with the X register pointing to the current level of the workspace
  stack, so that level (X-1) is copied to #52(LSB)..#55(MSB).
- Enter with the Y register pointing to the LSB of the four consecutive
  bytes that are the zero page destination.
- The workspace stack pointer ?4 is updated and decremented.

C3CD  CA        DEX
C3CE  86 04     STX #4


  Copy Current Level of the Workspace Stack to zero page subroutine
  -----------------------------------------------------------------

- Enter with the X register pointing to the level of the workspace stack
  required to be copied to #52(LSB)..#55(MSB).
- Enter with the Y register pointing to the LSB of the four consecutive
  bytes that are the zero page destination.
- The workspace stack pointer ?4 is NOT TOUCHED !

C3D0  B5 16     LDA #16,X
C3D2  99 00 00  STA #0,Y
C3D5  B5 25     LDA #25,X
C3D7  99 01 00  STA #1,Y
C3DA  B5 34     LDA #34,X
C3DC  99 02 00  STA #2,Y
C3DF  B5 43     LDA #43,X
C3E1  99 03 00  STA #3,Y
C3E4  60        RTS


  Deals with Numerical Assignments
  --------------------------------

- Sets pre-interpreted variable to an arbitrarily complex expression.
- Enter with the variable number (0=@, 1=A, etc TO 26=Z) in the LSB of
  the workspace stack at level (?4-1).

C3E5  20 E1 C4  JSR #C4E1       Evaluate a numerical expression onto the                                 w/s stack and do post-test.
C3E8  20 2F CA  JSR #CA2F       Assign value on the w/s stack to a variable                                 number on the w/s stack
C3EB  4C 5B C5  JMP #C55B       Return to execute the next command whether                                 by program execution or in direct mode


  Execute the command '!'
  -----------------------

- Sets pre-interpreted vector to an arbitrarily complex expression.

C3EE  20 BC C8  JSR #C8BC       Evaluate an arbitrarily complex numeric                                 expression pointed to by (5),Y                                 which is the ! base address
C3F1  20 93 CE  JSR #CE93       Interpret an '=' sign and a numerical                                 expression following, and copy the LSB                                 to the base address on stack
C3F4  B5 26     LDA #26,X       Get the second LSB from stack
C3F6  C8        INY             Point to the second address
C3F7  91 52     STA (#52),Y     ..and dump the second LSB
C3F9  C8        INY             Point to the third address
C3FA  B5 35     LDA #35,X       Get the third LSB from stack
C3FC  91 52     STA (#52),Y     ..and dump the third LSB
C3FE  C8        INY             Point to the fourth address
C3FF  B5 44     LDA #44,X       Get the fourth LSB from stack
C401  91 52     STA (#52),Y     ..and dump the fourth LSB
C403  4C 5B C5  JMP #C55B       Return to execute the next command whether
                                by program execution or in direct mode


  Execute the command '?'
  -----------------------

- Sets pre-interpreted byte to an arbitrarily complex expression.

C406  20 BC C8  JSR #C8BC       Evaluate an arbitrarily complex numeric                                 expression pointed to by (5),Y
C409  20 93 CE  JSR #CE93       Interpret an '=' sign and a numerical                                 expression following, and copy the LSB                                 to the base address on stack
C40C  4C 5B C5  JMP #C55B       Return to execute the next command whether                                 by program execution or in direct mode


  Execute COS commands
  --------------------

- Deals with * prefixed commands.
- Copies the string after the '*' prefix pointed to by (5),Y where Y=?3
  to the Direct Mode buffer at #100 and then calls OSCLI indirected
  by vector (#206,#207).

C40F  A2 00     LDX @#0         Initialise the Direct Mode buffer pointer
C411  B1 05     LDA (#5),Y      Get character under analysis from text
C413  9D 00 01  STA #100,X      ..and copy to the direct mode buffer
C416  84 03     STY #3          Update the interpreter pointer
C418  C8        INY             Point to the next character of text
C419  E8        INX             Point to the next slot in the buffer
C41A  C9 0D     CMP @#D         Was the last character <CR> ?
C41C  D0 F3     BNE #C411       ..no, keep copying                                 (defaults to #F8EF)
C41E  20 F7 FF  JSR #FFF7       ..yes, finished, so call OSCLI
C421  4C 58 C5  JMP #C558       Perform post test, check for <ESC> etc and return to execute the next command whether by program execution or in direct mode


  Floating Point ROM Check subroutine
  -----------------------------------

- Returns with Carry set if the FP ROM at #D000 exists.

C424  AD 00 D0  LDA #D000
C427  C9 AA     CMP @#AA
C429  D0 38     BNE #C463
C42B  4A        LSR A
C42C  CD 01 D0  CMP #D001
C42F  D0 32     BNE #C463
C431  A4 5E     LDY #5E
C433  60        RTS


  Interpreter Alphabetic Pre-Test subroutine
  ------------------------------------------

- Reads the first non-space character pointed to by (5),Y where y=?3
  and tests it and the following character.
  1st character: If it is alphabetic (@ to Z), the character number
                 (where @=0, A=1 to Z=26) is stored in the LSB of the
                 current level of the workspace stack, pointed to by ?4,
                 and the second character is tested.
                 However if it is not alphabetic, the routine is exited
                 with Carry clear and the interpreter pointer Y=?3
                 pointing to the second character.
  2nd character: If it is not alphabetic and also not '.', the workspace
                 pointer X=?4 is incremented before return with Carry set
                 and the interpreter pointer Y=?3 pointing to this
                 second character.
                 Otherwise return with pointers as above but with Carry clear.

C434  A4 03     LDY #3          Get the interpreter pointer
C436  10 03     BPL #C43B       ..branch always

C438  C8        INY
C439  84 03     STY #3
C43B  B1 05     LDA (#5),Y      Get the character under interpretation
C43D  C9 20     CMP @#20        If it's a space..
C43F  F0 F7     BEQ #C438       ..then skip to the next character
C441  C9 5B     CMP @#5B        Test for valid alphabetic character
C443  B0 1E     BCS #C463       ..invalid
C445  E9 3F     SBC @#3F        Convert to @=0, A=1,...to  Z=26
C447  90 1B     BCC #C464       ..invalid alphabetic character
C449  A6 04     LDX #4          Get the workspace pointer
C44B  95 16     STA #16,X       Dump the first character on the LSB of                                 the current workspace slot
C44D  C8        INY             Point to the next character
C44E  B1 05     LDA (#5),Y      ..and fetch it
C450  C9 2E     CMP @#2E        Is it '.' ?
C452  F0 0F     BEQ #C463       ..yes, clear Carry and quit
C454  C9 5B     CMP @#5B        Is it >='[' ?
C456  B0 04     BCS #C45C       ..yes, set Carry and quit
C458  C9 40     CMP @#40        Is it <='@' ?
C45A  B0 07     BCS #C463       ..yes, clear Carry and quit
C45C  E8        INX             Increment workspace stack pointer
C45D  86 04     STX #4          Update workspace stack pointer
C45F  38        SEC
C460  84 03     STY #3          Interpreter points to second character
C462  60        RTS
C463  18        CLC
C464  60        RTS

  Read Decimal String subroutine
  ------------------------------

- Reads string pointed to by (5),Y where Y=?3 as ASCII decimal characters,
  stores the binary result in the Workspace Stack at 16,X where X=?4
  and increments the Workspace Stack pointer ?4.
- If the first non-space character is not a number, BRK is executed.
- Destroys A,X,Y registers.

C465  20 34 C4  JSR #C434       If next symbol is a <variable>, BRK
C468  B0 BB     BCS #C425
;     GET POSITIVE NUMBER                                 (return with Carry clear if no number)
C46A  A2 00     LDX @#0
C46C  A4 03     LDY #3
C46E  86 52     STX #52
C470  86 53     STX #53
C472  86 54     STX #54
C474  86 55     STX #55
C476  88        DEY
C477  C8        INY
C478  B1 05     LDA (#5),Y
C47A  38        SEC
C47B  E9 30     SBC @#30
C47D  30 54     BMI #C4D3
C47F  C9 0A     CMP @#A
C481  B0 50     BCS #C4D3
C483  A6 53     LDX #53
C485  48        PHA
C486  A5 55     LDA #55
C488  48        PHA
C489  A5 54     LDA #54
C48B  48        PHA
C48C  A5 52     LDA #52
C48E  0A        ASL A
C48F  26 53     ROL #53
C491  26 54     ROL #54
C493  26 55     ROL #55
C495  30 D4     BMI #C46B
C497  0A        ASL A
C498  26 53     ROL #53
C49A  26 54     ROL #54
C49C  26 55     ROL #55
C49E  30 CB     BMI #C46B
C4A0  65 52     ADC #52
C4A2  85 52     STA #52
C4A4  8A        TXA
C4A5  65 53     ADC #53
C4A7  85 53     STA #53
C4A9  68        PLA
C4AA  65 54     ADC #54
C4AC  85 54     STA #54
C4AE  68        PLA
C4AF  65 55     ADC #55
C4B1  06 52     ASL #52
C4B3  26 53     ROL #53
C4B5  26 54     ROL #54
C4B7  2A        ROL A
C4B8  30 B1     BMI #C46B
C4BA  85 55     STA #55
C4BC  68        PLA
C4BD  65 52     ADC #52
C4BF  85 52     STA #52
C4C1  90 0C     BCC #C4CF
C4C3  E6 53     INC #53
C4C5  D0 08     BNE #C4CF
C4C7  E6 54     INC #54
C4C9  D0 04     BNE #C4CF
C4CB  E6 55     INC #55
C4CD  30 9C     BMI #C46B
C4CF  A2 FF     LDX @#FF
C4D1  D0 A4     BNE #C477
C4D3  8A        TXA
C4D4  F0 8D     BEQ #C463
C4D6  38        SEC
C4D7  84 03     STY #3
C4D9  A0 52     LDY @#52
C4DB  4C 9F C9  JMP #C99F

C4DE  20 79 C2  JSR #C279       Test for '=', BRK if failure
C4E1  20 8B C7  JSR #C78B       Evaluate numerical expression


 Interpreter Post-Test subroutine
 --------------------------------

- Checks that (5),Y where y=?3 points to a statement delimiter ';' or <CR>
 or spaces leading thereto.
- If successful, consolidates the (5),Y pointer.
- If unsuccessful, BRK if failure.

C4E4  A4 03     LDY #3
C4E6  88        DEY
C4E7  C8        INY
C4E8  B1 05     LDA (#5),Y
C4EA  C9 20     CMP @#20
C4EC  F0 F9     BEQ #C4E7
C4EE  C9 3B     CMP @#3B
C4F0  F0 04     BEQ #C4F6
C4F2  C9 0D     CMP @#D
C4F4  D0 66     BNE #C55C


  Consolidate (5),Y Pointer subroutine
  ------------------------------------

- Resets the text pointer by setting (5)=(5)+Y and Y=1 where Y=?3.

C4F6  18        CLC
C4F7  98        TYA
C4F8  65 05     ADC #5
C4FA  85 05     STA #5
C4FC  90 02     BCC #C500
C4FE  E6 06     INC #6
C500  A0 01     LDY @#1
C502  84 03     STY #3


  Check for <ESC> key subroutine
  ------------------------------

- If <ESC> pressed then RTS, otherwise jumps to the Direct Mode.

C504  AD 01 B0  LDA #B001
C507  29 20     AND @#20
C509  F0 3C     BEQ #C547
C50B  60        RTS


  Get Current Text Line Number subroutine
  ---------------------------------------

- Copies the new line number to 1,2 and updates the label address if the
  line is labelled.
- Sets up the (5),Y text pointer to the start of the statement.

C50C  20 E4 C4  JSR #C4E4
C50F  88        DEY
C510  B1 05     LDA (#5),Y
C512  C9 3B     CMP @#3B
C514  F0 F5     BEQ #C50B
C516  A5 06     LDA #6
C518  C9 01     CMP @#1
C51A  F0 7A     BEQ #C596
C51C  C8        INY
C51D  B1 05     LDA (#5),Y
C51F  30 3B     BMI #C55C
C521  85 02     STA #2
C523  C8        INY
C524  B1 05     LDA (#5),Y
C526  85 01     STA #1
C528  C8        INY
C529  B1 05     LDA (#5),Y
C52B  88        DEY
C52C  C9 61     CMP @#61
C52E  90 C7     BCC #C4F7
C530  E9 61     SBC @#61
C532  C9 1B     CMP @#1B
C534  B0 C0     BCS #C4F6
C536  C8        INY
C537  0A        ASL A
C538  AA        TAX
C539  20 F6 C4  JSR #C4F6
C53C  A5 05     LDA #5
C53E  9D 8D 03  STA #38D,X
C541  A5 06     LDA #6
C543  9D 8E 03  STA #38E,X
C546  60        RTS


C547  4C CF C2  JMP #C2CF
-- missing data
C5B5  20 E4 C4  JSR #C4E4
C3B8  AD 22 03  LDA #322
C3BB  AE 39 03  LDX #339
C3BE  AC 3A 03  LDY #33A
C3C1  20 A5 C2  JSR #C2A5
C3C4  D8        CLD
C3C5  4C 5B C5  JMP #C55B


  Function Interpreter subroutine
  -------------------------------

- Evaluates an arbitrarily complex function pointed to by (5),Y where y=?3
  and stores the result on the Workspace Stack pointed to by ?5 and also
  on the arithmetic Workspace Stack at #52 (LSB),#53,#54,#55 (MSB).
- The (5),Y pointer is consolidated before return, so that (5),0 points to
  the last character in the string interpreted.

C3C8  20 BC C8  JSR #C8BC
C3CB  A0 52     LDY @#52
C3CD  CA        DEX
C3CE  86 04     STX #4
C3D0  B5 16     LDA #16,X
C3D2  99 00 00  STA #0,Y
C3D5  B5 25     LDA #25,X
C3D7  99 01 00  STA #1,Y
C3DA  B5 34     LDA #34,X
C3DC  99 02 00  STA #2,Y
C3DF  B5 43     LDA #43,X
C3E1  99 03 00  STA #3,Y
C3E4  60        RTS


  Deals with Numerical Assignments
  --------------------------------

- Sets pre-interpreted variable to an arbitrarily complex expression.

C3E5  20 E1 C4  JSR #C4E1
C3E8  20 2F CA  JSR #CA2F
C3EB  4C 5B C5  JMP #C55B


  Execute the command '!'
  -----------------------

- Sets pre-interpreted vector to an arbitrarily complex expression.

C3EE  20 BC C8  JSR #C8BC
C3F1  20 93 CE  JSR #CE93
C3F4  B5 26     LDA #26,X
C3F6  C8        INY
C3F7  91 52     STA (#52),Y
C3F9  C8        INY
C3FA  B5 35     LDA #35,X
C3FC  91 52     STA (#52),Y
C3FE  C8        INY
C3FF  B5 44     LDA #44,X
C401  91 52     STA (#52),Y
C403  4C 5B C5  JMP #C55B


  Execute the command '?'
  -----------------------

- Sets pre-interpreted byte to an arbitrarily complex expression.

C406  20 BC C8  JSR #C8BC
C409  20 93 CE  JSR #CE93
C40C  4C 5B C5  JMP #C55B


  Execute COS commands
  --------------------

- Deals with * prefixed commands.
- Copies the string after the '*' prefix pointed to by (5),Y where Y=?3
  to the Direct Mode buffer at #100 and then calls OSCLI indirected
  by vector (#206,#207).

C40F  A2 00     LDX @#0
C411  B1 05     LDA (#5),Y
C413  9D 00 01  STA #100,X
C416  84 03     STY #3
C418  C8        INY
C419  E8        INX
C41A  C9 0D     CMP @#D
C41C  D0 F3     BNE #C411
C41E  20 F7 FF  JSR #FFF7
C421  4C 58 C5  JMP #C558


  Floating Point ROM Check subroutine
  -----------------------------------

- Returns with Carry set if the FP ROM at #D000 exists.

C424  AD 00 D0  LDA #D000
C427  C9 AA     CMP @#AA
C429  D0 38     BNE #C463
C42B  4A        LSR A
C42C  CD 01 D0  CMP #D001
C42F  D0 32     BNE #C463
C431  A4 5E     LDY #5E
C433  60        RTS


  Interpreter Pre-Test subroutine
  -------------------------------

- Reads the character pointed to by (5),Y where y=?3 and returns a
- character number where @=0, A=1 etc up to Z=26.
- Returns with Carry set if the following character is alphanumeric too.

C434  A4 03     LDY #3
C436  10 03     BPL #C43B
C438  C8        INY
C439  84 03     STY #3
C43B  B1 05     LDA (#5),Y
C43D  C9 20     CMP @#20
C43F  F0 F7     BEQ #C438
C441  C9 5B     CMP @#5B
C443  B0 1E     BCS #C463
C445  E9 3F     SBC @#3F
C447  90 1B     BCC #C464
C449  A6 04     LDX #4
C44B  95 16     STA #16,X
C44D  C8        INY
C44E  B1 05     LDA (#5),Y
C450  C9 2E     CMP @#2E
C452  F0 0F     BEQ #C463
C454  C9 5B     CMP @#5B
C456  B0 04     BCS #C45C
C458  C9 40     CMP @#40
C45A  B0 07     BCS #C463
C45C  E8        INX
C45D  86 04     STX #4
C45F  38        SEC
C460  84 03     STY #3
C462  60        RTS
C463  18        CLC
C464  60        RTS


  Read Decimal String subroutine
  ------------------------------

- Reads string pointed to by (5),Y where Y=?3 as ASCII decimal characters,
  stores the binary result in the Workspace Stack at 16,X where X=?4
  and increments the Workspace Stack pointer ?4.
- If the first non-space character is not a number, BRK is executed.
- Destroys A,X,Y registers.

C465  20 34 C4  JSR #C434       If next symbol is a <variable>, BRK
C468  B0 BB     BCS #C425
                                GET POSITIVE NUMBER
                                (return with Carry clear if no number)
C46A  A2 00     LDX @#0
C46C  A4 03     LDY #3
C46E  86 52     STX #52
C470  86 53     STX #53
C472  86 54     STX #54
C474  86 55     STX #55
C476  88        DEY
C477  C8        INY
C478  B1 05     LDA (#5),Y
C47A  38        SEC
C47B  E9 30     SBC @#30
C47D  30 54     BMI #C4D3
C47F  C9 0A     CMP @#A
C481  B0 50     BCS #C4D3
C483  A6 53     LDX #53
C485  48        PHA
C486  A5 55     LDA #55
C488  48        PHA
C489  A5 54     LDA #54
C48B  48        PHA
C48C  A5 52     LDA #52
C48E  0A        ASL A
C48F  26 53     ROL #53
C491  26 54     ROL #54
C493  26 55     ROL #55
C495  30 D4     BMI #C46B
C497  0A        ASL A
C498  26 53     ROL #53
C49A  26 54     ROL #54
C49C  26 55     ROL #55
C49E  30 CB     BMI #C46B
C4A0  65 52     ADC #52
C4A2  85 52     STA #52
C4A4  8A        TXA
C4A5  65 53     ADC #53
C4A7  85 53     STA #53
C4A9  68        PLA
C4AA  65 54     ADC #54
C4AC  85 54     STA #54
C4AE  68        PLA
C4AF  65 55     ADC #55
C4B1  06 52     ASL #52
C4B3  26 53     ROL #53
C4B5  26 54     ROL #54
C4B7  2A        ROL A
C4B8  30 B1     BMI #C46B
C4BA  85 55     STA #55
C4BC  68        PLA
C4BD  65 52     ADC #52
C4BF  85 52     STA #52
C4C1  90 0C     BCC #C4CF
C4C3  E6 53     INC #53
C4C5  D0 08     BNE #C4CF
C4C7  E6 54     INC #54
C4C9  D0 04     BNE #C4CF
C4CB  E6 55     INC #55
C4CD  30 9C     BMI #C46B
C4CF  A2 FF     LDX @#FF
C4D1  D0 A4     BNE #C477
C4D3  8A        TXA
C4D4  F0 8D     BEQ #C463
C4D6  38        SEC
C4D7  84 03     STY #3
C4D9  A0 52     LDY @#52
C4DB  4C 9F C9  JMP #C99F


C4DE  20 79 C2  JSR #C279       Test for '=', BRK if failure
C4E1  20 8B C7  JSR #C78B       Evaluate numerical expression


  Interpreter Post-Test subroutine
  --------------------------------

- Checks that (5),Y where y=?3 points to a statement delimiter ';' or <CR>
  or spaces leading thereto.
- If successful, consolidates the (5),Y pointer.
- If unsuccessful, BRK if failure.

C4E4  A4 03     LDY #3
C4E6  88        DEY
C4E7  C8        INY
C4E8  B1 05     LDA (#5),Y
C4EA  C9 20     CMP @#20
C4EC  F0 F9     BEQ #C4E7
C4EE  C9 3B     CMP @#3B
C4F0  F0 04     BEQ #C4F6
C4F2  C9 0D     CMP @#D
C4F4  D0 66     BNE #C55C


  Consolidate (5),Y Pointer subroutine
  ------------------------------------

- Resets the text pointer by setting (5)=(5)+Y and Y=1 where Y=?3.

C4F6  18        CLC
C4F7  98        TYA
C4F8  65 05     ADC #5
C4FA  85 05     STA #5
C4FC  90 02     BCC #C500
C4FE  E6 06     INC #6
C500  A0 01     LDY @#1
C502  84 03     STY #3


  Check for <ESC> key subroutine
  ------------------------------

- If <ESC> pressed then RTS, otherwise jumps to the Direct Mode.

C504  AD 01 B0  LDA #B001
C507  29 20     AND @#20
C509  F0 3C     BEQ #C547
C50B  60        RTS


  Get Current Text Line Number subroutine
  ---------------------------------------

- Copies the new line number to 1,2 and updates the label address if the
  line is labelled.
- Sets up the (5),Y text pointer to the start of the statement.

C50C  20 E4 C4  JSR #C4E4
C50F  88        DEY
C510  B1 05     LDA (#5),Y
C512  C9 3B     CMP @#3B
C514  F0 F5     BEQ #C50B
C516  A5 06     LDA #6
C518  C9 01     CMP @#1
C51A  F0 7A     BEQ #C596
C51C  C8        INY
C51D  B1 05     LDA (#5),Y
C51F  30 3B     BMI #C55C
C521  85 02     STA #2
C523  C8        INY
C524  B1 05     LDA (#5),Y
C526  85 01     STA #1
C528  C8        INY
C529  B1 05     LDA (#5),Y
C52B  88        DEY
C52C  C9 61     CMP @#61
C52E  90 C7     BCC #C4F7
C530  E9 61     SBC @#61
C532  C9 1B     CMP @#1B
C534  B0 C0     BCS #C4F6
C536  C8        INY
C537  0A        ASL A
C538  AA        TAX
C539  20 F6 C4  JSR #C4F6
C53C  A5 05     LDA #5
C53E  9D 8D 03  STA #38D,X
C541  A5 06     LDA #6
C543  9D 8E 03  STA #38E,X
C546  60        RTS


C547  4C CF C2  JMP #C2CF


  Statement Executer
  ------------------

- Executes a statement pointed to by (5),Y.
- Jumps indirectly to the FP ROM via (#D002) if the command cannot be
  interpreted.

C54A  88        DEY
C54B  20 F6 C4  JSR #C4F6
C54E  D0 0B     BNE #C55B
C550  20 24 C4  JSR #C424       Handle unrecognised statement
C553  90 03     BCC #C558
C555  6C 02 D0  JMP (#D002)
C558  20 E4 C4  JSR #C4E4


  Return Routine
  --------------

- All routines generally return to BASIC here.
- Goes on to interpret the next statement.

C55B  A0 00     LDY @#0
C55D  B1 05     LDA (#5),Y
C55F  C9 3B     CMP @#3B
C561  D0 1A     BNE #C57D
C563  4C 1B C3  JMP #C31B


  Execute the command 'IF'
  ------------------------

- Puts a zero on the Workspace Stack at #16,X where X=?4 if false.

C566  20 0C C7  JSR #C70C
C569  CA        DEX
C56A  86 04     STX #4
C56C  B5 16     LDA #16,X
C56E  F0 05     BEQ #C575
C570  A2 20     LDX @#20
C572  4C 33 C2  JMP #C233


  Execute the command 'REM'
  -------------------------

- Increments (5),Y until a <CR> is found.

C575  A9 0D     LDA @#D
C577  88        DEY
C578  C8        INY
C579  D1 05     CMP (#5),Y
C57B  D0 FB     BNE #C578
C57D  A5 06     LDA #6
C57F  C9 01     CMP @#1
C581  F0 C4     BEQ #C547
C583  20 1C C5  JSR #C51C
C586  4C 1B C3  JMP #C31B


  Print Decimal subroutine
  ------------------------

- Prints the lowest level of the Workspace Stack #16,#25,#34,#43 as a
  signed decimal number in field size set by the LSB of the integer
  variable '@' #321.
- Destroys A,X,Y registers.

C589  A5 43     LDA #43
C58B  85 27     STA #27
C58D  10 04     BPL #C593
C58F  E8        INX
C590  20 C4 C8  JSR #C8C4
C593  A2 09     LDX @#9
C595  A9 00     LDA @#0
C597  95 45     STA #45,X
C599  38        SEC
C59A  A5 16     LDA #16
C59C  FD 08 C6  SBC #C608,X
C59F  48        PHA
C5A0  A5 25     LDA #25
C5A2  FD 10 C6  SBC #C610,X
C5A5  48        PHA
C5A6  A5 34     LDA #34
C5A8  FD 1A C6  SBC #C61A,X
C5AB  A8        TAY
C5AC  A5 43     LDA #43
C5AE  FD 24 C6  SBC #C624,X
C5B1  90 0E     BCC #C5C1
C5B3  85 43     STA #43
C5B5  84 34     STY #34
C5B7  68        PLA
C5B8  85 25     STA #25
C5BA  68        PLA
C5BB  85 16     STA #16
C5BD  F6 45     INC #45,X
C5BF  D0 D8     BNE #C599
C5C1  68        PLA
C5C2  68        PLA
C5C3  CA        DEX
C5C4  10 CF     BPL #C595
C5C6  A2 0A     LDX @#A
C5C8  CA        DEX
C5C9  F0 04     BEQ #C5CF
C5CB  B5 45     LDA #45,X
C5CD  F0 F9     BEQ #C5C8
C5CF  86 52     STX #52
C5D1  24 27     BIT #27
C5D3  10 02     BPL #C5D7
C5D5  E6 52     INC #52
C5D7  38        SEC
C5D8  AD 21 03  LDA #321
C5DB  F0 02     BEQ #C5DF
C5DD  E9 01     SBC @#1
C5DF  E5 52     SBC #52
C5E1  F0 0B     BEQ #C5EE
C5E3  90 09     BCC #C5EE
C5E5  A8        TAY
C5E6  A9 20     LDA @#20
C5E8  20 4C CA  JSR #CA4C
C5EB  88        DEY
C5EC  D0 F8     BNE #C5E6
C5EE  24 27     BIT #27
C5F0  10 05     BPL #C5F7
C5F2  A9 2D     LDA @#2D
C5F4  20 4C CA  JSR #CA4C
C5F7  B5 45     LDA #45,X
C5F9  C9 0A     CMP @#A
C5FB  90 02     BCC #C5FF
C5FD  69 06     ADC @#6
C5FF  69 30     ADC @#30
C601  20 4C CA  JSR #CA4C
C604  CA        DEX
C605  10 F0     BPL #C5F7
C607  60        RTS


  Decimal Print Data Table
  ------------------------

C608                          01 0A 64 E8 10 A0 40 80
C610  00 00 00 03 27 86 42 96 E1 CA 00 00 00 00 00 01
C620  0F 98 F5 9A 00 00 00 00 00 00 00 00 05 3B


  Line Number Search subroutine
  -----------------------------

- Searches text looking for a line number match.
- Line number searched for is assumed to be on the 16,X Workspace Stack
  where X=?4-1.
- Returns with (58),Y pointing to the character following the line number
  and Carry clear.
- Failure indicated by Carry set.

C62E  C6 04     DEC #4
C630  A6 04     LDX #4
C632  A0 00     LDY @#0
C634  84 58     STY #58
C636  A5 12     LDA #12
C638  85 59     STA #59
C63A  88        DEY
C63B  A9 0D     LDA @#D
C63D  C8        INY
C63E  D1 58     CMP (#58),Y
C640  D0 FB     BNE #C63D
C642  20 A1 CE  JSR #CEA1
C645  B1 58     LDA (#58),Y
C647  C8        INY
C648  D5 25     CMP #25,X
C64A  90 EF     BCC #C63B
C64C  D0 12     BNE #C660
C64E  B1 58     LDA (#58),Y
C650  D5 16     CMP #16,X
C652  90 E7     BCC #C63B
C654  D0 0A     BNE #C660
C656  85 01     STA #1
C658  B5 25     LDA #25,X
C65A  85 02     STA #2
C65C  20 A1 CE  JSR #CEA1
C65F  18        CLC
C660  60        RTS


  Set up Miscellaneous Workspace for Multiply or Divide subroutine
  ----------------------------------------------------------------

C661  20 BC C8  JSR #C8BC
C664  B5 42     LDA #42,X
C666  55 41     EOR #41,X
C668  85 52     STA #52
C66A  20 05 C9  JSR #C905
C66D  A0 53     LDY @#53
C66F  20 CD C3  JSR #C3CD
C672  B5 42     LDA #42,X
C674  95 43     STA #43,X
C676  20 07 C9  JSR #C907
C679  A0 57     LDY @#57
C67B  20 CD C3  JSR #C3CD
C67E  A0 00     LDY @#0
C680  84 5B     STY #5B
C682  84 5C     STY #5C
C684  84 5D     STY #5D
C686  84 5E     STY #5E
C688  60        RTS


  Division subroutine
  -------------------

- Do division in miscellaneous workspace.

C689  20 61 C6  JSR #C661
C68C  A5 54     LDA #54
C68E  20 05 C7  JSR #C705
C691  F0 EC     BEQ #C67F
C693  A0 20     LDY @#20
C695  88        DEY
C696  F0 41     BEQ #C6D9
C698  06 57     ASL #57
C69A  26 58     ROL #58
C69C  26 59     ROL #59
C69E  26 5A     ROL #5A
C6A0  10 F3     BPL #C695
C6A2  26 57     ROL #57
C6A4  26 58     ROL #58
C6A6  26 59     ROL #59
C6A8  26 5A     ROL #5A
C6AA  26 5B     ROL #5B
C6AC  26 5C     ROL #5C
C6AE  26 5D     ROL #5D
C6B0  26 5E     ROL #5E
C6B2  38        SEC
C6B3  A5 5B     LDA #5B
C6B5  E5 53     SBC #53
C6B7  48        PHA
C6B8  A5 5C     LDA #5C
C6BA  E5 54     SBC #54
C6BC  48        PHA
C6BD  A5 5D     LDA #5D
C6BF  E5 55     SBC #55
C6C1  AA        TAX
C6C2  A5 5E     LDA #5E
C6C4  E5 56     SBC #56
C6C6  90 0C     BCC #C6D4
C6C8  85 5E     STA #5E
C6CA  86 5D     STX #5D
C6CC  68        PLA
C6CD  85 5C     STA #5C
C6CF  68        PLA
C6D0  85 5B     STA #5B
C6D2  B0 02     BCS #C6D6
C6D4  68        PLA
C6D5  68        PLA
C6D6  88        DEY
C6D7  D0 C9     BNE #C6A2
C6D9  60        RTS


  Relational Test subroutine
  --------------------------

C6DA  20 8B C7  JSR #C78B
C6DD  CA        DEX
C6DE  86 04     STX #4
C6E0  B5 42     LDA #42,X
C6E2  49 80     EOR @#80
C6E4  85 52     STA #52
C6E6  B5 43     LDA #43,X
C6E8  49 80     EOR @#80
C6EA  85 54     STA #54
C6EC  A0 00     LDY @#0
C6EE  38        SEC
C6EF  B5 15     LDA #15,X
C6F1  F5 16     SBC #16,X
C6F3  85 53     STA #53
C6F5  B5 24     LDA #24,X
C6F7  F5 25     SBC #25,X
C6F9  85 55     STA #55
C6FB  B5 33     LDA #33,X
C6FD  F5 34     SBC #34,X
C6FF  85 56     STA #56
C701  A5 52     LDA #52
C703  E5 54     SBC #54
C705  05 53     ORA #53
C707  05 55     ORA #55
C709  05 56     ORA #56
C70B  60        RTS


  Truth Test subroutine
  ---------------------

- Evaluates an arbitrarily complex expression pointed to by (5),Y where
  Y=?3 and places a zero on the Workspace Stack at 16,X where X=?4.
- Used by IF and UNTIL commands.

C70C  20 2C C7  JSR #C72C
C70F  A2 43     LDX @#43
C711  4C 33 C2  JMP #C233


  Logical AND Truth Test
  ----------------------

C714  20 2C C7  JSR #C72C
C717  B5 14     LDA #14,X
C719  35 15     AND #15,X
C71B  95 14     STA #14,X
C71D  C6 04     DEC #4
C71F  4C 0F C7  JMP #C70F


  Logical OR Truth Test
  ---------------------

C722  20 2C C7  JSR #C72C
C725  B5 14     LDA #14,X
C727  15 15     ORA #15,X
C729  4C 1B C7  JMP #C71B


C72C  A2 46     LDX @#46
C72E  4C 33 C2  JMP #C233


  '$' String Comparison Test
  --------------------------

C731  20 8B C7  JSR #C78B
C734  20 AE CE  JSR #CEAE
C737  B5 15     LDA #15,X
C739  85 54     STA #54
C73B  B5 24     LDA #24,X
C73D  85 55     STA #55
C73F  A0 FF     LDY @#FF
C741  C8        INY
C742  B1 54     LDA (#54),Y
C744  D1 52     CMP (#52),Y
C746  D0 07     BNE #C74F
C748  49 0D     EOR @#D
C74A  D0 F5     BNE #C741
C74C  A8        TAY
C74D  F0 11     BEQ #C760
C74F  A0 00     LDY @#0
C751  F0 0E     BEQ #C761


C753  20 8B C7  JSR #C78B
C756  A2 00     LDX @#0
C758  4C 33 C2  JMP #C233


  Test <expression> = <expression>
  --------------------------------

C75B  20 DA C6  JSR #C6DA
C75E  D0 01     BNE #C761
C760  C8        INY
C761  94 15     STY #15,X
C763  60        RTS


  Test <expression> <= <expression>
  ---------------------------------

C764  20 DA C6  JSR #C6DA
C767  F0 F7     BEQ #C760
C769  90 F5     BCC #C760
C76B  B0 F4     BCS #C761


  Test <expression> <> <expression>
  ---------------------------------

C76D  20 DA C6  JSR #C6DA
C770  D0 EE     BNE #C760
C772  F0 ED     BEQ #C761


  Test <expression> < <expression>
  --------------------------------

C774  20 DA C6  JSR #C6DA
C777  90 E7     BCC #C760
C779  B0 E6     BCS #C761


  Test <expression> >= <expression>
  ---------------------------------

C77B  20 DA C6  JSR #C6DA
C77E  B0 E0     BCS #C760
C780  90 DF     BCC #C761


  Test <expression> > <expression>
  --------------------------------

C782  20 DA C6  JSR #C6DA
C785  F0 DA     BEQ #C761
C787  B0 D7     BCS #C760
C789  90 D6     BCC #C761


  <expression>
  ------------

C78B  20 0B C8  JSR #C80B
C78E  4C 95 C7  JMP #C795

C791  95 41     STA #41,X
C793  C6 04     DEC #4
C795  A2 00     LDX @#0
C797  4C 7B C2  JMP #C27B


  Add 2 Numbers on the Workspace Stack
  ------------------------------------

- {14,X 23,X 32,X 41,X} = {14,X 23,X 32,X 41,X} + {15,X 24,X 33,X 42,X}

C79A  20 0B C8  JSR #C80B
C79D  18        CLC
C79E  B5 14     LDA #14,X
C7A0  75 15     ADC #15,X
C7A2  95 14     STA #14,X
C7A4  B5 23     LDA #23,X
C7A6  75 24     ADC #24,X
C7A8  95 23     STA #23,X
C7AA  B5 32     LDA #32,X
C7AC  75 33     ADC #33,X
C7AE  95 32     STA #32,X
C7B0  B5 41     LDA #41,X
C7B2  75 42     ADC #42,X
C7B4  4C 91 C7  JMP #C791


  Subtract 2 Numbers on the Workspace Stack
  -----------------------------------------

- {14,X 23,X 32,X 41,X} = {14,X 23,X 32,X 41,X} - {15,X 24,X 33,X 42,X}

C7B7  20 0B C8  JSR #C80B
C7BA  B5 14     LDA #14,X
C7BC  F5 15     SBC #15,X
C7BE  95 14     STA #14,X
C7C0  B5 23     LDA #23,X
C7C2  F5 24     SBC #24,X
C7C4  95 23     STA #23,X
C7C6  B5 32     LDA #32,X
C7C8  F5 33     SBC #33,X
C7CA  95 32     STA #32,X
C7CC  B5 41     LDA #41,X
C7CE  F5 42     SBC #42,X
C7D0  4C 91 C7  JMP #C791


  Logically OR 2 Numbers on the Workspace Stack
  ---------------------------------------------

- {14,X 23,X 32,X 41,X} = {14,X 23,X 32,X 41,X} OR {15,X 24,X 33,X 42,X}

C7D3  20 0B C8  JSR #C80B
C7D6  B5 14     LDA #14,X
C7D8  15 15     ORA #15,X
C7DA  95 14     STA #14,X
C7DC  B5 23     LDA #23,X
C7DE  15 24     ORA #24,X
C7E0  95 23     STA #23,X
C7E2  B5 32     LDA #32,X
C7E4  15 33     ORA #33,X
C7E6  95 32     STA #32,X
C7E8  B5 41     LDAA#41,X
C7EA  15 42     ORA #42,X
C7EC  4C 91 C7  JMP #C791


  Logically EOR 2 Numbers on the Workspace Stack
  ----------------------------------------------

- {14,X 23,X 32,X 41,X} = {14,X 23,X 32,X 41,X} EOR {15,X 24,X 33,X 42,X}

C7EF  20 0B C8  JSR #C80B
C7F2  B5 14     LDA #14,X
C7F4  55 15     EOR #15,X
C7F6  95 14     STA #14,X
C7F8  B5 23     LDA #23,X
C7FA  55 24     EOR #24,X
C7FC  95 23     STA #23,X
C7FE  B5 32     LDA #32,X
C800  55 33     EOR #33,X
C802  95 32     STA #32,X
C804  B5 41     LDA #41,X
C806  55 42     EOR #42,X
C808  4C 91 C7  JMP #C791


  <term>
  ------

C80B  20 BC C8  JSR #C8BC
C80E  A2 05     LDX @#5
C810  4C 7B C2  JMP #C27B


  <factor> * <factor>
  -------------------

C813  20 61 C6  JSR #C661
C816  46 5A     LSR #5A
C818  66 59     ROR #59
C81A  66 58     ROR #58
C81C  66 57     ROR #57
C81E  90 19     BCC #C839
C820  18        CLC
C821  98        TYA
C822  65 53     ADC #53
C824  A8        TAY
C825  A5 5C     LDA #5C
C827  65 54     ADC #54
C829  85 5C     STA #5C
C82B  A5 5D     LDA #5D
C82D  65 55     ADC #55
C82F  85 5D     STA #5D
C831  A5 5E     LDA #5E
C833  65 56     ADC #56
C835  29 7F     AND @#7F
C837  85 5E     STA #5E
C839  06 53     ASL #53
C83B  26 54     ROL #54
C83D  26 55     ROL #55
C83F  26 56     ROL #56
C841  A5 57     LDA #57
C843  05 58     ORA #58
C845  05 59     ORA #59
C847  05 5A     ORA #5A
C849  D0 CB     BNE #C816
C84B  84 5B     STY #5B
C84D  A5 52     LDA #52
C84F  08        PHP
C850  A0 5B     LDY @#5B
C852  20 9F C9  JSR #C99F
C855  28        PLP
C856  10 03     BPL #C85B
C858  20 C4 C8  JSR #C8C4
C85B  4C 0E C8  JMP #C80E


  <factor> / <factor>
  -------------------

C85E  20 89 C6  JSR #C689
C861  26 57     ROL #57
C863  26 58     ROL #58
C865  26 59     ROL #59
C867  26 5A     ROL #5A
C869  24 52     BIT #52
C86B  08        PHP
C86C  A0 57     LDY @#57
C86E  D0 E2     BNE #C852


  <factor> % <factor>
  -------------------

C870  20 89 C6  JSR #C689
C873  A6 04     LDX #4
C875  B5 44     LDA #44,X
C877  08        PHP
C878  4C 50 C8  JMP #C850


  <factor> & <factor>
  -------------------

C87B  20 BC C8  JSR #C8BC
C87E  CA        DEX
C87F  86 04     STX #4
C881  B5 15     LDA #15,X
C883  35 16     AND #16,X
C885  95 15     STA #15,X
C887  B5 24     LDA #24,X
C889  35 25     AND #25,X
C88B  95 24     STA #24,X
C88D  B5 33     LDA #33,X
C88F  35 34     AND #34,X
C891  95 33     STA #33,X
C893  B5 42     LDA #42,X
C895  35 43     AND #43,X
C897  95 42     STA #42,X
C899  4C 0E C8  JMP #C80E


  <factor> ? <factor>
  -------------------

C89C  20 A2 C8  JSR #C8A2
C89F  4C 0E C8  JMP #C80E
C8A2  20 BC C8  JSR #C8BC
C8A5  18        CLC
C8A6  B5 15     LDA #15,X
C8A8  75 14     ADC #14,X
C8AA  A8        TAY
C8AB  B5 24     LDA #24,X
C8AD  75 23     ADC #23,X
C8AF  CA        DEX
C8B0  4C 53 C9  JMP #C953


  <factor> ! <factor>
  -------------------

C8B3  20 A2 C8  JSR #C8A2
C8B6  20 62 C9  JSR #C962
C8B9  4C 0E C8  JMP #C80E


  Function Interpreter subroutine
  -------------------------------

- Evaluates an arbitrarily complex function pointed to by (5),Y where Y=?3
  and stores the result on the Workspace Stack pointed to by ?4.
- The (5),Y pointer is consolidated before return, so that (5),0 points to
  the last character in the string interpreted.
- The Workspace Stack pointer ?4 is incremented.

C8BC  A2 04     LDX @#4
C8BE  4C 33 C2  JMP #C233

 Negate Current Slot of Workspace Stack
 --------------------------------------

- {15,X 24,X 33,X 42,X} = 0 - {15,X 24,X 33,X 42,X}

C8C1  20 DC C8  JSR #C8DC


 Negate Current Slot of Workspace Stack subroutine
 ------------------------------------------------

- {15,X 24,X 33,X 42,X} = 0 - {15,X 24,X 33,X 42,X}
- Destroys accumulator.

C8C4  38        SEC
C8C5  A9 00     LDA @#0
C8C7  A8        TAY
C8C8  F5 15     SBC #15,X
C8CA  95 15     STA #15,X
C8CC  98        TYA
C8CD  F5 24     SBC #24,X
C8CF  95 24     STA #24,X
C8D1  98        TYA
C8D2  F5 33     SBC #33,X
C8D4  95 33     STA #33,X
C8D6  98        TYA
C8D7  F5 42     SBC #42,X
C8D9  95 42     STA #42,X
C8DB  60        RTS


  Variable Assignment to Workspace
  --------------------------------

C8DC  20 34 C4  JSR #C434
C8DF  90 17     BCC #C8F8
C8E1  B4 15     LDY #15,X


  Variable Assignment to Workspace Stack subroutine
  -------------------------------------------------

- Copies the simple variable pointed to by Y (where 0=@, 1=A, etc to 26=Z)
  to the current slot of the Workspace Stack pointed to by ?4.
- Destroys accumulator.

C8E3  B9 21 03  LDA #321,Y
C8E6  95 15     STA #15,X
C8E8  B9 57 03  LDA #357,Y
C8EB  95 33     STA #33,X
C8ED  B9 3C 03  LDA #33C,Y
C8F0  95 24     STA #24,X
C8F2  B9 72 03  LDA #372,Y
C8F5  95 42     STA #42,X
C8F7  60        RTS


  Do Numerical Assignments
  ------------------------


C8F8  20 6A C4  JSR #C46A
C8FB  B0 FA     BCS #C8F7
C8FD  A2 07     LDX @#7
C8FF  4C 33 C2  JMP #C233


  Execute the Function 'ABS'
  --------------------------

- Performs ABS of function pointed to by (5),Y and places the result on
  the Workspace Stack.

C902  20 BC C8  JSR #C8BC
C905  B5 42     LDA #42,X
C907  30 BB     BMI #C8C4
C909  60        RTS


  Deal with '#'
  -------------

C90A  A2 00     LDX @#0
C90C  86 52     STX #52
C90E  86 53     STX #53
C910  86 54     STX #54
C912  86 55     STX #55
C914  88        DEY
C915  C8        INY
C916  B1 05     LDA (#5),Y
C918  C9 30     CMP @#30
C91A  90 22     BCC #C93E
C91C  C9 3A     CMP @#3A
C91E  90 0A     BCC #C92A
C920  E9 37     SBC @#37
C922  C9 0A     CMP @#A
C924  90 18     BCC #C93E
C926  C9 10     CMP @#10
C928  B0 14     BCS #C93E
C92A  0A        ASL A
C92B  0A        ASL A
C92C  0A        ASL A
C92D  0A        ASL A
C92E  A2 03     LDX @#3
C930  0A        ASL A
C931  26 52     ROL #52
C933  26 53     ROL #53
C935  26 54     ROL #54
C937  26 55     ROL #55
C939  CA        DEX
C93A  10 F4     BPL #C930
C93C  30 D7     BMI #C915
C93E  8A        TXA
C93F  10 18     BPL #C959
C941  4C D6 C4  JMP #C4D6


  Deal with '('
  -------------

C944  20 0C C7  JSR #C70C
C947  A2 0C     LDX @#C
C949  4C 7B C2  JMP #C27B
C94C  20 BC C8  JSR #C8BC


  Deal with '?'
  -------------

C94F  B4 15     LDY #15,X
C951  B5 24     LDA #24,X
C953  85 53     STA #53
C955  84 52     STY #52
C957  CA        DEX
C958  A0 00     LDY @#0
C95A  B1 52     LDA (#52),Y
C95C  4C 7C C9  JMP #C97C


  Deal with '!'
  -------------

C95F  20 4C C9  JSR #C94C
C962  A0 01     LDY @#1
C964  B1 52     LDA (#52),Y
C966  95 24     STA #24,X
C968  C8        INY
C969  B1 52     LDA (#52),Y
C96B  95 33     STA #33,X
C96D  C8        INY
C96E  B1 52     LDA (#52),Y
C970  95 42     STA #42,X
C972  60        RTS


  Read TOP onto Workspace Stack subroutine
  ----------------------------------------

- Reads the TOP value at #D,#E onto the current workspace slot.
- The Workspace Stack pointer ?4 is incremented.

C973  A0 0D     LDY @#D
C975  20 A1 C9  JSR #C9A1
C978  F0 07     BEQ #C981


  Read COUNT onto Workspace Stack subroutine
  ------------------------------------------

- Reads the COUNT value at ?7 onto the current workspace slot

C97A  A5 07     LDA #7
C97C  20 B3 C9  JSR #C9B3
C97F  95 24     STA #24,X
C981  95 33     STA #33,X
C983  95 42     STA #42,X
C985  60        RTS


  Execute the Function 'RND' subroutine
  -------------------------------------

- Generates a new random number at #8,#9,#A,#B,#C and copies it to the   current slot of the Workspace Stack pointed to by ?4.
- The Workspace Stack pointer ?4 is incremented.

C986  A0 20     LDY @#20
C988  A5 0A     LDA #A
C98A  4A        LSR A
C98B  4A        LSR A
C98C  4A        LSR A
C98D  45 0C     EOR #C
C98F  6A        ROR A
C990  26 08     ROL #8
C992  26 09     ROL #9
C994  26 0A     ROL #A
C996  26 0B     ROL #B
C998  26 0C     ROL #C
C99A  88        DEY
C99B  D0 EB     BNE #C988
C99D  A0 08     LDY @#8
C99F  A6 04     LDX #4
C9A1  B9 01 00  LDA #1,Y
C9A4  95 25     STA #25,X
C9A6  B9 02 00  LDA #2,Y
C9A9  95 34     STA #34,X
C9AB  B9 03 00  LDA #3,Y
C9AE  95 43     STA #43,X
C9B0  B9 00 00  LDA #0,Y
C9B3  95 16     STA #16,X
C9B5  E8        INX
C9B6  86 04     STX #4
C9B8  A4 03     LDY #3
C9BA  A9 00     LDA @#0
C9BC  60        RTS


  Execute the Function 'LEN'
  --------------------------

C9BD  20 BC C8  JSR #C8BC
C9C0  20 CB C3  JSR #C3CB
C9C3  A0 00     LDY @#0
C9C5  A9 0D     LDA @#D
C9C7  D1 52     CMP (#52),Y
C9C9  F0 03     BEQ #C9CE
C9CB  C8        INY
C9CC  D0 F9     BNE #C9C7
C9CE  98        TYA
C9CF  4C 7C C9  JMP #C97C

;
;  Deal with the 'CH' operator
;  ---------------------------
C9D2  20 B1 CE  JSR #CEB1
C9D5  4C 58 C9  JMP #C958
;
;  BRK Handler
;  -----------
;- Points the BASIC interpreter at the vector (#10,#11) which is normally  set to point to #C9E7.
;- Exits to the Diect Mode.
C9D8  68        PLA
C9D9  68        PLA
C9DA  85 00     STA #0
C9DC  A5 10     LDA #10
C9DE  85 05     STA #5
C9E0  A5 11     LDA #11
C9E2  85 06     STA #6
C9E4  4C F2 C2  JMP #C2F2
;
C9E7                       40 3D 31 3B 50 2E 24 36 24  .......@=1;P.$6$
C9F0  37 27 22 45 52 52 4F 52 20 22 3F 30 3B 40 3D 38  7'"ERROR "?0;@=8
CA00  3B 49 46 3F 31 7C 3F 32 50 2E 22 20 4C 49 4E 45  ;IF?1|?2P." LINE
CA10  22 21 31 26 20 23 46 46 46 46 0D 00 00 50 2E 27  "!1& #FFFF...P.'
CA20  3B 45 2E 0D                                      ;E..

;
;  Handle Unrecognised Command
;  ---------------------------
;- Jumps indirectly to (#D002) if the FP ROM exists, otherwise executes BRK.
CA24  20 24 C4  JSR #C424
CA27  90 F2     BCC #CA1B
CA29  6C 04 D0  JMP (#D004)


  Assign Integer Variable
  -----------------------

- Copies the last value on the Workspace Stack to the integer variable
  pointed to by Y (where 0=@, 1=A, etc to 26=Z).
- Workspace Stack pointer is decremented TWICE.

CA2C  20 8B C7  JSR #C78B
CA2F  A6 04     LDX #4
CA31  CA        DEX
CA32  CA        DEX
CA33  86 04     STX #4
CA35  B4 16     LDY #16,X


  Assign Integer Variable subroutine
  ----------------------------------

- Copies the value on the Workspace Stack pointed to by X to the integer
  variable pointed to by Y (where 0=@, 1=A, etc to 26=Z).
- Destroys accumulator.

CA37  B5 17     LDA #17,X
CA39  99 21 03  STA #321,Y
CA3C  B5 26     LDA #26,X
CA3E  99 3C 03  STA #33C,Y
CA41  B5 35     LDA #35,X
CA43  99 57 03  STA #357,Y
CA46  B5 44     LDA #44,X
CA48  99 72 03  STA #372,Y
CA4B  60        RTS


  Increment 'COUNT' and Print Character subroutine
  ------------------------------------------------

- Increments COUNT at ?7 and the prints the contents of the accumulator.

CA4C  E6 07     INC #7
CA4E  6C 08 02  JMP (#208)


  Execute the Command 'LIST'
  --------------------------

- X register must be zero on entry.
- Exits to the Direct Mode.

CA51  A9 00     LDA @#0
CA53  20 7C C9  JSR #C97C
CA56  A9 FF     LDA @#FF
CA58  20 7C C9  JSR #C97C
CA5B  85 04     STA #4
CA5D  A0 7F     LDY @#7F
CA5F  84 26     STY #26
CA61  20 65 C4  JSR #C465
CA64  90 52     BCC #CAB8
CA66  20 31 C2  JSR #C231
CA69  B0 58     BCS #CAC3
CA6B  20 65 C4  JSR #C465
CA6E  A2 01     LDX @#1
CA70  86 04     STX #4
CA72  20 E4 C4  JSR #C4E4
CA75  20 2E C6  JSR #C62E
CA78  90 30     BCC #CAAA
CA7A  88        DEY
CA7B  B0 21     BCS #CA9E
CA7D  A9 05     LDA @#5
CA7F  8D 21 03  STA #321
CA82  20 89 C5  JSR #C589
CA85  A9 08     LDA @#8
CA87  8D 21 03  STA #321
CA8A  A4 03     LDY #3
CA8C  B1 58     LDA (#58),Y
CA8E  C9 0D     CMP @#D
CA90  F0 06     BEQ #CA98
CA92  20 4C CA  JSR #CA4C
CA95  C8        INY
CA96  D0 F4     BNE #CA8C
CA98  20 54 CD  JSR #CD54
CA9B  20 A1 CE  JSR #CEA1
CA9E  B1 58     LDA (#58),Y
CAA0  85 25     STA #25
CAA2  C8        INY
CAA3  B1 58     LDA (#58),Y
CAA5  85 16     STA #16
CAA7  C8        INY
CAA8  84 03     STY #3
CAAA  A5 16     LDA #16
CAAC  18        CLC
CAAD  E5 17     SBC #17
CAAF  A5 25     LDA #25
CAB1  E5 26     SBC #26
CAB3  90 C8     BCC #CA7D
CAB5  4C CF C2  JMP #C2CF
CAB8  20 31 C2  JSR #C231
CABB  E6 04     INC #4
CABD  20 65 C4  JSR #C465
CAC0  4C 6E CA  JMP #CA6E
CAC3  A5 16     LDA #16
CAC5  A4 25     LDY #25
CAC7  85 17     STA #17
CAC9  84 26     STY #26
CACB  B0 A1     BCS #CA6E


  Execute the Command 'NEXT'
  --------------------------

CACD  20 34 C4  JSR #C434
CAD0  A4 15     LDY #15
CAD2  F0 10     BEQ #CAE4
CAD4  90 0F     BCC #CAE5
CAD6  C6 04     DEC #4
CAD8  B5 15     LDA #15,X
CADA  D9 3F 02  CMP #23F,Y
CADD  F0 06     BEQ #CAE5
CADF  88        DEY
CAE0  84 15     STY #15
CAE2  D0 F6     BNE #CADA
CAE4  00        BRK
CAE5  BE 3F 02  LDX #23F,Y
CAE8  18        CLC
CAE9  BD 21 03  LDA #321,X
CAEC  79 4A 02  ADC #24A,Y
CAEF  9D 21 03  STA #321,X
CAF2  85 52     STA #52
CAF4  BD 3C 03  LDA #33C,X
CAF7  79 55 02  ADC #255,Y
CAFA  9D 3C 03  STA #33C,X
CAFD  85 53     STA #53
CAFF  BD 57 03  LDA #357,X
CB02  79 60 02  ADC #260,Y
CB05  9D 57 03  STA #357,X
CB08  85 54     STA #54
CB0A  BD 72 03  LDA #372,X
CB0D  79 6B 02  ADC #26B,Y
CB10  9D 72 03  STA #372,X
CB13  AA        TAX
CB14  A5 52     LDA #52
CB16  38        SEC
CB17  F9 76 02  SBC #276,Y
CB1A  85 52     STA #52
CB1C  A5 53     LDA #53
CB1E  F9 81 02  SBC #281,Y
CB21  85 53     STA #53
CB23  A5 54     LDA #54
CB25  F9 8C 02  SBC #28C,Y
CB28  85 54     STA #54
CB2A  8A        TXA
CB2B  F9 97 02  SBC #297,Y
CB2E  05 52     ORA #52
CB30  05 53     ORA #53
CB32  05 54     ORA #54
CB34  F0 0F     BEQ #CB45
CB36  8A        TXA
CB37  59 6B 02  EOR #26B,Y
CB3A  59 97 02  EOR #297,Y
CB3D  10 04     BPL #CB43
CB3F  B0 04     BCS #CB45
CB41  90 0F     BCC #CB52
CB43  B0 0D     BCS #CB52
CB45  B9 A2 02  LDA #2A2,Y
CB48  85 05     STA #5
CB4A  B9 AD 02  LDA #2AD,Y
CB4D  85 06     STA #6
CB4F  4C FF CB  JMP #CBFF

CB52  C6 15     DEC #15
CB54  4C 58 C5  JMP #C558


  Execute the Command 'FOR'
  -------------------------

CB57  20 34 C4  JSR #C434
CB5A  90 11     BCC #CB6D
CB5C  20 79 C2  JSR #C279
CB5F  20 2C CA  JSR #CA2C
CB62  98        TYA
CB63  A4 15     LDY #15
CB65  C0 0B     CPY @#B
CB67  B0 04     BCS #CB6D
CB69  99 40 02  STA #240,Y
CB6C  A9 00     LDA @#0
CB6E  99 6C 02  STA #26C,Y
CB71  99 61 02  STA #261,Y
CB74  99 56 02  STA #256,Y
CB77  A9 01     LDA @#1
CB79  99 4B 02  STA #24B,Y
CB7C  A2 16     LDX @#16
CB7E  4C 33 C2  JMP #C233


  Execute the Command 'TO'
  ------------------------

CB81  20 8B C7  JSR #C78B
CB84  A4 15     LDY #15
CB86  CA        DEX
CB87  86 04     STX #4
CB89  B5 16     LDA #16,X
CB8B  99 77 02  STA #277,Y
CB8E  B5 25     LDA #25,X
CB90  99 82 02  STA #282,Y
CB93  B5 34     LDA #34,X
CB95  99 8D 02  STA #28D,Y
CB98  B5 43     LDA #43,X
CB9A  99 98 02  STA #298,Y
CB9D  A2 1A     LDX @#1A
CB9F  4C 33 C2  JMP #C233


  Execute the Command 'STEP'
  --------------------------

CBA2  20 8B C7  JSR #C78B
CBA5  A4 15     LDY #15
CBA7  CA        DEX
CBA8  86 04     STX #4
CBAA  B5 16     LDA #16,X
CBAC  99 4B 02  STA #24B,Y
CBAF  B5 25     LDA #25,X
CBB1  99 56 02  STA #256,Y
CBB4  B5 34     LDA #34,X

CBB6  99 61 02  STA #261,Y
CBB9  B5 43     LDA #43,X
CBBB  99 6C 02  STA #26C,Y

			; CONFLICT: some ROM binaries say:
			; CBB6  99 62 02  STA #262,Y	; 62 not 61
			; CBB9  B5 43     LDA #43,X
			; CBBB  99 6d 02  STA #26D,Y	; 6D not 6C


CBBE  20 0C C5  JSR #C50C
CBC1  A4 15     LDY #15
CBC3  A5 05     LDA #5
CBC5  99 A3 02  STA #2A3,Y
CBC8  A5 06     LDA #6
CBCA  99 AE 02  STA #2AE,Y
CBCD  E6 15     INC #15
CBCF  4C 1B C3  JMP #C31B


  Execute the Command 'GOSUB'
  ---------------------------

CBD2  20 1F CC  JSR #CC1F
CBD5  20 0C C5  JSR #C50C
CBD8  A4 14     LDY #14
CBDA  C0 0E     CPY @#E
CBDC  B0 22     BCS #CC00
CBDE  A5 05     LDA #5
CBE0  99 CF 02  STA #2CF,Y
CBE3  A5 06     LDA #6
CBE5  99 DD 02  STA #2DD,Y
CBE8  E6 14     INC #14
CBEA  90 1F     BCC #CC0B


  Execute the Command 'RETURN'
  ----------------------------

CBEC  20 E4 C4  JSR #C4E4
CBEF  A4 14     LDY #14
CBF1  F0 2A     BEQ #CC1D
CBF3  C6 14     DEC #14
CBF5  B9 CE 02  LDA #2CE,Y
CBF8  85 05     STA #5
CBFA  B9 DC 02  LDA #2DC,Y
CBFD  85 06     STA #6
CBFF  20 00 C5  JSR #C500
CC02  4C 1B C3  JMP #C31B


  Execute the Command 'GOTO'
  --------------------------

CC05  20 1F CC  JSR #CC1F
CC08  20 E4 C4  JSR #C4E4
CC0B  A5 57     LDA #57
CC0D  D0 05     BNE #CC14
CC0F  20 2E C6  JSR #C62E
CC12  B0 69     BCS #CC7D
CC14  A4 58     LDY #58
CC16  A5 59     LDA #59
CC18  84 05     STY #5
CC1A  4C FD CB  JMP #CBFD

CC1D  00        BRK


  Line Number/Label Text Search subroutine
  ----------------------------------------

- Used by 'GOTO' and 'GOSUB' routines.
- Line number copied to #1,#2 if the search is successful.
- If the label address is known, it is copied to #58,#59.
- If the label address is not known, it is searched for and copied to the
  label store as well as to #58,#59.

CC1E  C8        INY
CC1F  B1 05     LDA (#5),Y
CC21  C9 20     CMP @#20
CC23  F0 F9     BEQ #CC1E
CC25  C9 61     CMP @#61
CC27  90 50     BCC #CC79
CC29  85 57     STA #57
CC2B  E9 61     SBC @#61
CC2D  C9 1B     CMP @#1B
CC2F  B0 48     BCS #CC79
CC31  0A        ASL A
CC32  AA        TAX
CC33  BD 8D 03  LDA #38D,X
CC36  85 58     STA #58
CC38  20 F6 C4  JSR #C4F6
CC3B  BD 8E 03  LDA #38E,X
CC3E  85 59     STA #59
CC40  05 58     ORA #58
CC42  D0 34     BNE #CC78
CC44  A8        TAY
CC45  A5 12     LDA #12
CC47  85 59     STA #59
CC49  88        DEY
CC4A  A9 0D     LDA @#D
CC4C  C8        INY
CC4D  D1 58     CMP (#58),Y
CC4F  D0 FB     BNE #CC4C
CC51  C8        INY
CC52  B1 58     LDA (#58),Y
CC54  30 45     BMI #CC9B
CC56  85 02     STA #2
CC58  C8        INY
CC59  B1 58     LDA (#58),Y
CC5B  85 01     STA #1
CC5D  C8        INY
CC5E  B1 58     LDA (#58),Y
CC60  88        DEY
CC61  C5 57     CMP #57
CC63  F0 06     BEQ #CC6B
CC65  20 A1 CE  JSR #CEA1
CC68  4C 4A CC  JMP #CC4A

CC6B  20 A2 CE  JSR #CEA2
CC6E  A5 58     LDA #58
CC70  9D 8D 03  STA #38D,X
CC73  A5 59     LDA #59
CC75  9D 8E 03  STA #38E,X
CC78  60        RTS


CC79  20 BC C8  JSR #C8BC
CC7C  A9 00     LDA @#0
CC7E  85 57     STA #57
CC80  60        RTS


  Execute the Command 'INPUT'
  ---------------------------

CC81  20 72 C3  JSR #C372
CC84  20 34 C4  JSR #C434
CC87  B0 05     BCS #CC8E
CC89  A2 2B     LDX @#2B
CC8B  4C 33 C2  JMP #C233


  Numerical Variable Input
  ------------------------

CC8E  20 09 CD  JSR #CD09
CC91  A5 05     LDA #5
CC93  48        PHA
CC94  A5 06     LDA #6
CC96  48        PHA
CC97  A5 03     LDA #3
CC99  48        PHA
CC9A  A0 00     LDY @#0
CC9C  84 03     STY #3
CC9E  C8        INY
CC9F  84 06     STY #6
CCA1  A0 40     LDY @#40
CCA3  84 05     STY #5
CCA5  20 2C CA  JSR #CA2C
CCA8  68        PLA
CCA9  85 03     STA #3
CCAB  68        PLA
CCAC  85 06     STA #6
CCAE  68        PLA
CCAF  85 05     STA #5
CCB1  A2 2C     LDX @#2C
CCB3  4C 33 C2  JMP #C233


  String Variable Input
  ---------------------

CCB6  20 8B C7  JSR #C78B
CCB9  A0 54     LDY @#54
CCBB  20 CD C3  JSR #C3CD
CCBE  20 09 CD  JSR #CD09
CCC1  A2 40     LDX @#40
CCC3  A0 00     LDY @#0
CCC5  BD 00 01  LDA #100,X
CCC8  91 54     STA (#54),Y
CCCA  C9 0D     CMP @#D
CCCC  F0 B3     BEQ #CC81
CCCE  E8        INX
CCCF  C8        INY
CCD0  D0 F3     BNE #CCC5


  Execute the Command 'UNTIL'
  ---------------------------

CCD2  20 0C C7  JSR #C70C
CCD5  A4 13     LDY #13
CCD7  F0 EB     BEQ #CCC4
CCD9  CA        DEX
CCDA  86 04     STX #4
CCDC  B5 16     LDA #16,X
CCDE  F0 05     BEQ #CCE5
CCE0  C6 13     DEC #13
CCE2  4C 58 C5 9JMP #C558

CCE5  B9 B8 02  LDA #2B8,Y
CCE8  85 05     STA #5
CCEA  B9 C3 02  LDA #2C3,Y
CCED  4C FD CB  JMP #CBFD


  Execute the Command 'DO'
  ------------------------

CCF0  A6 13     LDX #13
CCF2  E0 0B     CPX @#B
CCF4  B0 1A     BCS #CD10
CCF6  88        DEY
CCF7  20 F6 C4  JSR #C4F6
CCFA  A5 05     LDA #5
CCFC  9D B9 02  STA #2B9,X
CCFF  A5 06     LDA #6
CD01  9D C4 02  STA #2C4,X
CD04  E6 13     INC #13
CD06  4C 1B C3  JMP #C31B


  Input to String Input Buffer subroutine
  ---------------------------------------

- Prints a '?' prompt and stores subsequent keypresses in the #140 string
  input buffer.
- Returns when <CR> pressed with Y register pointing to the last character
  entered.
- COUNT is set to zero on return.

CD09  A9 3F     LDA @#3F
CD0B  A0 40     LDY @#40
CD0D  D0 02     BNE #CD11


  Input a Line to Direct Mode Input Buffer subroutine
  ---------------------------------------------------

- Prints the contents of the accumulator and stores subsequent keypresses
  in the #100 Direct Mode input buffer.
- Returns when <CR> pressed with Y register pointing to the last character
  entered.
- COUNT is set to zero on return.

CD0F  A0 00     LDY @#0
CD11  20 4C CA  JSR #CA4C
CD14  84 52     STY #52
CD16  A4 52     LDY #52
CD18  20 E6 FF  JSR #FFE6
CD1B  C9 7F     CMP @#7F
CD1D  D0 07     BNE #CD26
CD1F  88        DEY
CD20  C4 52     CPY #52
CD22  10 F4     BPL #CD18
CD24  30 F0     BMI #CD16
CD26  C9 18     CMP @#18
CD28  D0 06     BNE #CD30
CD2A  20 54 CD  JSR #CD54
CD2D  4C 16 CD  JMP #CD16

CD30  C9 1B     CMP @#1B
CD32  D0 03     BNE #CD37
CD34  4C CF C2  JMP #C2CF

CD37  99 00 01  STA #100,Y
CD3A  C9 0D     CMP @#D
CD3C  F0 19     BEQ #CD57
CD3E  C8        INY
CD3F  98        TYA
CD40  38        SEC
CD41  E5 52     SBC #52
CD43  C9 40     CMP @#40
CD45  90 D1     BCC #CD18
CD47  20 E3 FF  JSR #FFE3
CD4A  C9 7F     CMP @#7F
CD4C  D0 F9     BNE #CD47
CD4E  20 F4 FF  JSR #FFF4
CD51  4C 1F CD  JMP #CD1F


  Print a <CR><LF> subroutine
  ---------------------------

- Sends a <CR><LF> to WRCHAR, and resets COUNT at ?7 to zero.
- Destroys accumulator.

CD54  20 ED FF  JSR #FFED
CD57  A9 00     LDA @#0
CD59  85 07     STA #7
CD5B  60        RTS


  Assign '$' String Variable
  --------------------------

CD5C  20 8B C7  JSR #C78B
CD5F  20 AE CE  JSR #CEAE
CD62  A0 54     LDY @#54
CD64  20 CD C3  JSR #C3CD
CD67  A0 FF     LDY @#FF
CD69  C8        INY
CD6A  B1 52     LDA (#52),Y
CD6C  91 54     STA (#54),Y
CD6E  C9 0D     CMP @#D
CD70  D0 F7     BNE #CD69
CD72  4C 58 C5  JMP #C558


  Assign !<variable>
  ------------------

CD75  20 81 CD  JSR #CD81
CD78  4C F1 C3  JMP #C3F1


  Assign ?<variable>
  ------------------

CD7B  20 81 CD  JSR #CD81
CD7E  4C 09 C4  JMP #C409



  Assignment subroutine
  ---------------------

CD81  20 E1 C8  JSR #C8E1
CD84  20 BC C8  JSR #C8BC
CD87  CA        DEX
CD88  18        CLC
CD89  B5 16     LDA #16,X
CD8B  75 15     ADC #15,X
CD8D  95 15     STA #15,X
CD8F  B5 25     LDA #25,X
CD91  75 24     ADC #24,X
CD93  95 24     STA #24,X
CD95  86 04     STX #4
CD97  60        RTS


  Execute the Command 'END'
  -------------------------

- Finds the end of the current text space, starting at page ?#12, and
  sets the TOP vector #D, #E.
- Exits to Direct Mode.

CD98  20 E4 C4  JSR #C4E4
CD9B  A5 12     LDA #12
CD9D  85 0E     STA #E
CD9F  A0 00     LDY @#0
CDA1  84 0D     STY #D
CDA3  88        DEY
CDA4  C8        INY
CDA5  B1 0D     LDA (#D),Y
CDA7  C9 0D     CMP @#D
CDA9  D0 F9     BNE #CDA4
CDAB  20 BC CD  JSR #CDBC
CDAE  B1 0D     LDA (#D),Y
CDB0  30 03     BMI #CDB5
CDB2  C8        INY
CDB3  D0 EF     BNE #CDA4
CDB5  C8        INY
CDB6  20 BC CD  JSR #CDBC
CDB9  4C CF C2  JMP #C2CF


  END subroutine
  --------------

- Sets TOP=TOP+Y and Y=1.

CDBC  18        CLC
CDBD  98        TYA
CDBE  65 0D     ADC #D
CDC0  85 0D     STA #D
CDC2  90 02     BCC #CDC6
CDC4  E6 0E     INC #E
CDC6  A0 01     LDY @#1
CDC8  60        RTS


  Text Line Insertion and Removal
  -------------------------------

- On entry #16, #17 contain the line number to be entered.

CDC9  84 56     STY #56
CDCB  20 2E C6  JSR #C62E
CDCE  B0 48     BCS #CE18
CDD0  A5 58     LDA #58
CDD2  85 52     STA #52
CDD4  E9 01     SBC @#1
CDD6  85 58     STA #58
CDD8  85 0D     STA #D
CDDA  A5 59     LDA #59
CDDC  85 53     STA #53
CDDE  E9 00     SBC @#0
CDE0  85 0E     STA #E
CDE2  85 59     STA #59
CDE4  A9 0D     LDA @#D
CDE6  C8        INY
CDE7  D1 52     CMP (#52),Y
CDE9  D0 FB     BNE #CDE6
CDEB  18        CLC
CDEC  98        TYA
CDED  65 52     ADC #52
CDEF  85 52     STA #52
CDF1  90 02     BCC #CDF5
CDF3  E6 53     INC #53
CDF5  A0 00     LDY @#0
CDF7  B1 52     LDA (#52),Y
CDF9  91 0D     STA (#D),Y
CDFB  C9 0D     CMP @#D
CDFD  F0 09     BEQ #CE08
CDFF  C8        INY
CE00  D0 F5     BNE #CDF7
CE02  E6 53     INC #53
CE04  E6 0E     INC #E
CE06  D0 EF     BNE #CDF7
CE08  C8        INY
CE09  D0 04     BNE #CE0F
CE0B  E6 53     INC #53
CE0D  E6 0E     INC #E
CE0F  B1 52     LDA (#52),Y
CE11  91 0D     STA (#D),Y
CE13  10 EA     BPL #CDFF
CE15  20 BD CD  JSR #CDBD
CE18  A0 01     LDY @#1
CE1A  84 57     STY #57
CE1C  88        DEY
CE1D  A9 0D     LDA @#D
CE1F  D1 56     CMP (#56),Y
CE21  F0 5D     BEQ #CE80
CE23  C8        INY
CE24  D1 56     CMP (#56),Y
CE26  D0 FB     BNE #CE23
CE28  C8        INY
CE29  C8        INY
CE2A  A5 0D     LDA #D
CE2C  85 54     STA #54
CE2E  A5 0E     LDA #E
CE30  85 55     STA #55
CE32  20 BD CD  JSR #CDBD
CE35  85 52     STA #52
CE37  A5 0E     LDA #E
CE39  85 53     STA #53
CE3B  88        DEY
CE3C  A9 55     LDA @#55
CE3E  91 0D     STA (#D),Y
CE40  D1 0D     CMP (#D),Y
CE42  D0 B2     BNE #CDF6
CE44  0A        ASL A
CE45  91 0D     STA (#D),Y
CE47  D1 0D     CMP (#D),Y
CE49  D0 AB     BNE #CDF6
CE4B  B1 54     LDA (#54),Y
CE4D  91 52     STA (#52),Y
CE4F  98        TYA
CE50  D0 04     BNE #CE56
CE52  C6 55     DEC #55
CE54  C6 53     DEC #53
CE56  88        DEY
CE57  98        TYA
CE58  65 54     ADC #54
CE5A  A6 55     LDX #55
CE5C  90 01     BCC #CE5F
CE5E  E8        INX
CE5F  C5 58     CMP #58
CE61  8A        TXA
CE62  E5 59     SBC #59
CE64  B0 E5     BCS #CE4B
CE66  A0 01     LDY @#1
CE68  A5 25     LDA #25
CE6A  91 58     STA (#58),Y
CE6C  C8        INY
CE6D  A5 16     LDA #16
CE6F  91 58     STA (#58),Y
CE71  38        SEC
CE72  20 A2 CE  JSR #CEA2
CE75  A0 FF     LDY @#FF
CE77  C8        INY
CE78  B1 56     LDA (#56),Y
CE7A  91 58     STA (#58),Y
CE7C  C9 0D     CMP @#D
CE7E  D0 F7     BNE #CE77
CE80  4C CF C2  JMP #C2CF


  Continuation of Execution of the Command 'RUN'
  ----------------------------------------------

- Continuation from #F141.
- Sets the Text Pointer at ?5,?6 to the start of text, and then jumps to
  the interpreter.

CE83  20 E4 C4  JSR #C4E4
CE86  A0 00     LDY @#0
CE88  84 05     STY #5
CE8A  84 03     STY #3
CE8C  A5 12     LDA #12
CE8E  85 06     STA #6
CE90  4C 5B C5  JMP #C55B


  !<factor> and ?<factor> subroutine
  ----------------------------------

CE93  20 DE C4  JSR #C4DE
CE96  CA        DEX
CE97  20 CB C3  JSR #C3CB
CE9A  A0 00     LDY @#0
CE9C  B5 17     LDA #17,X
CE9E  91 52     STA (#52),Y
CEA0  60        RTS


  Update #58, #59 Pointer subroutine
  ----------------------------------

- Sets (#58)=(#58)+Y and Y=1, ?3=1.
- Checks the <ESC> key before return.
- Destroys accumulator.

CEA1  18        CLC
CEA2  98        TYA
CEA3  65 58     ADC #58
CEA5  85 58     STA #58
CEA7  90 02     BCC #CEAB
CEA9  E6 59     INC #59
CEAB  4C 00 C5  JMP #C500


  Set up String Ready for Assignment
  ----------------------------------

CEAE  20 79 C2  JSR #C279


  Check for Valid String subroutine
  ---------------------------------

- Checks for '$' or '"' at the location pointed to by (5),Y where y=?3.
- If successful, returns with (5),?3 pointimg to the character following,
  otherwise executes BRK.

CEB1  A2 26     LDX @#26
CEB3  4C 33 C2  JMP #C233


  Set up $ String Ready for Asssignment
  -------------------------------------

CEB6  20 8B C7  JSR #C78B
CEB9  20 CB C3  JSR #C3CB
CEBC  A4 03     LDY #3
CEBE  60        RTS


  Set up "string" Ready for Asssignment
  -------------------------------------

CEBF  20 F6 C4  JSR #C4F6


  Copy Quoted String to String Input Buffer subroutine
  ----------------------------------------------------

- Copies a string in quotes pointed to by (5),Y to the string input buffer
  at #140.
- Quotation marks are removed.

CEC2  84 53     STY #53
CEC4  88        DEY
CEC5  A2 00     LDX @#0
CEC7  B1 05     LDA (#5),Y
CEC9  C9 0D     CMP @#D
CECB  F0 F9     BEQ #CEC6
CECD  9D 40 01  STA #140,X
CED0  E8        INX
CED1  C8        INY
CED2  C9 22     CMP @#22
CED4  D0 F1     BNE #CEC7
CED6  B1 05     LDA (#5),Y
CED8  C9 22     CMP @#22
CEDA  F0 0E     BEQ #CEEA
CEDC  A9 0D     LDA @#D
CEDE  9D 3F 01  STA #13F,X
CEE1  84 03     STY #3
CEE3  A9 40     LDA @#40
CEE5  85 52     STA #52
CEE7  A6 04     LDX #4
CEE9  60        RTS

CEEA  C8        INY
CEEB  B0 DA     BCS #CEC7


  'LOAD' File
  -----------

CEED  20 FA CE  JSR #CEFA
CEF0  88        DEY
CEF1  84 56     STY #56
CEF3  38        SEC
CEF4  20 E0 FF  JSR #FFE0
CEF7  4C 9B CD  JMP #CD9B


  Load and Save Setup subroutine
  ------------------------------

- Reads the file title into the String Input buffer at #140, and sets
  the vector #54, #55 to the start of text.

CEFA  20 B1 CE  JSR #CEB1
CEFD  20 E4 C4  JSR #C4E4
CF00  88        DEY
CF01  84 54     STY #54
CF03  A5 12     LDA #12
CF05  85 55     STA #55
CF07  A2 52     LDX @#52
CF09  60        RTS


  Execute the Command 'SAVE'
  --------------------------

CF0A  20 FA CE  JSR #CEFA
CF0D  84 58     STY #58
CF0F  85 59     STA #59
CF11  A5 0D     LDA #D
CF13  85 5A     STA #5A
CF15  A5 0E     LDA #E
CF17  85 5B     STA #5B
CF19  A9 B2     LDA @#B2
CF1B  85 56     STA #56
CF1D  A9 C2     LDA @#C2
CF1F  85 57     STA #57
CF21  18        CLC
CF22  20 DD FF  JSR #FFDD
CF25  4C 5B C5  JMP #C55B


CF28  38        SEC
CF29  A9 00     LDA @#0
CF2B  2A        ROL A
CF2C  48        PHA
CF2D  20 3E CF  JSR #CF3E
CF30  A2 52     LDX @#52
CF32  68        PLA
CF33  20 DA FF  JSR #FFDA
CF36  A0 52     LDY @#52
CF38  20 9F C9  JSR #C99F
CF3B  95 42     STA #42,X
CF3D  60        RTS


  Get <factor> into Y Register subroutine
  ---------------------------------------

CF3E  20 BC C8  JSR #C8BC
CF41  B4 15     LDY #15,X
CF43  CA        DEX
CF44  86 04     STX #4
CF46  60        RTS


CF47  20 BC C8  JSR #C8BC
CF4A  20 DE C4  JSR #C4DE
CF4D  20 CB C3  JSR #C3CB
CF50  20 41 CF  JSR #CF41
CF53  A2 52     LDX @#52
CF55  20 D7 FF  JSR #FFD7
CF58  4C 5B C5  JMP #C55B


  Execute 'BGET' subroutine
  -------------------------

- Reads 1 byte from OSBGET into the workspace stack and sets the other
  3 bytes to zero.

CF5B  20 3E CF  JSR #CF3E
CF5E  84 52     STY #52
CF60  20 D4 FF  JSR #FFD4
CF63  4C 7C C9  JMP #C97C


  Execute 'GET' subroutine
  ------------------------

- Reads 4 bytes from OSBGET into the workspace stack.

CF66  20 5B CF  JSR #CF5B
CF69  A4 52     LDY #52
CF6B  20 D4 FF  JSR #FFD4
CF6E  95 24     STA #24,X
CF70  20 D4 FF  JSR #FFD4
CF73  95 33     STA #33,X
CF75  20 D4 FF  JSR #FFD4
CF78  95 42     STA #42,X
CF7A  60        RTS


CF7B  20 BC C8  JSR #C8BC
CF7E  20 31 C2  JSR #C231
CF81  20 E1 C4  JSR #C4E1
CF84  20 CB C3  JSR #C3CB
CF87  20 41 CF  JSR #CF41
CF8A  A5 52     LDA #52
CF8C  6C 16 02  JMP (#216)


  Execute the Command 'BPUT'
  --------------------------

CF8F  20 7B CF  JSR #CF7B
CF92  4C 5B C5  JMP #C55B


  Execute 'PUT' subroutine
  ------------------------

CF95  20 7B CF  JSR #CF7B
CF98  A2 01     LDX @#1
CF9A  B5 52     LDA #52,X
CF9C  20 D1 FF  JSR #FFD1
CF9F  E8        INX
CFA0  E0 04     CPX @#4
CFA2  90 F6     BCC #CF9A
CFA4  B0 EC     BCS #CF92
CFA6  38        SEC
CFA7  08        PHP
CFA8  20 B1 CE  JSR #CEB1
CFAB  A2 52     LDX @#52
CFAD  28        PLP
CFAE  20 CE FF  JSR #FFCE
CFB1  A6 04     LDX #4
CFB3  4C 7C C9  JMP #C97C


CFB6  20 BC C8  JSR #C8BC
CFB9  20 E4 C4  JSR #C4E4
CFBC  20 41 CF  JSR #CF41
CFBF  20 CB FF  JSR #FFCB
CFC2  4C 5B C5  JMP #C55B


  Execute the Command 'SPUT'
  --------------------------

CFC5  20 2C C2  JSR #C22C
CFC8  20 B1 CE  JSR #CEB1
CFCB  20 E4 C4  JSR #C4E4
CFCE  88        DEY
CFCF  B1 52     LDA (#52),Y
CFD1  84 55     STY #55
CFD3  A4 0F     LDY #F
CFD5  48        PHA
CFD6  20 D1 FF  JSR #FFD1
CFD9  68        PLA
CFDA  C9 0D     CMP @#D
CFDC  F0 E4     BEQ #CFC2
CFDE  A4 55     LDY #55
CFE0  C8        INY
CFE1  D0 EC     BNE #CFCF


  Execute the Command 'SGET'
  --------------------------

CFE3  20 2C C2  JSR #C22C
CFE6  20 E1 C4  JSR #C4E1
CFE9  20 CB C3  JSR #C3CB
CFEC  A0 00     LDY @#0
CFEE  84 55     STY #55
CFF0  A4 0F     LDY #F
CFF2  20 D4 FF  JSR #FFD4
CFF5  A4 55     LDY #55
CFF7  91 52     STA (#52),Y
CFF9  C8        INY
CFFA  C9 0D     CMP @#D
CFFC  D0 F0     BNE #CFEE
CFFE  F0 C2     BEQ #CFC2


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              *************************************
              * Disassembly of Atom Extension ROM *
              *         from #D000 to #DFFF       *
              *************************************

Version 1.0
22:11:85


;   Subroutines...
;   **************
;
; D236 Something to do with 'ASN' subroutine
; D303 Get to next non-space character subroutine
; D49A ??? subroutine
; D4C3 ??? subroutine
; D4D0 ??? subroutine
; D587 ??? subroutine
; D594 ??? subroutine
; D636 ??? subroutine
; D642 ??? subroutine
; D64E ??? subroutine
; D67B ??? subroutine
; D686 ??? subroutine
; D6A0 ??? subroutine
; D6C3 Copy the 8 bytes #57..#5E to #5F..66 subroutine
; D6CD Shift Left 1 Bit #5E..#5A subroutine
; D6D8 Shift Right 1 Bit #5A..#5E subroutine
; D6E3 Copy #5A..#5D to #5B..#5E and clear #5A subroutine
; D706 Copy #62..#65 to #63..#66 and clear #62 subroutine
; D71B ??? subroutine
; D778 ??? subroutine
; D7B2 ??? subroutine
; D804 ??? subroutine
; D827 ??? subroutine
; D85D ??? subroutine
; D870 ??? subroutine
; D880 ??? subroutine
; D892 ??? subroutine
; D8BB ??? subroutine
; D8D1 ??? subroutine
; D8E2 ??? subroutine
; D913 ??? subroutine
; D923 ??? subroutine
; DAAE ??? subroutine
; DB9E ??? subroutine
; DBB3 ??? subroutine
; DC27 ??? subroutine
; DD86 ??? subroutine
; DD8A ??? subroutine
; DD93 ??? subroutine
; DE51 ??? subroutine
; DE83 Something to do with 'HTN' subroutine
;
;
;   Other routines...
;   *****************
;
; D000 Extension ROM Existence Check Bytes
; D002 Extension Interpreter Jump Vector
; D004 Extension Interpreter Jump Vector
; D006 Extension Command Table and Jump Addresses
; D0E4 Deal with '('
; D0EB Deal with '+' and '-'
; D0F2 Deal with '*' and '/'
; D0FC Deal with '+' and '-'
; D103 Deal with '^'
; D10E Floating Point interpreter
; D15E Floating Point interpreter
; D177 Deals with '+'
; D183 Deals with '-'
; D18F Deals with '*'
; D19B Deals with '/'
; D1A7 Deals with '^'
; D1BC Deals with '-'
; D1CB Deals with '+'
; D215 Execute the Command 'ABS'
; D21E Execute the Command 'ACS'
; D224 Execute the Command 'ASN'
; D265 Execute the Command 'RAD'
; D273 Execute the Command 'DEG'
; D27C ??? Table
; D286 Execute the Command 'TAN'
; D296 ???
; D29A Execute the Command 'FLT'
; D2C3 Execute the Command 'PI'
; D2CC Execute the Command 'FGET'
; D2E0 Execute the Command 'VAL'
; D30B Execute the Command '%'
; D31F Execute the Command 'STR'
; D331 Execute the Command 'FPRINT'
; D339 ???
; D36A Execute the Command 'FINPUT'
; D3A8 Execute the Command 'FIF'
; D3AE Execute the Command 'FUNTIL'
; D3B4 Execute the Command 'FPUT'
; D3D3 Execute the Command 'FDIM'
; D444 ???
; D494 ???
; D4AF Pass Control to Utility Interpreter, if it Exists
; D933 ???
; D939 ???
; D9EB ???
; D9F6 Execute the conditional test '='
; D9FA Execute the conditional test '<='
; D9FE Execute the conditional test '<>'
; DA02 Execute the conditional test '<'
; DA06 Execute the conditional test '>='
; DA0A Execute the conditional test '>'
; DAC4 Execute the command 'TAN'
; DB6F Execute the command 'SQR'
; DBF9 ??? Table
; DC64 Execute the command 'ATN'
; DCB0 ??? Table
; DCE3 Execute the command 'COS'
; DCEE Execute the command 'SIN'
; DD24 ???
; DD97 ??? Table
; DDD4 Execute the command 'EXP'
; DE23 ??? Table
; DE72 Execute the command 'HTN'
; DED4 ??? Table
; DF02 Execute the command 'COLOUR'
; DF42 Colour Point Plot routine LSB Address Table
; DF46 Colour Point Plot routine MSB Address Table
; DF4A ??? Data Table
; DF4E Colour Byte Table
; DF52 Mode 1 Colour Point Plot routine
; DF70 Mode 2 Colour Point Plot routine
; DF88 Mode 3 Colour Point Plot routine
; DFA0 Mode 4 Colour Point Plot routine


  Extension ROM Existence Check Bytes
  -----------------------------------

D000  AA 55


  Extension Interpreter Jump Vector
  ---------------------------------

- Used by #C54A routine.

D002  0E D1


  Extension Interpreter Jump Vector
  ---------------------------------

- Used by #CA24 routine.

D004  5E D1


  Extension Command Table and Jump Addresses
  ------------------------------------------

D006                    28 D0 E4 41 43 53 D2 1E 41 53        (..ACS..AS
D010  4E D2 24 41 54 4E DC 64 41 42 53 D2 15 43 4F 53  N..ATN..ABS..COS
D020  DC E3 45 58 50 DD D4 48 54 4E DE 72 4C 4F 47 DB  ..EXP..HTN..LOG.
D030  B3 50 49 D2 C3 53 49 4E DC EE 53 51 52 DB 6F 54  .PI..SIN..SQR..T
D040  41 4E DA C4 44 45 47 D2 73 52 41 44 D2 65 53 47  AN..DEG..RAD..SG
D050  4E D2 86 56 41 4C D2 E0 46 4C 54 D2 9A 46 47 45  N..VAL..FLT..FGE
D060  54 D2 CC D2 96 25 D3 0B 46 49 46 D3 A8 46 55 4E  T....%..FIF..FUN
D070  54 49 4C D3 AE 43 4F 4C 4F 55 52 DF 02 46 44 49  TIL..COLOUR..FDI
D080  4D D3 D3 53 54 52 D3 1F 46 50 52 49 4E 54 D3 31  M..STR..FPRINT..
D090  46 49 4E 50 55 54 D3 6A 46 50 55 54 D3 B4 D4 AF  FINPUT..FPUT....
D0A0  2B D1 77 2D D1 83 FE 2A D1 8F 2F D1 9B FE 5E D1  +.w-...*../...^.
D0B0  A7 FE 2B D1 CB 2D D1 BC D1 CB 29 C2 78 FF 3B C5  ..+..-....).x.;.
D0C0  4A 0D C5 4A 2C D3 31 D3 39 2C D3 6A C5 58 3D D9  J..J,.1.9,.j.X=.
D0D0  F6 3C 3E D9 FE 3C 3D D9 FA 3C DA 02 3E 3D DA 06  .<>..<=..<..>=..
D0E0  3E DA 0A FF                                      >...


  Deal with '('
  -------------

D0E4  20 FC D0  JSR #D0FC
D0E7  A2 B4     LDX @#B4        Point to command table at #D0BA
D0E9  D0 20     BNE #D10B


  Deal with '+' and '-'
  ---------------------

D0EB  18        CLC
D0EC  66 73     ROR #73
D0EE  A2 AC     LDX @#AC        Point to command table at #D0B2
D0F0  D0 19     BNE #D10B


  Deal with '*' and '/'
  ---------------------

D0F2  20 5D D8  JSR #D85D
D0F5  20 06 D1  JSR #D106
D0F8  A2 A1     LDX @#A1
D0FA  D0 0F     BNE #D10B


  Deal with '+' and '-'
  ---------------------

D0FC  20 F5 D0  JSR #D0F5
D0FF  A2 9A     LDX @#9A
D101  D0 08     BNE #D10B


  Deal with '^'
  -------------

D103  20 5D D8  JSR #D85D
D106  20 EB D0  JSR #D0EB
D109  A2 A8     LDX @#A8
D10B  18        CLC
D10C  90 05     BCC #D113


  Floating Point interpreter
  --------------------------

- Indirected by (#D002).

D10E  A2 5F     LDX @#5F
D110  84 03     STY #3
D112  38        SEC
D113  66 53     ROR #53
D115  A4 03     LDY #3
D117  88        DEY
D118  C8        INY
D119  B1 05     LDA (#5),Y
D11B  C9 20     CMP @#20
D11D  F0 F9     BEQ #D118
D11F  88        DEY
D120  84 52     STY #52
D122  CA        DEX
D123  A4 52     LDY #52
D125  E8        INX
D126  C8        INY
D127  BD 06 D0  LDA #D006,X
D12A  30 1A     BMI #D146
D12C  D1 05     CMP (#5),Y
D12E  F0 F5     BEQ #D125
D130  CA        DEX
D131  E8        INX
D132  BD 06 D0  LDA #D006,X
D135  10 FA     BPL #D131
D137  E8        INX
D138  24 53     BIT #53
D13A  10 E7     BPL #D123
D13C  B1 05     LDA (#5),Y
D13E  C9 2E     CMP @#2E
D140  D0 E1     BNE #D123
D142  C8        INY
D143  CA        DEX
D144  B0 E1     BCS #D127
D146  C9 FE     CMP @#FE
D148  B0 11     BCS #D15B
D14A  85 53     STA #53
D14C  BD 07 D0  LDA #D007,X
D14F  85 52     STA #52
D151  84 03     STY #3
D153  A6 04     LDX #4
D155  6C 52 00  JMP (#52)


D158  A6 04     LDX #4
D15A  60        RTS


D15B  F0 FB     BEQ #D158
D15D  00        BRK


  Floating Point interpreter
  --------------------------

- Indirected via (#D004).

D15E  84 03     STY #3
D160  20 EC D0  JSR #D0EC
D163  20 9A D8  JSR #D89A
D166  A5 5A     LDA #5A
D168  85 60     STA #60
D16A  A5 5B     LDA #5B
D16C  85 5F     STA #5F
D16E  A5 5C     LDA #5C
D170  85 5E     STA #5E
D172  A0 5D     LDY @#5D
D174  4C 9F C9  JMP #C99F


  Deals with '+'
  --------------

D177  20 F2 D0  JSR #D0F2
D17A  20 70 D8  JSR #D870
D17D  20 3C D9  JSR #D93C
D180  4C FF D0  JMP #D0FF


  Deals with '-'
  --------------

D183  20 F2 D0  JSR #D0F2
D186  20 70 D8  JSR #D870
D189  20 39 D9  JSR #D939
D18C  4C FF D0  JMP #D0FF


  Deals with '*'
  --------------

D18F  20 03 D1  JSR #D103
D192  20 70 D8  JSR #D870
D195  20 45 DA  JSR #DA45
D198  4C F8 D0  JMP #D0F8


  Deals with '/'
  --------------

D19B  20 03 D1  JSR #D103
D19E  20 70 D8  JSR #D870
D1A1  20 B6 DA  JSR #DAB6
D1A4  4C F8 D0  JMP #D0F8


  Deals with '^'
  --------------

D1A7  20 B6 DB  JSR #DBB6
D1AA  20 5D D8  JSR #D85D
D1AD  20 EB D0  JSR #D0EB
D1B0  20 70 D8  JSR #D870
D1B3  20 45 DA  JSR #DA45
D1B6  20 D7 DD  JSR #DDD7
D1B9  4C 09 D1  JMP #D109


  Deals with '-'
  --------------

D1BC  20 CB D1  JSR #D1CB
D1BF  20 86 D6  JSR #D686
D1C2  F0 06     BEQ #D1CA
D1C4  A5 57     LDA #57
D1C6  49 80     EOR @#80
D1C8  85 57     STA #57
D1CA  60        RTS


  Deals with '+'
  --------------

D1CB  A4 03     LDY #3
D1CD  88        DEY
D1CE  C8        INY
D1CF  B1 05     LDA (#5),Y
D1D1  C9 20     CMP @#20
D1D3  F0 F9     BEQ #D1CE
D1D5  C9 25     CMP @#25
D1D7  D0 32     BNE #D20B
D1D9  E6 03     INC #3
D1DB  20 44 D4  JSR #D444
D1DE  90 2B     BCC #D20B
D1E0  A0 6F     LDY @#6F
D1E2  20 CD C3  JSR #C3CD
D1E5  A0 04     LDY @#4
D1E7  A9 00     LDA @#0
D1E9  85 5E     STA #5E
D1EB  85 58     STA #58
D1ED  85 57     STA #57
D1EF  B1 6F     LDA (#6F),Y
D1F1  99 59 00  STA #59,Y
D1F4  05 57     ORA #57
D1F6  85 57     STA #57
D1F8  88        DEY
D1F9  10 F4     BPL #D1EF
D1FB  AA        TAX
D1FC  F0 09     BEQ #D207
D1FE  A5 5A     LDA #5A
D200  85 57     STA #57
D202  09 80     ORA @#80
D204  85 5A     STA #5A
D206  8A        TXA
D207  60        RTS


D208  84 03     STY #3
D20A  60        RTS


D20B  20 A5 D5  JSR #D5A5
D20E  B0 F8     BCS #D208
D210  A2 00     LDX @#0
D212  4C 12 D1  JMP #D112


  Execute the Command 'ABS'
  -------------------------

D215  20 EB D0  JSR #D0EB
D218  20 86 D6  JSR #D686
D21B  30 A7     BMI #D1C4
D21D  60        RTS


  Execute the Command 'ACS'
  -------------------------

D21E  20 24 D2  JSR #D224
D221  4C 86 DC  JMP #DC86


  Execute the Command 'ASN'
  -------------------------

D224  20 EB D0  JSR #D0EB
D227  20 86 D6  JSR #D686
D22A  10 0A     BPL #D236
D22C  A9 00     LDA @#0
D22E  85 57     STA #57
D230  20 36 D2  JSR #D236
D233  4C 75 DC  JMP #DC75


  Something to do with 'ASN' subroutine
  -------------------------------------

D236  20 2C D8  JSR #D82C
D239  20 45 DA  JSR #DA45
D23C  20 31 D8  JSR #D831
D23F  20 8D DE  JSR #DE8D
D242  20 33 D9  JSR #D933
D245  20 72 DB  JSR #DB72
D248  20 86 D6  JSR #D686
D24B  F0 12     BEQ #D25F
D24D  20 31 D8  JSR #D831
D250  20 A6 DB  JSR #DBA6
D253  20 E5 D1  JSR #D1E5
D256  20 AA DB  JSR #DBAA
D259  20 DC DA  JSR #DADC
D25C  4C 67 DC  JMP #DC67


D25F  20 93 DD  JSR #DD93
D262  4C E5 D1  JMP #D1E5


  Execute the Command 'RAD'
  -------------------------

D265  20 EB D0  JSR #D0EB
D268  A0 7C     LDY @#7C
D26A  A9 D2     LDA @#D2
D26C  84 6F     STY #6F
D26E  85 70     STA #70
D270  4C 45 DA  JMP #DA45


  Execute the Command 'DEG'
  -------------------------

D273  20 EB D0  JSR #D0EB
D276  A0 81     LDY @#81
D278  A9 D2     LDA @#D2
D27A  D0 F0     BNE #D26C


  ??? Table
  ---------

D27C  7B 0E FA 35 12


D281  86 65     STX #65
D283  2E E0 D3  ROL #D3E0


  Execute the Command 'TAN'
  -------------------------

D286  20 EB D0  JSR #D0EB
D289  20 86 D6  JSR #D686
D28C  F0 07     BEQ #D295
D28E  48        PHA
D28F  20 8D DE  JSR #DE8D
D292  68        PLA
D293  85 57     STA #57
D295  60        RTS


  ???
  ---

D296  24 73     BIT #73
D298  30 26     BMI #D2C0


  Execute the Command 'FLT'
  -------------------------

D29A  20 BC C8  JSR #C8BC
D29D  A0 5D     LDY @#5D
D29F  20 CD C3  JSR #C3CD
D2A2  85 5A     STA #5A
D2A4  A5 5F     LDA #5F
D2A6  85 5B     STA #5B
D2A8  A5 5E     LDA #5E
D2AA  85 5C     STA #5C
D2AC  A9 A0     LDA @#A0
D2AE  85 59     STA #59
D2B0  A0 00     LDY @#0
D2B2  84 5E     STY #5E
D2B4  A5 5A     LDA #5A
D2B6  85 57     STA #57
D2B8  10 03     BPL #D2BD
D2BA  20 D5 D8  JSR #D8D5
D2BD  4C C8 D7  JMP #D7C8

D2C0  4C 1B CA  JMP #CA1B       Execute BRK


  Execute the Command 'PI'
  ------------------------

D2C3  20 93 DD  JSR #DD93
D2C6  20 E5 D1  JSR #D1E5
D2C9  E6 59     INC #59
D2CB  60        RTS


  Execute the Command 'FGET'
  --------------------------

D2CC  20 3E CF  JSR #CF3E
D2CF  A2 04     LDX @#4
D2D1  20 D4 FF  JSR #FFD4
D2D4  9D C5 03  STA #3C5,X
D2D7  CA        DEX
D2D8  10 F7     BPL #D2D1
D2DA  20 AA DB  JSR #DBAA
D2DD  4C E5 D1  JMP #D1E5


  Execute the Command 'VAL'
  -------------------------

D2E0  20 B1 CE  JSR #CEB1
D2E3  A0 00     LDY @#0
D2E5  20 04 D3  JSR #D304
D2E8  C9 2B     CMP @#2B
D2EA  F0 0F     BEQ #D2FB
D2EC  C9 2D     CMP @#2D
D2EE  D0 0E     BNE #D2FE
D2F0  20 03 D3  JSR #D303
D2F3  84 54     STY #54
D2F5  20 B1 D5  JSR #D5B1
D2F8  4C BF D1  JMP #D1BF

D2FB  20 03 D3  JSR #D303
D2FE  84 54     STY #54
D300  4C B1 D5  JMP #D5B1


  Get to next non-space character subroutine
  ------------------------------------------

D303  C8        INY
D304  B1 52     LDA (#52),Y
D306  C9 20     CMP @#20
D308  F0 F9     BEQ #D303
D30A  60        RTS


  Execute the Command '%'
  -----------------------

D30B  20 44 D4  JSR #D444
D30E  90 D4     BCC #D2E4
D310  20 79 C2  JSR #C279
D313  20 FC D0  JSR #D0FC
D316  20 E4 C4  JSR #C4E4
D319  20 36 D8  JSR #D836
D31C  4C 5B C5  JMP #C55B


  Execute the Command 'STR'
  -------------------------

D31F  20 FC D0  JSR #D0FC
D322  20 31 C2  JSR #C231
D325  20 E1 C4  JSR #C4E1
D328  20 CB C3  JSR #C3CB
D32B  20 D0 D4  JSR #D4D0
D32E  4C 5B C5  JMP #C55B


  Execute the Command 'FPRINT'
  ----------------------------

D331  20 72 C3  JSR #C372
D334  A2 B8     LDX @#B8
D336  4C 0B D1  JMP #D10B


  ???
  ---

D339  20 FC D0  JSR #D0FC
D33C  A9 C5     LDA @#C5
D33E  85 52     STA #52
D340  A9 03     LDA @#3
D342  85 53     STA #53
D344  20 D0 D4  JSR #D4D0
D347  C6 6F     DEC #6F
D349  AD 21 03  LDA #321
D34C  38        SEC
D34D  E5 6F     SBC #6F
D34F  90 0B     BCC #D35C
D351  F0 09     BEQ #D35C
D353  A8        TAY
D354  A9 20     LDA @#20
D356  20 4C CA  JSR #CA4C
D359  88        DEY
D35A  D0 FA     BNE #D356
D35C  A0 00     LDY @#0
D35E  B1 52     LDA (#52),Y
D360  C9 0D     CMP @#D
D362  F0 CD     BEQ #D331
D364  20 4C CA  JSR #CA4C
D367  C8        INY
D368  D0 F4     BNE #D35E


  Execute the Command 'FINPUT'
  ----------------------------

D36A  20 72 C3  JSR #C372
D36D  B1 05     LDA (#5),Y
D36F  C9 25     CMP @#25
D371  D0 08     BNE #D37B
D373  C8        INY
D374  84 03     STY #3
D376  20 44 D4  JSR #D444
D379  B0 05     BCS #D380
D37B  A2 C3     LDX @#C3
D37D  4C 0B D1  JMP #D10B

D380  20 09 CD  JSR #CD09
D383  A8        TAY
D384  A5 05     LDA #5
D386  48        PHA
D387  A5 06     LDA #6
D389  48        PHA
D38A  A5 03     LDA #3
D38C  48        PHA
D38D  84 03     STY #3
D38F  C8        INY
D390  84 06     STY #6
D392  A9 40     LDA @#40
D394  85 05     STA #5
D396  20 FC D0  JSR #D0FC
D399  68        PLA
D39A  85 03     STA #3
D39C  68        PLA
D39D  85 06     STA #6
D39F  68        PLA
D3A0  85 05     STA #5
D3A2  20 36 D8  JSR #D836
D3A5  4C 7B D3  JMP #D37B


  Execute the Command 'FIF'
  -------------------------

D3A8  20 EB D9  JSR #D9EB
D3AB  4C 69 C5  JMP #C569


  Execute the Command 'FUNTIL'
  ----------------------------

D3AE  20 EB D9  JSR #D9EB
D3B1  4C D5 CC  JMP #CCD5


  Execute the Command 'FPUT'
  --------------------------

D3B4  20 94 D4  JSR #D494
D3B7  20 FC D0  JSR #D0FC
D3BA  20 E4 C4  JSR #C4E4
D3BD  20 31 D8  JSR #D831
D3C0  A6 04     LDX #4
D3C2  20 41 CF  JSR #CF41
D3C5  A2 04     LDX @#4
D3C7  BD C5 03  LDA #3C5,X
D3CA  20 D1 FF  JSR #FFD1
D3CD  CA        DEX
D3CE  10 F7     BPL #D3C7
D3D0  4C 5B C5  JMP #C55B


  Execute the Command 'FDIM'
  --------------------------

D3D3  A5 01     LDA #1
D3D5  05 02     ORA #2
D3D7  F0 6A     BEQ #D443
D3D9  20 34 C4  JSR #C434
D3DC  B0 65     BCS #D443
D3DE  A4 03     LDY #3
D3E0  B1 05     LDA (#5),Y
D3E2  C9 25     CMP @#25
D3E4  D0 5D     BNE #D443
D3E6  C8        INY
D3E7  B1 05     LDA (#5),Y
D3E9  C8        INY
D3EA  D1 05     CMP (#5),Y
D3EC  D0 55     BNE #D443
D3EE  C9 5B     CMP @#5B
D3F0  B0 51     BCS #D443
D3F2  E9 3F     SBC @#3F
D3F4  90 4D     BCC #D443
D3F6  C8        INY
D3F7  84 03     STY #3
D3F9  48        PHA
D3FA  20 8B C7  JSR #C78B
D3FD  F6 15     INC #15,X
D3FF  D0 02     BNE #D403
D401  F6 24     INC #24,X
D403  20 9A D4  JSR #D49A
D406  68        PLA
D407  A8        TAY
D408  18        CLC
D409  A5 23     LDA #23
D40B  99 87 28  STA #2887,Y
D40E  65 16     ADC #16
D410  85 23     STA #23
D412  A5 24     LDA #24
D414  99 A2 28  STA #28A2,Y
D417  65 25     ADC #25
D419  85 24     STA #24
D41B  A0 00     LDY @#0
D41D  84 04     STY #4
D41F  A9 AA     LDA @#AA
D421  91 23     STA (#23),Y
D423  D1 23     CMP (#23),Y
D425  D0 1C     BNE #D443
D427  4A        LSR A
D428  91 23     STA (#23),Y
D42A  D1 23     CMP (#23),Y
D42C  D0 15     BNE #D443
D42E  20 34 C4  JSR #C434
D431  B0 10     BCS #D443
D433  A4 03     LDY #3
D435  B1 05     LDA (#5),Y
D437  C9 2C     CMP @#2C
D439  D0 05     BNE #D440
D43B  E6 03     INC #3
D43D  4C D3 D3  JMP #D3D3
D440  4C 58 C5  JMP #C558
D443  00        BRK


  ???
  ---

D444  20 34 C4  JSR #C434
D447  90 0E     BCC #D457
D449  B5 15     LDA #15,X
D44B  0A        ASL A
D44C  0A        ASL A
D44D  75 15     ADC #15,X
D44F  95 15     STA #15,X
D451  A9 28     LDA @#28
D453  95 24     STA #24,X
D455  38        SEC
D456  60        RTS
D457  A4 03     LDY #3
D459  B1 05     LDA (#5),Y
D45B  C9 21     CMP @#21
D45D  D0 07     BNE #D466
D45F  E6 03     INC #3
D461  20 BC C8  JSR #C8BC
D464  38        SEC
D465  60        RTS
D466  C8        INY
D467  D1 05     CMP (#5),Y
D469  D0 08     BNE #D473
D46B  C9 5B     CMP @#5B
D46D  B0 04     BCS #D473
D46F  E9 3F     SBC @#3F
D471  B0 02     BCS #D475
D473  18        CLC
D474  60        RTS
D475  C8        INY
D476  84 03     STY #3
D478  48        PHA
D479  20 BC C8  JSR #C8BC
D47C  20 9A D4  JSR #D49A
D47F  68        PLA
D480  A8        TAY
D481  B0 10     BCS #D493
D483  B9 87 28  LDA #2887,Y
D486  75 15     ADC #15,X
D488  95 15     STA #15,X
D48A  B9 A2 28  LDA #28A2,Y
D48D  75 24     ADC #24,X
D48F  95 24     STA #24,X
D491  90 D1     BCC #D464
D493  00        BRK


  ???
  ---

D494  20 BC C8  JSR #C8BC
D497  4C 31 C2  JMP #C231


  ??? subroutine
  --------------

D49A  B4 24     LDY #24,X
D49C  B5 15     LDA #15,X
D49E  0A        ASL A
D49F  36 24     ROL #24,X
D4A1  0A        ASL A
D4A2  36 24     ROL #24,X
D4A4  18        CLC
D4A5  75 15     ADC #15,X
D4A7  95 15     STA #15,X
D4A9  98        TYA
D4AA  75 24     ADC #24,X
D4AC  95 24     STA #24,X
D4AE  60        RTS


  Pass Control to Utility Interpreter, if it Exists
  -------------------------------------------------

  Floating pointing interpreter jumps here if a match cannot be made
  against the #D006 command table.

  If ?#A000=#40 and ?#A001=#BF then control is passed to the Utility
  interpreter at #A002.

D4AF  AD 00 A0  LDA #A000       Get the first byte of the utility ROM
D4B2  C9 40     CMP @#40        Does it match the test byte ?
D4B4  D0 0A     BNE #D4C0       ..no, do interpreter post test, which
                                will fail and so execute BRK
D4B6  AD 01 A0  LDA #A001       Get the second byte of the utility ROM
D4B9  C9 BF     CMP @#BF        Does it match the test byte ?
D4BB  D0 03     BNE #D4C0       ..no, do interpreter post test, which
                                will fail and so execute BRK
D4BD  4C 02 A0  JMP #A002       ..yes, transfer control to the utility
D4C0  4C 58 C5  JMP #C558       Do interpreter post test


  ??? subroutine
  --------------

D4C3  C9 3A     CMP @#3A
D4C5  B0 07     BCS #D4CE
D4C7  C9 30     CMP @#30
D4C9  90 02     BCC #D4CD
D4CB  E9 30     SBC @#30
D4CD  60        RTS

D4CE  18        CLC
D4CF  60        RTS


  ??? subroutine
  --------------

D4D0  A9 00     LDA @#0
D4D2  85 6F     STA #6F
D4D4  20 86 D6  JSR #D686
D4D7  D0 12     BNE #D4EB
D4D9  A9 30     LDA @#30
D4DB  20 8D D5  JSR #D58D
D4DE  A9 2E     LDA @#2E
D4E0  20 8D D5  JSR #D58D
D4E3  A9 30     LDA @#30
D4E5  20 8D D5  JSR #D58D
D4E8  4C 71 D5  JMP #D571

D4EB  10 05     BPL #D4F2
D4ED  A9 2D     LDA @#2D
D4EF  20 8D D5  JSR #D58D
D4F2  A9 00     LDA @#0
D4F4  85 6D     STA #6D
D4F6  A5 59     LDA #59
D4F8  C9 81     CMP @#81
D4FA  B0 08     BCS #D504
D4FC  20 A0 D6  JSR #D6A0
D4FF  C6 6D     DEC #6D
D501  4C F6 D4  JMP #D4F6

D504  C9 84     CMP @#84
D506  90 10     BCC #D518
D508  D0 06     BNE #D510
D50A  A5 5A     LDA #5A
D50C  C9 A0     CMP @#A0
D50E  90 08     BCC #D518
D510  20 1B D7  JSR #D71B
D513  E6 6D     INC #6D
D515  4C F6 D4  JMP #D4F6

D518  A5 59     LDA #59
D51A  C9 84     CMP @#84
D51C  B0 07     BCS #D525
D51E  20 D8 D6  JSR #D6D8
D521  E6 59     INC #59
D523  D0 F3     BNE #D518
D525  38        SEC
D526  A9 FF     LDA @#FF
D528  20 36 D6  JSR #D636
D52B  A5 5A     LDA #5A
D52D  C9 A0     CMP @#A0
D52F  B0 DF     BCS #D510
D531  A9 01     LDA @#1
D533  A4 6D     LDY #6D
D535  30 0A     BMI #D541
D537  C0 08     CPY @#8
D539  B0 06     BCS #D541
D53B  C8        INY
D53C  A9 00     LDA @#0
D53E  85 6D     STA #6D
D540  98        TYA
D541  85 70     STA #70
D543  A2 09     LDX @#9
D545  86 54     STX #54
D547  20 75 D5  JSR #D575
D54A  C6 70     DEC #70
D54C  D0 05     BNE #D553
D54E  A9 2E     LDA @#2E
D550  20 8D D5  JSR #D58D
D553  C6 54     DEC #54
D555  D0 F0     BNE #D547
D557  A5 6D     LDA #6D
D559  F0 16     BEQ #D571
D55B  A9 45     LDA @#45
D55D  20 8D D5  JSR #D58D
D560  A5 6D     LDA #6D
D562  10 0A     BPL #D56E
D564  A9 2D     LDA @#2D
D566  20 8D D5  JSR #D58D
D569  38        SEC
D56A  A9 00     LDA @#0
D56C  E5 6D     SBC #6D
D56E  20 87 D5  JSR #D587
D571  A9 0D     LDA @#D
D573  D0 18     BNE #D58D
D575  A5 5A     LDA #5A
D577  4A        LSR A
D578  4A        LSR A
D579  4A        LSR A
D57A  4A        LSR A
D57B  20 8B D5  JSR #D58B
D57E  A5 5A     LDA #5A
D580  29 0F     AND @#F
D582  85 5A     STA #5A
D584  4C 4E D6  JMP #D64E


  ??? subroutine
  --------------

D587  C9 0A     CMP @#A
D589  B0 09     BCS #D594
D58B  09 30     ORA @#30
D58D  A4 6F     LDY #6F
D58F  91 52     STA (#52),Y
D591  E6 6F     INC #6F
D593  60        RTS


??? subroutine
--------------

D594  A2 FF     LDX @#FF
D596  E8        INX
D597  E9 0A     SBC @#A
D599  B0 FB     BCS #D596
D59B  69 0A     ADC @#A
D59D  48        PHA
D59E  8A        TXA
D59F  20 87 D5  JSR #D587
D5A2  68        PLA
D5A3  10 E6     BPL #D58B
D5A5  A5 03     LDA #3
D5A7  85 54     STA #54
D5A9  A5 05     LDA #5
D5AB  85 52     STA #52
D5AD  A5 06     LDA #6
D5AF  85 53     STA #53
D5B1  20 A4 DA  JSR #DAA4
D5B4  85 6C     STA #6C
D5B6  85 6D     STA #6D
D5B8  20 7B D6  JSR #D67B
D5BB  C9 2E     CMP @#2E
D5BD  F0 0E     BEQ #D5CD
D5BF  20 C3 D4  JSR #D4C3
D5C2  90 71     BCC #D635
D5C4  85 5E     STA #5E
D5C6  20 7B D6  JSR #D67B
D5C9  C9 2E     CMP @#2E
D5CB  D0 09     BNE #D5D6
D5CD  A5 6C     LDA #6C
D5CF  18        CLC
D5D0  D0 3A     BNE #D60C
D5D2  E6 6C     INC #6C
D5D4  D0 F0     BNE #D5C6
D5D6  C9 45     CMP @#45
D5D8  F0 27     BEQ #D601
D5DA  20 C3 D4  JSR #D4C3
D5DD  90 2D     BCC #D60C
D5DF  85 6E     STA #6E
D5E1  A5 5A     LDA #5A
D5E3  C9 18     CMP @#18
D5E5  90 08     BCC #D5EF
D5E7  A5 6C     LDA #6C
D5E9  D0 DB     BNE #D5C6
D5EB  E6 6D     INC #6D
D5ED  B0 D7     BCS #D5C6
D5EF  A5 6C     LDA #6C
D5F1  F0 02     BEQ #D5F5
D5F3  C6 6D     DEC #6D
D5F5  20 4E D6  JSR #D64E
D5F8  18        CLC
D5F9  A5 6E     LDA #6E
D5FB  20 36 D6  JSR #D636
D5FE  4C C6 D5  JMP #D5C6

D601  20 7B D6  JSR #D67B
D604  20 78 D7  JSR #D778
D607  18        CLC
D608  65 6D     ADC #6D
D60A  85 6D     STA #6D
D60C  A9 A8     LDA @#A8
D60E  85 59     STA #59
D610  20 86 D6  JSR #D686
D613  F0 1C     BEQ #D631
D615  20 C8 D7  JSR #D7C8
D618  A5 6D     LDA #6D
D61A  30 0B     BMI #D627
D61C  F0 10     BEQ #D62E
D61E  20 A0 D6  JSR #D6A0
D621  C6 6D     DEC #6D
D623  D0 F9     BNE #D61E
D625  F0 07     BEQ #D62E
D627  20 1B D7  JSR #D71B
D62A  E6 6D     INC #6D
D62C  D0 F9     BNE #D627
D62E  20 9B DA  JSR #DA9B
D631  38        SEC
D632  A4 54     LDY #54
D634  88        DEY
D635  60        RTS


  ??? subroutine
  --------------

D636  A2 05     LDX @#5
D638  75 59     ADC #59,X
D63A  95 59     STA #59,X
D63C  A9 00     LDA @#0
D63E  CA        DEX
D63F  D0 F7     BNE #D638
D641  60        RTS


  ??? subroutine
  --------------

D642  A2 05     LDX @#5
D644  B5 59     LDA #59,X
D646  75 61     ADC #61,X
D648  95 59     STA #59,X
D64A  CA        DEX
D64B  D0 F7     BNE #D644
D64D  60        RTS


  ??? subroutine
  --------------

D64E  A2 05     LDX @#5
D650  A9 00     LDA @#0
D652  85 67     STA #67
D654  A9 00     LDA @#0
D656  85 68     STA #68
D658  B5 59     LDA #59,X
D65A  0A        ASL A
D65B  26 68     ROL #68
D65D  0A        ASL A
D65E  26 68     ROL #68
D660  18        CLC
D661  75 59     ADC #59,X
D663  90 02     BCC #D667
D665  E6 68     INC #68
D667  0A        ASL A
D668  26 68     ROL #68
D66A  18        CLC
D66B  65 67     ADC #67
D66D  90 02     BCC #D671
D66F  E6 68     INC #68
D671  95 59     STA #59,X
D673  A5 68     LDA #68
D675  85 67     STA #67
D677  CA        DEX
D678  D0 DA     BNE #D654
D67A  60        RTS


  ??? subroutine
  --------------

D67B  84 55     STY #55
D67D  A4 54     LDY #54
D67F  B1 52     LDA (#52),Y
D681  A4 55     LDY #55
D683  E6 54     INC #54
D685  60        RTS


  ??? subroutine
  --------------

D686  A5 5A     LDA #5A
D688  05 5B     ORA #5B
D68A  05 5C     ORA #5C
D68C  05 5D     ORA #5D
D68E  05 5E     ORA #5E
D690  F0 07     BEQ #D699
D692  A5 57     LDA #57
D694  D0 09     BNE #D69F
D696  A9 01     LDA @#1
D698  60        RTS

D699  85 57     STA #57
D69B  85 59     STA #59
D69D  85 58     STA #58
D69F  60        RTS


  ??? subroutine
  --------------

D6A0  18        CLC
D6A1  A5 59     LDA #59
D6A3  69 03     ADC @#3
D6A5  85 59     STA #59
D6A7  90 02     BCC #D6AB
D6A9  E6 58     INC #58
D6AB  20 C3 D6  JSR #D6C3
D6AE  20 FB D6  JSR #D6FB
D6B1  20 FB D6  JSR #D6FB
D6B4  20 42 D6  JSR #D642
D6B7  90 09     BCC #D6C2
D6B9  20 D8 D6  JSR #D6D8
D6BC  E6 59     INC #59
D6BE  D0 02     BNE #D6C2
D6C0  E6 58     INC #58
D6C2  60        RTS


  Copy the 8 bytes #57..#5E to #5F..66 subroutine
  -----------------------------------------------

D6C3  A2 08     LDX @#8
D6C5  B5 56     LDA #56,X
D6C7  95 5E     STA #5E,X
D6C9  CA        DEX
D6CA  D0 F9     BNE #D6C5
D6CC  60        RTS


  Shift Left 1 Bit #5E..#5A subroutine
  ------------------------------------

D6CD  06 5E     ASL #5E
D6CF  26 5D     ROL #5D
D6D1  26 5C     ROL #5C
D6D3  26 5B     ROL #5B
D6D5  26 5A     ROL #5A
D6D7  60        RTS


  Shift Right 1 Bit #5A..#5E subroutine
  -------------------------------------

D6D8  66 5A     ROR #5A
D6DA  66 5B     ROR #5B
D6DC  66 5C     ROR #5C
D6DE  66 5D     ROR #5D
D6E0  66 5E     ROR #5E
D6E2  60        RTS


  Copy #5A..#5D to #5B..#5E and clear #5A subroutine
  --------------------------------------------------

D6E3  A5 5D     LDA #5D
D6E5  85 5E     STA #5E
D6E7  A5 5C     LDA #5C
D6E9  85 5D     STA #5D
D6EB  A5 5B     LDA #5B
D6ED  85 5C     STA #5C
D6EF  A5 5A     LDA #5A
D6F1  85 5B     STA #5B
D6F3  A9 00     LDA @#0
D6F5  85 5A     STA #5A
D6F7  60        RTS


D6F8  20 C3 D6  JSR #D6C3
D6FB  46 62     LSR #62
D6FD  66 63     ROR #63
D6FF  66 64     ROR #64
D701  66 65     ROR #65
D703  66 66     ROR #66
D705  60        RTS


  Copy #62..#65 to #63..#66 and clear #62 subroutine
  --------------------------------------------------

D706  A5 65     LDA #65
D708  85 66     STA #66
D70A  A5 64     LDA #64
D70C  85 65     STA #65
D70E  A5 63     LDA #63
D710  85 64     STA #64
D712  A5 62     LDA #62
D714  85 63     STA #63
D716  A9 00     LDA @#0
D718  85 62     STA #62
D71A  60        RTS


  ??? subroutine
  --------------

D71B  38        SEC
D71C  A5 59     LDA #59
D71E  E9 04     SBC @#4
D720  85 59     STA #59
D722  B0 02     BCS #D726
D724  C6 58     DEC #58
D726  20 F8 D6  JSR #D6F8
D729  20 B4 D6  JSR #D6B4
D72C  20 F8 D6  JSR #D6F8
D72F  20 FB D6  JSR #D6FB
D732  20 FB D6  JSR #D6FB
D735  20 FB D6  JSR #D6FB
D738  20 B4 D6  JSR #D6B4
D73B  A9 00     LDA @#0
D73D  85 62     STA #62
D73F  A5 5A     LDA #5A
D741  85 63     STA #63
D743  A5 5B     LDA #5B
D745  85 64     STA #64
D747  A5 5C     LDA #5C
D749  85 65     STA #65
D74B  A5 5D     LDA #5D
D74D  85 66     STA #66
D74F  A5 5E     LDA #5E
D751  2A        ROL A
D752  20 B4 D6  JSR #D6B4
D755  A9 00     LDA @#0
D757  85 62     STA #62
D759  85 63     STA #63
D75B  A5 5A     LDA #5A
D75D  85 64     STA #64
D75F  A5 5B     LDA #5B
D761  85 65     STA #65
D763  A5 5C     LDA #5C
D765  85 66     STA #66
D767  A5 5D     LDA #5D
D769  2A        ROL A
D76A  20 B4 D6  JSR #D6B4
D76D  A5 5B     LDA #5B
D76F  2A        ROL A
D770  A5 5A     LDA #5A
D772  20 36 D6  JSR #D636
D775  4C B7 D6  JMP #D6B7


  ??? subroutine
  --------------

D778  A0 FF     LDY @#FF
D77A  C9 2B     CMP @#2B
D77C  F0 05     BEQ #D783
D77E  C9 2D     CMP @#2D
D780  D0 04     BNE #D786
D782  C8        INY
D783  20 7B D6  JSR #D67B
D786  20 C3 D4  JSR #D4C3
D789  90 24     BCC #D7AF
D78B  AA        TAX
D78C  20 7B D6  JSR #D67B
D78F  20 C3 D4  JSR #D4C3
D792  90 10     BCC #D7A4
D794  85 6E     STA #6E
D796  20 7B D6  JSR #D67B
D799  8A        TXA
D79A  85 67     STA #67
D79C  0A        ASL A
D79D  0A        ASL A
D79E  65 67     ADC #67
D7A0  0A        ASL A
D7A1  65 6E     ADC #6E
D7A3  AA        TAX
D7A4  98        TYA
D7A5  D0 06     BNE #D7AD
D7A7  86 6E     STX #6E
D7A9  38        SEC
D7AA  E5 6E     SBC #6E
D7AC  60        RTS

D7AD  8A        TXA
D7AE  60        RTS

D7AF  A9 00     LDA @#0
D7B1  60        RTS


  ??? subroutine
  --------------

D7B2  48        PHA
D7B3  20 A4 DA  JSR #DAA4
D7B6  68        PLA
D7B7  F0 F8     BEQ #D7B1
D7B9  10 07     BPL #D7C2
D7BB  85 57     STA #57
D7BD  A9 00     LDA @#0
D7BF  38        SEC
D7C0  E5 57     SBC #57
D7C2  85 5A     STA #5A
D7C4  A9 88     LDA @#88
D7C6  85 59     STA #59
D7C8  20 86 D6  JSR #D686
D7CB  F0 E4     BEQ #D7B1
D7CD  A5 5A     LDA #5A
D7CF  D0 21     BNE #D7F2
D7D1  A5 5B     LDA #5B
D7D3  85 5A     STA #5A
D7D5  A5 5C     LDA #5C
D7D7  85 5B     STA #5B
D7D9  A5 5D     LDA #5D
D7DB  85 5C     STA #5C
D7DD  A5 5E     LDA #5E
D7DF  85 5D     STA #5D
D7E1  A9 00     LDA @#0
D7E3  85 5E     STA #5E
D7E5  38        SEC
D7E6  A5 59     LDA #59
D7E8  E9 08     SBC @#8
D7EA  85 59     STA #59
D7EC  B0 DF     BCS #D7CD
D7EE  C6 58     DEC #58
D7F0  90 DB     BCC #D7CD
D7F2  A5 5A     LDA #5A
D7F4  30 BB     BMI #D7B1
D7F6  20 CD D6  JSR #D6CD
D7F9  A5 59     LDA #59
D7FB  D0 02     BNE #D7FF
D7FD  C6 58     DEC #58
D7FF  C6 59     DEC #59
D801  4C F2 D7  JMP #D7F2


  ??? subroutine
  --------------

D804  A0 04     LDY @#4
D806  A9 00     LDA @#0
D808  85 66     STA #66
D80A  85 60     STA #60
D80C  85 5F     STA #5F
D80E  B1 6F     LDA (#6F),Y
D810  99 61 00  STA #61,Y
D813  05 5F     ORA #5F
D815  85 5F     STA #5F
D817  88        DEY
D818  10 F4     BPL #D80E
D81A  AA        TAX
D81B  F0 09     BEQ #D826
D81D  A5 62     LDA #62
D81F  85 5F     STA #5F
D821  09 80     ORA @#80
D823  85 62     STA #62
D825  8A        TXA
D826  60        RTS


  ??? subroutine
  --------------

D827  20 A2 DB  JSR #DBA2
D82A  D0 11     BNE #D83D
D82C  20 A6 DB  JSR #DBA6
D82F  D0 0C     BNE #D83D
D831  20 AA DB  JSR #DBAA
D834  D0 07     BNE #D83D
D836  A6 04     LDX #4
D838  A0 6F     LDY @#6F
D83A  20 CD C3  JSR #C3CD
D83D  A0 00     LDY @#0
D83F  A5 59     LDA #59
D841  91 6F     STA (#6F),Y
D843  C8        INY
D844  A5 57     LDA #57
D846  29 80     AND @#80
D848  85 57     STA #57
D84A  A5 5A     LDA #5A
D84C  29 7F     AND @#7F
D84E  05 57     ORA #57
D850  91 6F     STA (#6F),Y
D852  C8        INY
D853  B9 59 00  LDA #59,Y
D856  91 6F     STA (#6F),Y
D858  C0 04     CPY @#4
D85A  D0 F6     BNE #D852
D85C  60        RTS


  ??? subroutine
  --------------

D85D  A0 52     LDY @#52
D85F  84 6F     STY #6F
D861  A9 00     LDA @#0
D863  85 70     STA #70
D865  20 3D D8  JSR #D83D
D868  20 D9 C4  JSR #C4D9
D86B  A5 56     LDA #56
D86D  95 73     STA #73,X
D86F  60        RTS


  ??? subroutine
  --------------

D870  A6 04     LDX #4
D872  20 CB C3  JSR #C3CB
D875  B5 74     LDA #74,X
D877  85 56     STA #56
D879  84 6F     STY #6F
D87B  A9 00     LDA @#0
D87D  85 70     STA #70
D87F  60        RTS


  ??? subroutine
  --------------

D880  A5 5E     LDA #5E
D882  C9 80     CMP @#80
D884  90 07     BCC #D88D
D886  F0 0A     BEQ #D892
D888  A9 FF     LDA @#FF
D88A  20 72 D7  JSR #D772
D88D  A9 00     LDA @#0
D88F  85 5E     STA #5E
D891  60        RTS


  ??? subroutine
  --------------

D892  A5 5D     LDA #5D
D894  09 01     ORA @#1
D896  85 5D     STA #5D
D898  D0 F3     BNE #D88D
D89A  20 C7 D8  JSR #D8C7
D89D  F0 06     BEQ #D8A5
D89F  A5 59     LDA #59
D8A1  C9 A0     CMP @#A0
D8A3  B0 14     BCS #D8B9
D8A5  46 5A     LSR #5A
D8A7  66 5B     ROR #5B
D8A9  66 5C     ROR #5C
D8AB  66 5D     ROR #5D
D8AD  66 62     ROR #62
D8AF  66 63     ROR #63
D8B1  66 64     ROR #64
D8B3  66 65     ROR #65
D8B5  E6 59     INC #59
D8B7  D0 E6     BNE #D89F
D8B9  F0 16     BEQ #D8D1


  ??? subroutine
  --------------

D8BB  A9 7F     LDA @#7F
D8BD  85 5A     STA #5A
D8BF  A9 FF     LDA @#FF
D8C1  85 5B     STA #5B
D8C3  85 5C     STA #5C
D8C5  85 5D     STA #5D
D8C7  A2 08     LDX @#8
D8C9  A9 00     LDA @#0
D8CB  95 5F     STA #5F,X
D8CD  CA        DEX
D8CE  D0 FB     BNE #D8CB
D8D0  60        RTS


  ??? subroutine
  --------------

D8D1  A5 57     LDA #57
D8D3  10 0C     BPL #D8E1
D8D5  38        SEC
D8D6  A2 04     LDX @#4
D8D8  A9 00     LDA @#0
D8DA  F5 59     SBC #59,X
D8DC  95 59     STA #59,X
D8DE  CA        DEX
D8DF  D0 F7     BNE #D8D8
D8E1  60        RTS


  ??? subroutine
  --------------

D8E2  A5 62     LDA #62
D8E4  10 23     BPL #D909
D8E6  A2 04     LDX @#4
D8E8  A9 00     LDA @#0
D8EA  F5 61     SBC #61,X
D8EC  95 61     STA #61,X
D8EE  CA        DEX
D8EF  D0 F7     BNE #D8E8
D8F1  A5 57     LDA #57
D8F3  49 80     EOR @#80
D8F5  85 57     STA #57
D8F7  10 11     BPL #D90A
D8F9  E6 5D     INC #5D
D8FB  D0 0C     BNE #D909
D8FD  E6 5C     INC #5C
D8FF  D0 08     BNE #D909
D901  E6 5B     INC #5B
D903  D0 04     BNE #D909
D905  E6 5A     INC #5A
D907  F0 B2     BEQ #D8BB
D909  60        RTS

D90A  20 D5 D8  JSR #D8D5
D90D  20 F9 D8  JSR #D8F9
D910  4C D5 D8  JMP #D8D5


  ??? subroutine
  --------------

D913  A2 05     LDX @#5
D915  B5 61     LDA #61,X
D917  95 59     STA #59,X
D919  CA        DEX
D91A  D0 F9     BNE #D915
D91C  A9 80     LDA @#80
D91E  85 59     STA #59
D920  4C C8 D7  JMP #D7C8


  ??? subroutine
  --------------

D923  20 04 D8  JSR #D804
D926  20 3D D8  JSR #D83D
D929  A2 08     LDX @#8
D92B  B5 5E     LDA #5E,X
D92D  95 56     STA #56,X
D92F  CA        DEX
D930  D0 F9     BNE #D92B
D932  60        RTS


  ???
  ---

D933  20 39 D9  JSR #D939
D936  4C BF D1  JMP #D1BF


  ???
  ---

D939  20 BF D1  JSR #D1BF
D93C  20 04 D8  JSR #D804
D93F  F0 F1     BEQ #D932
D941  20 86 D6  JSR #D686
D944  F0 E3     BEQ #D929
D946  A5 59     LDA #59
D948  C5 61     CMP #61
D94A  F0 26     BEQ #D972
D94C  90 0F     BCC #D95D
D94E  E5 61     SBC #61
D950  C9 21     CMP @#21
D952  B0 DE     BCS #D932
D954  AA        TAX
D955  20 FB D6  JSR #D6FB
D958  CA        DEX
D959  D0 FA     BNE #D955
D95B  F0 15     BEQ #D972

D95D  38        SEC
D95E  A5 61     LDA #61
D960  E5 59     SBC #59
D962  C9 21     CMP @#21
D964  B0 C3     BCS #D929
D966  AA        TAX
D967  18        CLC
D968  20 D8 D6  JSR #D6D8
D96B  CA        DEX
D96C  D0 F9     BNE #D967
D96E  A5 61     LDA #61
D970  85 59     STA #59
D972  A5 57     LDA #57
D974  45 5F     EOR #5F
D976  10 49     BPL #D9C1
D978  A5 5A     LDA #5A
D97A  C5 62     CMP #62
D97C  D0 1B     BNE #D999
D97E  A5 5B     LDA #5B
D980  C5 63     CMP #63
D982  D0 15     BNE #D999
D984  A5 5C     LDA #5C
D986  C5 64     CMP #64
D988  D0 0F     BNE #D999
D98A  A5 5D     LDA #5D
D98C  C5 65     CMP #65
D98E  D0 09     BNE #D999
D990  A5 5E     LDA #5E
D992  C5 66     CMP #66
D994  D0 03     BNE #D999
D996  4C A4 DA  JMP #DAA4

D999  B0 2D     BCS #D9C8
D99B  38        SEC
D99C  A5 66     LDA #66
D99E  E5 5E     SBC #5E
D9A0  85 5E     STA #5E
D9A2  A5 65     LDA #65
D9A4  E5 5D     SBC #5D
D9A6  85 5D     STA #5D
D9A8  A5 64     LDA #64
D9AA  E5 5C     SBC #5C
D9AC  85 5C     STA #5C
D9AE  A5 63     LDA #63
D9B0  E5 5B     SBC #5B
D9B2  85 5B     STA #5B
D9B4  A5 62     LDA #62
D9B6  E5 5A     SBC #5A
D9B8  85 5A     STA #5A
D9BA  A5 5F     LDA #5F
D9BC  85 57     STA #57
D9BE  4C 98 DA  JMP #DA98

D9C1  18        CLC
D9C2  20 B4 D6  JSR #D6B4
D9C5  4C 9B DA  JMP #DA9B

D9C8  38        SEC
D9C9  A5 5E     LDA #5E
D9CB  E5 66     SBC #66
D9CD  85 5E     STA #5E
D9CF  A5 5D     LDA #5D
D9D1  E5 65     SBC #65
D9D3  85 5D     STA #5D
D9D5  A5 5C     LDA #5C
D9D7  E5 64     SBC #64
D9D9  85 5C     STA #5C
D9DB  A5 5B     LDA #5B
D9DD  E5 63     SBC #63
D9DF  85 5B     STA #5B
D9E1  A5 5A     LDA #5A
D9E3  E5 62     SBC #62
D9E5  85 5A     STA #5A
D9E7  4C 98 DA  JMP #DA98

D9EA  00        BRK

  ???
  ---

D9EB  20 FC D0  JSR #D0FC
D9EE  A9 C7     LDA @#C7
D9F0  48        PHA
D9F1  A2 C8     LDX @#C8
D9F3  4C 0B D1  JMP #D10B


  Execute the conditional test '='
  --------------------------------

D9F6  A9 5D     LDA @#5D
D9F8  D0 12     BNE #DA0C


  Execute the conditional test '<='
  ---------------------------------

D9FA  A9 66     LDA @#66
D9FC  D0 0E     BNE #DA0C


  Execute the conditional test '<>'
  ---------------------------------

D9FE  A9 6F     LDA @#6F
DA00  D0 0A     BNE #DA0C


  Execute the conditional test '<'
  --------------------------------

DA02  A9 76     LDA @#76
DA04  D0 06     BNE #DA0C


  Execute the conditional test '>='
  ---------------------------------

DA06  A9 7D     LDA @#7D
DA08  D0 02     BNE #DA0C


  Execute the conditional test '>'
  --------------------------------

DA0A  A9 84     LDA @#84
DA0C  48        PHA
DA0D  20 5D D8  JSR #D85D
DA10  20 FC D0  JSR #D0FC
DA13  20 70 D8  JSR #D870
DA16  E6 04     INC #4
DA18  20 04 D8  JSR #D804
DA1B  A5 5F     LDA #5F
DA1D  29 80     AND @#80
DA1F  85 5F     STA #5F
DA21  A0 00     LDY @#0
DA23  A5 57     LDA #57
DA25  29 80     AND @#80
DA27  C5 5F     CMP #5F
DA29  D0 0D     BNE #DA38
DA2B  A2 00     LDX @#0
DA2D  B5 61     LDA #61,X
DA2F  D5 59     CMP #59,X
DA31  D0 0A     BNE #DA3D
DA33  E8        INX
DA34  E0 05     CPX @#5
DA36  D0 F5     BNE #DA2D
DA38  08        PHP
DA39  A6 04     LDX #4
DA3B  28        PLP
DA3C  60        RTS

DA3D  6A        ROR A
DA3E  45 5F     EOR #5F
DA40  2A        ROL A
DA41  A9 01     LDA @#1
DA43  D0 F3     BNE #DA38
DA45  20 86 D6  JSR #D686
DA48  F0 F2     BEQ #DA3C
DA4A  20 04 D8  JSR #D804
DA4D  D0 03     BNE #DA52
DA4F  4C A4 DA  JMP #DAA4

DA52  18        CLC
DA53  A5 59     LDA #59
DA55  65 61     ADC #61
DA57  85 59     STA #59
DA59  90 02     BCC #DA5D
DA5B  E6 58     INC #58
DA5D  38        SEC
DA5E  A5 59     LDA #59
DA60  E9 80     SBC @#80
DA62  85 59     STA #59
DA64  B0 02     BCS #DA68
DA66  C6 58     DEC #58
DA68  A2 05     LDX @#5
DA6A  A0 00     LDY @#0
DA6C  B5 59     LDA #59,X
DA6E  95 66     STA #66,X
DA70  94 59     STY #59,X
DA72  CA        DEX
DA73  D0 F7     BNE #DA6C
DA75  A5 57     LDA #57
DA77  45 5F     EOR #5F
DA79  85 57     STA #57
DA7B  A0 20     LDY @#20
DA7D  20 FB D6  JSR #D6FB
DA80  A5 67     LDA #67
DA82  10 04     BPL #DA88
DA84  18        CLC
DA85  20 42 D6  JSR #D642
DA88  20 FB D6  JSR #D6FB
DA8B  06 6B     ASL #6B
DA8D  26 6A     ROL #6A
DA8F  26 69     ROL #69
DA91  26 68     ROL #68
DA93  26 67     ROL #67
DA95  88        DEY
DA96  D0 E8     BNE #DA80
DA98  20 C8 D7  JSR #D7C8
DA9B  20 80 D8  JSR #D880
DA9E  A5 58     LDA #58
DAA0  F0 0B     BEQ #DAAD
DAA2  10 03     BPL #DAA7
DAA4  A2 08     LDX @#8
DAA6  A9 00     LDA @#0
DAA8  95 56     STA #56,X
DAAA  CA        DEX
DAAB  D0 FB     BNE #DAA8
DAAD  60        RTS


  ??? subroutine
  --------------

DAAE  20 31 D8  JSR #D831
DAB1  20 8D DE  JSR #DE8D
DAB4  D0 26     BNE #DADC
DAB6  20 86 D6  JSR #D686
DAB9  F0 EC     BEQ #DAA7
DABB  20 C3 D6  JSR #D6C3
DABE  20 E5 D1  JSR #D1E5
DAC1  D0 23     BNE #DAE6
DAC3  60        RTS


  Execute the command 'TAN'
  -------------------------

DAC4  20 EB D0  JSR #D0EB
DAC7  20 9E DB  JSR #DB9E
DACA  20 3D D8  JSR #D83D
DACD  20 E6 DC  JSR #DCE6
DAD0  20 9E DB  JSR #DB9E
DAD3  20 23 D9  JSR #D923
DAD6  20 F1 DC  JSR #DCF1
DAD9  20 9E DB  JSR #DB9E
DADC  20 86 D6  JSR #D686
DADF  F0 CC     BEQ #DAAD
DAE1  20 04 D8  JSR #D804
DAE4  F0 C1     BEQ #DAA7
DAE6  A5 57     LDA #57
DAE8  45 5F     EOR #5F
DAEA  85 57     STA #57
DAEC  38        SEC
DAED  A5 59     LDA #59
DAEF  E5 61     SBC #61
DAF1  85 59     STA #59
DAF3  B0 02     BCS #DAF7
DAF5  C6 58     DEC #58
DAF7  18        CLC
DAF8  A5 59     LDA #59
DAFA  69 81     ADC @#81
DAFC  85 59     STA #59
DAFE  90 02     BCC #DB02
DB00  E6 58     INC #58
DB02  A2 05     LDX @#5
DB04  B5 59     LDA #59,X
DB06  95 66     STA #66,X
DB08  CA        DEX
DB09  D0 F9     BNE #DB04
DB0B  46 67     LSR #67
DB0D  66 68     ROR #68
DB0F  66 69     ROR #69
DB11  66 6A     ROR #6A
DB13  66 6B     ROR #6B
DB15  20 FB D6  JSR #D6FB
DB18  A2 27     LDX @#27
DB1A  A5 67     LDA #67
DB1C  C5 62     CMP #62
DB1E  D0 16     BNE #DB36
DB20  A5 68     LDA #68
DB22  C5 63     CMP #63
DB24  D0 10     BNE #DB36
DB26  A5 69     LDA #69
DB28  C5 64     CMP #64
DB2A  D0 0A     BNE #DB36
DB2C  A5 6A     LDA #6A
DB2E  C5 65     CMP #65
DB30  D0 04     BNE #DB36
DB32  A5 6B     LDA #6B
DB34  C5 66     CMP #66
DB36  90 24     BCC #DB5C
DB38  A5 6B     LDA #6B
DB3A  E5 66     SBC #66
DB3C  85 6B     STA #6B
DB3E  A5 6A     LDA #6A
DB40  E5 65     SBC #65
DB42  85 6A     STA #6A
DB44  A5 69     LDA #69
DB46  E5 64     SBC #64
DB48  85 69     STA #69
DB4A  A5 68     LDA #68
DB4C  E5 63     SBC #63
DB4E  85 68     STA #68
DB50  A5 67     LDA #67
DB52  E5 62     SBC #62
DB54  85 67     STA #67
DB56  A5 5E     LDA #5E
DB58  09 01     ORA @#1
DB5A  85 5E     STA #5E
DB5C  20 CD D6  JSR #D6CD
DB5F  06 6B     ASL #6B
DB61  26 6A     ROL #6A
DB63  26 69     ROL #69
DB65  26 68     ROL #68
DB67  26 67     ROL #67
DB69  CA        DEX
DB6A  D0 AE     BNE #DB1A
DB6C  4C 98 DA  JMP #DA98


  Execute the command 'SQR'
  -------------------------

DB6F  20 EB D0  JSR #D0EB
DB72  20 86 D6  JSR #D686
DB75  F0 26     BEQ #DB9D
DB77  10 01     BPL #DB7A
DB79  00        BRK

DB7A  20 31 D8  JSR #D831
DB7D  A5 59     LDA #59
DB7F  4A        LSR A
DB80  69 40     ADC @#40
DB82  85 59     STA #59
DB84  A9 05     LDA @#5
DB86  85 6E     STA #6E
DB88  20 27 D8  JSR #D827
DB8B  20 AA DB  JSR #DBAA
DB8E  20 B6 DA  JSR #DAB6
DB91  20 A2 DB  JSR #DBA2
DB94  20 3C D9  JSR #D93C
DB97  C6 59     DEC #59
DB99  C6 6E     DEC #6E
DB9B  D0 EB     BNE #DB88
DB9D  60        RTS


  ??? subroutine
  --------------

DB9E  A9 D4     LDA @#D4
DBA0  D0 0A     BNE #DBAC
DBA2  A9 CA     LDA @#CA
DBA4  D0 06     BNE #DBAC
DBA6  A9 CF     LDA @#CF
DBA8  D0 02     BNE #DBAC
DBAA  A9 C5     LDA @#C5
DBAC  85 6F     STA #6F
DBAE  A9 03     LDA @#3
DBB0  85 70     STA #70
DBB2  60        RTS


  ??? subroutine
  --------------

DBB3  20 EB D0  JSR #D0EB
DBB6  20 86 D6  JSR #D686
DBB9  F0 02     BEQ #DBBD
DBBB  10 01     BPL #DBBE
DBBD  00        BRK

DBBE  A5 59     LDA #59
DBC0  48        PHA
DBC1  A9 81     LDA @#81
DBC3  85 59     STA #59
DBC5  20 C7 D8  JSR #D8C7
DBC8  A9 C0     LDA @#C0
DBCA  85 62     STA #62
DBCC  A9 81     LDA @#81
DBCE  85 61     STA #61
DBD0  85 5F     STA #5F
DBD2  20 41 D9  JSR #D941
DBD5  E6 59     INC #59
DBD7  A9 FE     LDA @#FE
DBD9  A0 DB     LDY @#DB
DBDB  20 27 DC  JSR #DC27
DBDE  20 31 D8  JSR #D831
DBE1  68        PLA
DBE2  38        SEC
DBE3  E9 81     SBC @#81
DBE5  20 B2 D7  JSR #D7B2
DBE8  A9 F9     LDA @#F9
DBEA  85 6F     STA #6F
DBEC  A9 DB     LDA @#DB
DBEE  85 70     STA #70
DBF0  20 45 DA  JSR #DA45
DBF3  20 AA DB  JSR #DBAA
DBF6  4C 3C D9  JMP #D93C


  ??? Table
  ---------

DBF9                             80 31 72 17 F8 07 85
DC00  17 6E D4 85 80 28 C7 12 A0 84 70 4E 5F F2 81 00
DC10  00 FE EF 84 0F FF DA E1 81 7F FF FF 93 82 40 00
DC20  00 0C 7F 4F 99 1F 65


  ??? subroutine
  --------------

DC27  85 71     STA #71
DC29  84 72     STY #72
DC2B  20 31 D8  JSR #D831
DC2E  A0 00     LDY @#0
DC30  B1 71     LDA (#71),Y
DC32  85 6C     STA #6C
DC34  E6 71     INC #71
DC36  D0 02     BNE #DC3A
DC38  E6 72     INC #72
DC3A  A5 71     LDA #71
DC3C  85 6F     STA #6F
DC3E  A5 72     LDA #72
DC40  85 70     STA #70
DC42  20 E5 D1  JSR #D1E5
DC45  20 AA DB  JSR #DBAA
DC48  20 B6 DA  JSR #DAB6
DC4B  18        CLC
DC4C  A5 71     LDA #71
DC4E  69 05     ADC @#5
DC50  85 71     STA #71
DC52  85 6F     STA #6F
DC54  A5 72     LDA #72
DC56  69 00     ADC @#0
DC58  85 72     STA #72
DC5A  85 70     STA #70
DC5C  20 3C D9  JSR #D93C
DC5F  C6 6C     DEC #6C
DC61  D0 E2     BNE #DC45
DC63  60        RTS


  Execute the command 'ATN'
  -------------------------

DC64  20 EB D0  JSR #D0EB
DC67  20 86 D6  JSR #D686
DC6A  F0 0D     BEQ #DC79
DC6C  10 0C     BPL #DC7A
DC6E  A9 00     LDA @#0
DC70  85 57     STA #57
DC72  20 7A DC  JSR #DC7A
DC75  A9 80     LDA @#80
DC77  85 57     STA #57
DC79  60        RTS

DC7A  A5 59     LDA #59
DC7C  C9 81     CMP @#81
DC7E  90 0C     BCC #DC8C
DC80  20 AE DA  JSR #DAAE
DC83  20 8C DC  JSR #DC8C
DC86  20 93 DD  JSR #DD93
DC89  4C 39 D9  JMP #D939

DC8C  A5 59     LDA #59
DC8E  C9 73     CMP @#73
DC90  90 E7     BCC #DC79
DC92  20 2C D8  JSR #D82C
DC95  20 C7 D8  JSR #D8C7
DC98  A9 80     LDA @#80
DC9A  85 61     STA #61
DC9C  85 62     STA #62
DC9E  85 5F     STA #5F
DCA0  20 41 D9  JSR #D941
DCA3  A9 B0     LDA @#B0
DCA5  A0 DC     LDY @#DC
DCA7  20 27 DC  JSR #DC27
DCAA  20 A6 DB  JSR #DBA6
DCAD  4C 45 DA  JMP #DA45


  ??? Table
  ---------

DCB0  09 85 A3 59 E8 67 80 1C 9D 07 36 80 57 BB 78 DF
DCC0  80 CA 9A 0E 83 84 8C BB CA 6E 81 95 96 06 DE 81
DCD0  0A C7 6C 52 7F 7D AD 90 A1 82 FB 62 57 2F 80 6D
DCE0  63 38 2C


  Execute the command 'COS'
  -------------------------

DCE3  20 EB D0  JSR #D0EB
DCE6  20 24 DD  JSR #DD24
DCE9  E6 6E     INC #6E
DCEB  4C F4 DC  JMP #DCF4


  Execute the command 'SIN'
  -------------------------

DCEE  20 EB D0  JSR #D0EB
DCF1  20 24 DD  JSR #DD24
DCF4  46 6E     LSR #6E
DCF6  90 03     BCC #DCFB
DCF8  20 86 DC  JSR #DC86
DCFB  46 6E     LSR #6E
DCFD  90 06     BCC #DD05
DCFF  20 05 DD  JSR #DD05
DD02  4C BF D1  JMP #D1BF

DD05  20 2C D8  JSR #D82C
DD08  20 93 DD  JSR #DD93
DD0B  20 04 D8  JSR #D804
DD0E  C6 61     DEC #61
DD10  A9 80     LDA @#80
DD12  85 5F     STA #5F
DD14  20 41 D9  JSR #D941
DD17  A9 A6     LDA @#A6
DD19  A0 DD     LDY @#DD
DD1B  20 27 DC  JSR #DC27
DD1E  20 A6 DB  JSR #DBA6
DD21  4C 45 DA  JMP #DA45


  ???
  ---

DD24  A5 59     LDA #59
DD26  C9 98     CMP @#98
DD28  B0 54     BCS #DD7E
DD2A  20 31 D8  JSR #D831
DD2D  20 93 DD  JSR #DD93
DD30  20 DC DA  JSR #DADC
DD33  20 9A D8  JSR #D89A
DD36  A5 5D     LDA #5D
DD38  85 6E     STA #6E
DD3A  05 5C     ORA #5C
DD3C  05 5B     ORA #5B
DD3E  05 5A     ORA #5A
DD40  F0 3E     BEQ #DD80
DD42  20 AC D2  JSR #D2AC
DD45  20 27 D8  JSR #D827
DD48  20 86 DD  JSR #DD86
DD4B  20 45 DA  JSR #DA45
DD4E  20 AA DB  JSR #DBAA
DD51  20 3C D9  JSR #D93C
DD54  20 3D D8  JSR #D83D
DD57  20 A2 DB  JSR #DBA2
DD5A  20 E5 D1  JSR #D1E5
DD5D  20 8A DD  JSR #DD8A
DD60  20 45 DA  JSR #DA45
DD63  20 AA DB  JSR #DBAA
DD66  20 3C D9  JSR #D93C
DD69  A5 57     LDA #57
DD6B  10 12     BPL #DD7F
DD6D  20 8A DD  JSR #DD8A
DD70  20 33 D9  JSR #D933
DD73  20 86 DD  JSR #DD86
DD76  20 33 D9  JSR #D933
DD79  C6 6E     DEC #6E
DD7B  4C 69 DD  JMP #DD69

DD7E  00        BRK

DD7F  60        RTS

DD80  20 DA D2  JSR #D2DA
DD83  4C 69 DD  JMP #DD69


  ??? subroutine
  --------------

DD86  A9 97     LDA @#97
DD88  D0 02     BNE #DD8C


  ??? subroutine
  --------------

DD8A  A9 9C     LDA @#9C
DD8C  85 6F     STA #6F
DD8E  A9 DD     LDA @#DD
DD90  85 70     STA #70
DD92  60        RTS


  ??? subroutine
  --------------

DD93  A9 A1     LDA @#A1
DD95  D0 F5     BNE #DD8C


  ??? Table
  ---------

DD97                       81 C9 00 00 00 75 FD AA 22
DDA0  17 81 49 0F DA A2 08 84 04 C7 3C FB 81 E0 4F 5D
DDB0  AD 82 80 00 69 B8 82 5B CF 1D B5 82 BF CE 82 1E
DDC0  82 45 44 7F 32 7F 62 44 5A D2 83 82 14 8A 27 80
DDD0  66 7B 21 4D


  Execute the command 'EXP'
  -------------------------

DDD4  20 EB D0  JSR #D0EB
DDD7  A5 59     LDA #59
DDD9  C9 87     CMP @#87
DDDB  90 10     BCC #DDED
DDDD  D0 06     BNE #DDE5
DDDF  A5 5A     LDA #5A
DDE1  C9 B3     CMP @#B3
DDE3  90 08     BCC #DDED
DDE5  A5 57     LDA #57
DDE7  10 03     BPL #DDEC
DDE9  4C A4 DA  JMP #DAA4

DDEC  00        BRK

DDED  A5 59     LDA #59
DDEF  C9 80     CMP @#80
DDF1  90 29     BCC #DE1C
DDF3  20 9A D8  JSR #D89A
DDF6  20 E2 D8  JSR #D8E2
DDF9  A5 5D     LDA #5D
DDFB  85 6E     STA #6E
DDFD  20 13 D9  JSR #D913
DE00  20 1C DE  JSR #DE1C
DE03  20 2C D8  JSR #D82C
DE06  A9 23     LDA @#23
DE08  85 6F     STA #6F
DE0A  A9 DE     LDA @#DE
DE0C  85 70     STA #70
DE0E  20 E5 D1  JSR #D1E5
DE11  A5 6E     LDA #6E
DE13  20 51 DE  JSR #DE51
DE16  20 A6 DB  JSR #DBA6
DE19  4C 45 DA  JMP #DA45

DE1C  A9 28     LDA @#28
DE1E  A0 DE     LDY @#DE
DE20  4C 27 DC  JMP #DC27


  ??? Table
  ---------

DE23           82 2D F8 54 58 07 83 E0 20 86 5B 82 80
DE30  53 93 B8 83 20 00 06 A1 82 00 00 21 63 82 C0 00
DE40  00 02 82 80 00 00 0C 81 00 00 00 00 81 00 00 00
DE50  00


  ??? subroutine
  --------------

DE51  AA        TAX
DE52  10 09     BPL #DE5D
DE54  CA        DEX
DE55  8A        TXA
DE56  49 FF     EOR @#FF
DE58  48        PHA
DE59  20 AE DA  JSR #DAAE
DE5C  68        PLA
DE5D  48        PHA
DE5E  20 31 D8  JSR #D831
DE61  20 8D DE  JSR #DE8D
DE64  68        PLA
DE65  F0 0A     BEQ #DE71
DE67  38        SEC
DE68  E9 01     SBC @#1
DE6A  48        PHA
DE6B  20 45 DA  JSR #DA45
DE6E  4C 64 DE  JMP #DE64

DE71  60        RTS


  Execute the command 'HTN'
  -------------------------

DE72  20 EB D0  JSR #D0EB
DE75  A5 57     LDA #57
DE77  10 0A     BPL #DE83
DE79  A9 00     LDA @#0
DE7B  85 57     STA #57
DE7D  20 83 DE  JSR #DE83
DE80  4C BF D1  JMP #D1BF


  Something to do with 'HTN' subroutine
  -------------------------------------

DE83  A5 59     LDA #59
DE85  C9 81     CMP @#81
DE87  90 33     BCC #DEBC
DE89  C9 85     CMP @#85
DE8B  90 0B     BCC #DE98
DE8D  20 A4 DA  JSR #DAA4
DE90  A0 80     LDY @#80
DE92  84 5A     STY #5A
DE94  C8        INY
DE95  84 59     STY #59
DE97  60        RTS

DE98  E6 59     INC #59
DE9A  A9 80     LDA @#80
DE9C  85 57     STA #57
DE9E  20 D7 DD  JSR #DDD7
DEA1  20 31 D8  JSR #D831
DEA4  20 8D DE  JSR #DE8D
DEA7  20 3C D9  JSR #D93C
DEAA  20 27 D8  JSR #D827
DEAD  20 8D DE  JSR #DE8D
DEB0  20 AA DB  JSR #DBAA
DEB3  20 33 D9  JSR #D933
DEB6  20 A2 DB  JSR #DBA2
DEB9  4C DC DA  JMP #DADC

DEBC  20 2C D8  JSR #D82C
DEBF  20 8D DE  JSR #DE8D
DEC2  C6 59     DEC #59
DEC4  20 33 D9  JSR #D933
DEC7  A9 D4     LDA @#D4
DEC9  A0 DE     LDY @#DE
DECB  20 27 DC  JSR #DC27
DECE  20 A6 DB  JSR #DBA6
DED1  4C 45 DA  JMP #DA45


  ??? Table
  ---------

DED4              08 7E 85 51 B3 0C 86 DE B0 7D 73 7C
DEE0  23 D8 E9 9A 87 34 82 1D 80 81 9A 20 6C ED 81 BD
DEF0  32 34 2E 7F 5D 46 87 B4 82 68 3E 43 F7 80 6C 9A
DF00  9E BB


  Execute the command 'COLOUR'
  ----------------------------

DF02  20 C8 C3  JSR #C3C8
DF05  A5 52     LDA #52
DF07  29 03     AND @#3
DF09  A8        TAY
DF0A  B9 4E DF  LDA #DF4E,Y
DF0D  8D FD 03  STA #3FD
DF10  AD 00 B0  LDA #B000
DF13  29 F0     AND @#F0
DF15  C9 70     CMP @#70
DF17  D0 0C     BNE #DF25
DF19  A9 00     LDA @#0
DF1B  A8        TAY
DF1C  99 00 86  STA #8600,Y
DF1F  99 00 87  STA #8700,Y
DF22  88        DEY
DF23  D0 F7     BNE #DF1C
DF25  AD 00 B0  LDA #B000
DF28  29 DF     AND @#DF
DF2A  8D 00 B0  STA #B000
DF2D  2A        ROL A
DF2E  2A        ROL A
DF2F  2A        ROL A
DF30  29 03     AND @#3
DF32  A8        TAY
DF33  B9 42 DF  LDA #DF42,Y
DF36  8D FE 03  STA #3FE
DF39  B9 46 DF  LDA #DF46,Y
DF3C  8D FF 03  STA #3FF
DF3F  4C 58 C5  JMP #C558


  Colour Point Plot routine LSB Address Table
  -------------------------------------------

DF42  52 70 88 A0


  Colour Point Plot routine MSB Address Table
  -------------------------------------------


DF46  DF DF DF DF


  ??? Data Table
  --------------

DF4A  3F CF F3 FC


  Colour Byte Table
  -----------------

DF4E  00 55 AA FF


  Mode 1 Colour Point Plot routine
  --------------------------------

DF52  A5 5B     LDA #5B
DF54  05 5D     ORA #5D
DF56  D0 47     BNE #DF9F
DF58  A5 5A     LDA #5A
DF5A  C9 40     CMP @#40
DF5C  B0 41     BCS #DF9F
DF5E  4A        LSR A
DF5F  4A        LSR A
DF60  85 5F     STA #5F
DF62  A0 00     LDY @#0
DF64  84 60     STY #60
DF66  A9 3F     LDA @#3F
DF68  38        SEC
DF69  E5 5C     SBC #5C
DF6B  C9 40     CMP @#40
DF6D  90 4F     BCC #DFBE
DF6F  60        RTS


  Mode 2 Colour Point Plot routine
  --------------------------------

DF70  A5 5B     LDA #5B
DF72  05 5D     ORA #5D
DF74  D0 29     BNE #DF9F
DF76  A5 5A     LDA #5A
DF78  30 25     BMI #DF9F
DF7A  4A        LSR A
DF7B  4A        LSR A
DF7C  85 5F     STA #5F
DF7E  A9 3F     LDA @#3F
DF80  38        SEC
DF81  E5 5C     SBC #5C
DF83  C9 40     CMP @#40
DF85  90 30     BCC #DFB7
DF87  60        RTS


  Mode 3 Colour Point Plot routine
  --------------------------------

DF88  A5 5B     LDA #5B
DF8A  05 5D     ORA #5D
DF8C  D0 11     BNE #DF9F
DF8E  A5 5A     LDA #5A
DF90  30 0D     BMI #DF9F
DF92  4A        LSR A
DF93  4A        LSR A
DF94  85 5F     STA #5F
DF96  A9 5F     LDA @#5F
DF98  38        SEC
DF99  E5 5C     SBC #5C
DF9B  C9 60     CMP @#60
DF9D  90 18     BCC #DFB7
DF9F  60        RTS


  Mode 4 Colour Point Plot routine
  --------------------------------

DFA0  A5 5B     LDA #5B
DFA2  05 5D     ORA #5D
DFA4  D0 F9     BNE #DF9F
DFA6  A5 5A     LDA #5A
DFA8  30 F5     BMI #DF9F
DFAA  4A        LSR A
DFAB  4A        LSR A
DFAC  85 5F     STA #5F
DFAE  A9 BF     LDA @#BF
DFB0  38        SEC
DFB1  E5 5C     SBC #5C
DFB3  C9 C0     CMP @#C0
DFB5  B0 E8     BCS #DF9F
DFB7  A0 00     LDY @#0
DFB9  84 60     STY #60
DFBB  0A        ASL A
DFBC  26 60     ROL #60
DFBE  0A        ASL A
DFBF  26 60     ROL #60
DFC1  0A        ASL A
DFC2  26 60     ROL #60
DFC4  0A        ASL A
DFC5  26 60     ROL #60
DFC7  0A        ASL A
DFC8  26 60     ROL #60
DFCA  65 5F     ADC #5F
DFCC  85 5F     STA #5F
DFCE  A5 60     LDA #60
DFD0  69 80     ADC @#80
DFD2  85 60     STA #60
DFD4  A5 5A     LDA #5A
DFD6  29 03     AND @#3
DFD8  AA        TAX
DFD9  BD 4A DF  LDA #DF4A,X
DFDC  A6 5E     LDX #5E
DFDE  CA        DEX
DFDF  F0 0F     BEQ #DFF0
DFE1  CA        DEX
DFE2  F0 05     BEQ #DFE9
DFE4  31 5F     AND (#5F),Y
DFE6  91 5F     STA (#5F),Y
DFE8  60        RTS

DFE9  49 FF     EOR @#FF
DFEB  51 5F     EOR (#5F),Y
DFED  91 5F     STA (#5F),Y
DFEF  60        RTS

DFF0  AA        TAX
DFF1  31 5F     AND (#5F),Y
DFF3  91 5F     STA (#5F),Y
DFF5  8A        TXA
DFF6  49 FF     EOR @#FF
DFF8  2D FD 03  AND #3FD
DFFB  11 5F     ORA (#5F),Y
DFFD  91 5F     STA (#5F),Y
DFFF  60        RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              ****************************************
              * Disassembly of Atom Operating System *
              *           from #F000 to #FFFF        *
              ****************************************

Version 1.1
9:4:86


;   Subroutines...
;   --------------
;
; F02E Test for Array variable and Fetch Contents if Valid subroutine
; F08B Interpret an Array Variable Address to the Workspace Stack subroutine
; F291 Get to the First Non-Space Character subroutine
; F36B Get the Integer Variable 'P' into the Workspace Stack subroutine
; F376 Print Accumulator in Hexadecimal followed by a Space subroutine
; F37E Print Accumulator in Hexadecimal subroutine
; F668 Decrement the Vector (#5A),X subroutine
; F671 Increment the Vector (#5A),X subroutine
; F678 Plot a Point subroutine
; F720 Point Clear/Set/Invert subroutine
; F73B Mode 1 Point Plot subroutine
; F754 Mode 2 Point Plot subroutine
; F76D Mode 3 Point Plot subroutine
; F7AA Mode 4 Point Plot subroutine
; F7D1 Print ASCII String subroutine
; F7EC Print the (#D4) word in Hexadecimal followed by a Space subroutine
; F7EE Print a 4 Byte Word in Hexadecimal followed by a Space subroutine
; F7F1 Print a 2 Byte Vector in Hexadecimal followed by a Space subroutine
; F7FA Print a Byte in Hexadecimal followed by a Space subroutine
; F7FD Print a Space subroutine
; F802 Print a Byte in Hexadecimal subroutine
; F818 Copy String from #100 Buffer to #140 Buffer subroutine
; F84F Transfer Tape File Control Block and Test Name subroutine
; F875 Get Next Non-Space Character from #100 Buffer subroutine
; F87E Convert ASCII Hexadecimal Digit to Binary subroutine
; F893 Read 4 Hexadecimal Characters from #100 buffer subroutine
; F8EF COS Interpreter subroutine
; F92F Load an Un-Named File subroutine
; F955 Execute the Command '*FLOAD' subroutine
; F958 Execute the Command '*LOAD' subroutine
; F96E OSLOAD Load File subroutine
; F98E Print Filename subroutine
; F9A2 Load Current Block subroutine
; FA08 Increment and Test Vector subroutine
; FA19 Execute the Command '*NOMON' subroutine
; FA1A Execute the Command '*MON' subroutine
; FA65 Read 4 Hex Characters from #100 buffer with Invalid Test subroutine
; FA76 COS Post Test subroutine
; FA86 Save an Un-Named File subroutine
; FAE5 Save File subroutine
; FB3B Send Header and Data Block to Tape subroutine
; FB78 Wait 2 Seconds with Tape Tone Off subroutine
; FB7A Wait 2 Seconds subroutine
; FB81 Wait 0.5 Second subroutine
; FB83 Wait up to 4.25 Seconds subroutine
; FB8A Wait 0.1 second subroutine
; FB8E Read Header from Tape and Test for Un-Named File subroutine
; FBC8 Read Name from Tape and Compare Names subroutine
; FBE2 Get 8 Bytes from Tape into Workspace subroutine
; FBEE OSBGET Get Byte from Tape subroutine
; FC23 Add Byte to Checksum subroutine
; FC2B Set up Block Load Address subroutine
; FC38 Print "PLAY TAPE" or "RECORD TAPE" subroutine
; FC63 Print "REWIND TAPE" subroutine
; FC76 Wait for Keypress and Print <CR><LF> subroutine
; FC7C OSBPUT Put Byte to Tape subroutine
; FCBD Count Duration of Tape Pulse subroutine
; FCCD Test state of #B002 tape input pulse subroutine
; FCD8 Wait for 1 Falling Edge of the 2.4KHz Clock subroutine
; FCDA Wait for 1 to 127 Falling Edges of the 2.4KHz Clock subroutine
; FCEA Send ASCII Character to Screen subroutine
; FD0B Handle <ESC> subroutine
; FD11 Handle <ACK> or <NAK> subroutine
; FD1A Handle <BEL> subroutine
; FD29 Print an ASCII Character on the Screen subroutine
; FD40 Reset Cursor to Start of Current Line Without Deletion subroutine
; FD44 Invert Character at Current Cursor Position subroutine
; FD50 Handle <DEL> subroutine
; FD5C Handle <BS> subroutine
; FD62 Handle <LF> subroutine
; FD69 Handle <FF> subroutine
; FD7D Handle <RS> subroutine
; FD87 Handle <VT> subroutine
; FD8D Handle <SO> subroutine
; FD92 Handle <SI> subroutine
; FD9A Handle <LOCK> subroutine
; FDA2 Handle Cursor Keys from Keyboard subroutine
; FDAE Handle <COPY> Key subroutine
; FDC0 Handle <DEL> key #F (ASCII #7F) subroutine
; FDC2 Handle '[\]^_' keys #3B-#3F (ASCII #5B-#5F) subroutine
; FDC6 Handle 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' keys #21-#3A (ASCII #41-#5A) sub
; FDC8 Handle '@' key #20 (ASCII #40) subroutine
; FDD2 Handle '!"#$' keys 1-4 (ASCII #21-#24) subroutine
; FDD6 Handle '<=>?>' keys #1C-#1F (ASCII #3C-#3F) subroutine
; FDD8 Handle '123456789:;' keys #11-#1B (ASCII #31-#3B) subroutine
; FDDF Handle <SPACE> key 0 (ASCII #10) subroutine
; FDEC Handle <LF>, Scrolling if Necessary subroutine
; FE08 Scroll the Screen subroutine
; FE0A Scroll Y lines of the Screen subroutine
; FE22 Delete Current Line subroutine
; FE2C Add One Line to the Cursor Position subroutine
; FE35 Move the Cursor Back One Position subroutine
; FE52 Send Character to VIA and Screen subroutine
; FE55 Send Character to Screen subroutine
; FE66 Wait Until Next CRT Field Flyback subroutine
; FE6B Wait Until Next or Current CRT Field Flyback subroutine
; FE71 Scan Key Matrix subroutine
; FE94 OSRDCH Get Key subroutine
; FEC4 Decode Control Character subroutine
; FEFB Send Contents of Accumulator to VIA subroutine
; FF38 Do <EXT> subroutine
;
;
;   Other routines...
;     -----------------
;
; F04B Interpreter for #F000 Command Words
; F085 Set Array Variable to an Arbitrarily Complex Expression
; F0AE Execute the Command 'DIM'
; F141 Execute the Command 'RUN'
; F14C Execute the Command 'WAIT'
; F155 Table of Compressed Assembler Mnemonic (MSB)
; F195 Table of Compressed Assembler Mnemonic (LSB)
; F1D5 Table of Bit Masks for Address Modes (LSB)
; F1E4 Table of Bit Masks for Address Modes (MSB)
; F1F3 Table of Offset from Base for Address Modes
; F211 Table of Base Address Value for Mnemonics Modes
; F251 Table of Base Address Value for Mnemonics
; F29C Execute the Command ']'
; F2A1 Execute the Command '['
; F32E Deal with Assembler Label Definition
; F360 Deal with Assembler Comments
; F38E Deal with Assembler Statement
; F3F2 Get Assembler Addressing Mode Data and Type
; F440 Act on Assembler ??? Mode
; F454 Act on Assembler Immediate Mode
; F462 Act on Assembler Indirect Mode
; F49B Construct Assembler Opcode and Data
; F4EC Handle Assembler Relative Addressing
; F531 Execute the Command 'OLD'
; F542 Execute the Command 'DRAW'
; F546 Execute the Command 'MOVE'
; F54E Execute the Command 'PLOT'
; F5B5 Draw a Line Routine
; F5EB Plot a Line with (X change) <= (Y change)
; F61C Plot a Line with (X change) > (Y change)
; F67B Execute the Command 'CLEAR'
; F6C2 Perform 'CLEAR 0'
; F6CF Graphics Mode Control Data
; F6D3 Point Plot Routine LSBs for Graphic Modes 0 to 4
; F6D8 Point Plot Routine MSBs for Graphic Modes 0 to 4
; F6DD VDG Control Byte for Graphic Modes 0 to 4
; F6E2 Mode 0 Point PLot Routine
; F7C9 Graphics Bit Mask Table
; F8BE COS Interpreter Command Table
; F926 Default COS Error Handler
; FA20 Execute the Command '*RUN'
; FA2A Execute the Command '*CAT'
; FA6B Get a Hexadecimal Number and Jump There
; FABB Execute the Command '*SAVE'
; F926 Default COS Error Handler
; FECB WRCHAR Control Code Data Lookup Table
; FED6 RDCHAR Control Code Data Lookup Table
; FEE3 WRCHAR Control Code Address Lookup Table
; FEEE RDCHAR Control Code Address Lookup Table
; FF3F RESET Routine
; FF9A Vector Data Table
; FFB2 IRQ/BRK Handler
; FFC0 Execute BRK
; FFC7 Execute NMI
; FFCB Operating System Jump Table


F000  50 4C 4F 54 F5 4E 44 52 41 57 F5 42 4D 4F 56 45  PLOT..DRAW..MOVE
F010  F5 46 43 4C 45 41 52 F6 7B 44 49 4D F0 AE 5B F2  ..CLEAR..DIM..[.
F020  A1 4F 4C 44 F5 31 57 41 49 54 F1 4C C5 50        .OLD..WAIT....


  Test for Array variable and Fetch Contents if Valid subroutine
  --------------------------------------------------------------

- Looks for two consecutive characters being the same, thus identifying
  an array.
- Entry at #F02E starts interpretation at (5),?#5E.
- Entry at #F030 starts interpretation at (5),Y.
- Enter with the X register pointing to the current slot of the workspace
  stack.
- If an array is identified, the array number is evaluated, the array
  offset calculated (offset=4*array number, since an integer has 4-byte
  precision), the offset added to the array base address fetched from the
  Array Table, and the 4-byte integer read from the resultant array
  variable and written to the current slot of the workspace stack.
- The workspace stack pointer ?4 is updated and incremented.

F02E  A4 5E     LDY #5E         Get index
F030  B1 05     LDA (#5),Y      Get the first character of text
F032  C9 40     CMP @#40        Is it >= '@' ?
F034  90 12     BCC #F048       ..no, can't be a valid array - quit
F036  C9 5B     CMP @#5B        Is it <= '[' ?
F038  B0 0E     BCS #F048       ..no, can't be a valid array - quit
F03A  C8        INY             Point to the second character in text
F03B  D1 05     CMP (#5),Y      Is the second character the same as
                                the first ?
F03D  D0 09     BNE #F048       ..no, it's not a valid array - quit
F03F  20 8B F0  JSR #F08B       Interpret the address of the array number
                                and copy to the level of the w/s stack
                                pointed to by the X register
F042  20 4F C9  JSR #C94F       Get the LSB array byte into LSB w/s stack
F045  4C 62 C9  JMP #C962       Get the 3 MSBs into the w/s stack also


F048  4C 24 CA  JMP #CA24       Unrecognised command - try FP interpreter


  Interpreter for #F000 Command Words
  -----------------------------------

- Starts interpretation at (5),?#5E.
- Jumps to the appropriate action addresses.
- Exits to #C550 if fails to match command word.

F04B  A2 FF     LDX @#FF        Pointer to the #F000 command word table
F04D  A4 5E     LDY #5E         Get interpreter pointer
F04F  C6 5E     DEC #5E         This now points to the previous character

                                TEST FOR ARRAY ASSIGNMENT

F051  B1 05     LDA (#5),Y      Get the first character of text
F053  C9 40     CMP @#40        Is it >= '@' ?
F055  90 09     BCC #F060       ..no, definately not an array assignment
F057  C9 5B     CMP @#5B        is it <= '[' ?
F059  B0 05     BCC #F060       ..no, definately not an array assignment
F05B  C8        INY             Point to the second character in text
F05C  D1 05     CMP (#5),Y      is it the same, identifying an array ?
F05E  F0 25     BEQ #F085       ..yes, deal with ARRAY=(function)

                                TRY TO MATCH TEXT WITH #F000 TABLE WORDS

F060  A4 5E     LDY #5E         Restore pointer to the character before
                                the first to be interpreted
F062  E8        INX             Point to next character in command table
F063  C8        INY             Point to next character under analysis
F064  BD 00 F0  LDA #F000,X     Get character from command table
F067  30 0C     BMI #F075       ..reached MSB address byte of command word
F069  D1 05     CMP (#5),Y      Otherwise compare with character in text
F06B  F0 F5     BEQ #F062       Go on to test next character if matched

                                WORD MATCH FAILED - TRY NEXT WORD IN TABLE

F06D  E8        INX             Point to next character of the failed
                                command word in the table
F06E  BD FF EF  LDA #EFFF,X     ..and get it
F071  10 FA     BPL #F06D       Keep going until MSB command word reached
F073  D0 EB     BNE #F060       ..and try to match this command word

                                COPY JUMP ADDRESS TO ZERO PAGE - AND JUMP

F075  85 53     STA #53         Dump the MSB jump address to w/s
F077  BD 01 F0  LDA #F001,X     Get MSB jump address from command table
F07A  85 52     STA #52         Dump the LSB jump address to w/s
F07C  84 03     STY #3          Update the interpreter pointer
F07E  A6 04     LDX #4          Get pointer to current slot of w/s stack
F080  E6 5E     INC #5E         This points to the first character
                                JUST interpreted
F082  6C 52 00  JMP (#52)       Jump to the command word jump address


  Set Array Variable to an Arbitrarily Complex Expression
  -------------------------------------------------------

- Interprets an array variable, followed by an '=', followed by an
  arbitrarily complex numerical expression, and copies the latter to the
  array variable.
- Returns to the main interpreter at #C55B.

F085  20 8B F0  JSR #F08B       Get the array address into the current
                                level of the w/s stack and increment the
                                w/s stack pointer
F088  4C F1 C3  JMP #C3F1       Interpret an '=' followed by a numerical
                                expression & copy this result to the array variable previously interpreted


  Interpret an Array Variable Address to the Workspace Stack subroutine
  ---------------------------------------------------------------------

- Gets the array start address from the table of start addresses pointed
  to by #2EB,Y and #306,Y, adds the offset calculated by 4 times the
  evaluated array number, and places the resultant address on the current
  level of the workspace stack.
- Enter with (5),Y pointing to the second array character (@ to Z), the
  accumulator containing the array character, and the Carry flag set.

F08B  C8        INY             Point to first character of array number
F08C  84 03     STY #3          Save interpreter index
F08E  E9 40     SBC @#40        Convert so '@'=0 to "Z"=26
F090  48        PHA             ..and save the resulting array number
F091  20 BC C8  JSR #C8BC       Evaluate array number onto the w/s stack
F094  68        PLA             Restore the array number
F095  A8        TAY             This is the index tothe array stack
F096  B5 15     LDA #15,X       )
F098  0A        ASL A           )
F099  36 24     ROL #24,X       )
F09B  0A        ASL A           ) Multiply the 2-byte array number by 4
F09C  36 24     ROL #24,X       ) to get the array offset
F09E  18        CLC             )
F09F  79 EB 02  ADC #2EB,Y      )
F0A2  95 15     STA #15,X       )
F0A4  B5 24     LDA #24,X       ) Add the array offset to the base address
F0A6  79 06 03  ADC #306,Y      ) and put the result on the last level of
F0A9  95 24     STA #24,X       ) the w/s stack
F0AB  B0 D7     BCS #F084       ..if the array had not been dimensioned,
                                then overflow will occur as the arrays are
                                initialised to #FFFF. Hence execute BRK
F0AD  60        RTS


  Execute the Command 'DIM'
  -------------------------

- If in Direct Mode then BRK is executed.

F0AE  A5 01     LDA #1          If the MSB line number is 0..
F0B0  05 02     ORA #2          ..and the LSB line number is 0..
F0B2  F0 22     BEQ #F0D6       ..then in Direct Mode, so BRK

                                TEST FOR NUMERIC OR STRING ARRAY

F0B4  20 34 C4  JSR #C434       Get the first non-space character onto
                                the w/s stack if it's alphabetic
F0B7  90 1E     BCC #F0D7       Branch if the first character is not
                                alphabetic or the first two characters
                                are - possibly indicating a numeric array

                                DIMENSION A STRING ARRAY

F0B9  20 BC C8  JSR #C8BC       Interpret array length onto the w/s stack
F0BC  CA        DEX             Point to array length on the w/s stack
F0BD  CA        DEX             Point to array character no. on w/s stack
F0BE  86 04     STX #4          Update w/s stack pointer
F0C0  B4 16     LDY #16,X       Get character number from LSB w/s stack
F0C2  38        SEC
F0C3  A5 23     LDA #23         Copy LSB free space pointer..
F0C5  99 21 03  STA #321,Y      ..to LSB variable - this is string address
F0C8  75 17     ADC #17,X       Add array length from w/s stack
F0CA  85 23     STA #23         Update LSB free space pointer
F0CC  A5 24     LDA #24         Copy MSB free space pointer..
F0CE  99 3C 03  STA #33C,Y      ..to MSB variable - this is string address
F0D1  75 26     ADC #26,X       Add array length from w/s stack
F0D3  4C 19 F1  JMP #F119       Update MSB free space pointer and test for
                                memory at the free space pointer address
F0D6  00        BRK

                                DIMENSION A NUMERIC ARRAY
                                FIRST TEST FOR VALID ARRAY VARIABLE
                                IN THE RANGE '@@' TO 'ZZ'

F0D7  A4 03     LDY #3          Get the interpeter pointer
F0D9  B1 05     LDA (#5),Y      Get first non-space character from text
F0DB  C9 40     CMP @#40        Is it alphabetic, ie >= '@' ?
F0DD  90 F7     BCC #F0D6       ..no, execute BRK
F0DF  C9 5B     CMP @#5B        Is it alphabetic, ie < '[' ?
F0E1  B0 F3     BCS #F0D6       ..no, execute BRK

                                EVALUATE ARRAY VARIABLE AND LENGTH

F0E3  C8        INY             Point to next character
F0E4  D1 05     CMP (#5),Y      Is this the same as the first character
                                indicating a valid array variable ?
F0E6  D0 EE     BNE #F0D6       ..no, execute BRK
F0E8  E9 40     SBC @#40        ..yes, convert so '@'=0 to 'Z'=26
F0EA  48        PHA             Save this array variable number
F0EB  C8        INY             Point to first character of array dimension
F0EC  84 03     STY #3          Update text pointer
F0EE  20 BC C8  JSR #C8BC       Evaluate arbitrarily complex array length
                                onto the w/s stack
F0F1  68        PLA             Restore the array variable number
F0F2  A8        TAY             ..as the index to the array table

                                SET ARRAY VARIABLE TO FREE SPACE POINTER

F0F3  A5 23     LDA #23         Copy the LSB free space pointer..
F0F5  99 EB 02  STA #2EB,Y      ..to the LSB array variable table
F0F8  A5 24     LDA #24         Copy the MSB free space pointer..
F0FA  99 06 03  STA #306,Y      ..to the MSB array variable table
F0FD  CA        DEX
F0FE  86 04     STX #4          Decrement the w/s pointer

                                MULTIPLY ARRAY LENGTH BY 4 AS IT'S NUMERIC

F100  B4 16     LDY #16,X       Get the LSB array length
F102  C8        INY             Increment - a dimension of 0 uses 1 byte !
F103  D0 02     BNE #F107
F105  F6 25     INC #25,X       Increment MSB array length if overflowed
F107  98        TYA             Get the LSB array length
F108  0A        ASL A           Double it
F109  36 25     ROL #25,X       ..and double the MSB array length
F10B  0A        ASL A           Double it again
F10C  36 25     ROL #25,X       ..and double the MSB array length again

                                ADD (4*LENGTH) TO FREE SPACE POINTER

F10E  18        CLC
F10F  65 23     ADC #23         Add the old LSB free space pointer
F111  85 23     STA #23         And update the LSB free space pointer
F113  B5 25     LDA #25,X       Get MSB (4*length)
F115  65 24     ADC #24         Add the old MSB free space pointer
F117  B0 BD     BCS #F0D6       Execute BRK if overflows
F119  85 24     STA #24         And update the MSB free space pointer

                                TEST FOR MEMORY AT FREE SPACE POINTER

F11B  A0 00     LDY @#0
F11D  A9 AA     LDA @#AA        Get first test byte
F11F  91 23     STA (#23),Y     ..and dump to free space pointer address
F121  D1 23     CMP (#23),Y     Can it be read back ?
F123  D0 F7     BNE #F11C       ..no, execute BRK
F125  4A        LSR A           Get second test byte, ie #55
F126  91 23     STA (#23),Y     ..and dump to free space pointer address
F128  D1 23     CMP (#23),y     Can it be read back ?
F12A  D0 F0     BNE #F11C       ..no, execute BRK

                                CONTINUE DIMENSIONING OTHER VARIABLES

F12C  20 34 C4  JSR #C434       Get first non-space character
F12F  B0 A5     BCS #F0D6       Execute BRK if it's alphabetic - a ','
                                is expected separating DIM terms
F131  A4 03     LDY #3          Get interpreter pointer
F133  B1 05     LDA (#5),Y      Get first non-space character
F135  C9 2C     CMP @#2C        Is it ',' ?
F137  D0 05     BNE #F13E       ..no, no more variables to dimension
F139  E6 03     INC #3          ..yes, Point past the ','
F13B  4C AE F0  JMP #F0AE       ..and dimension the next variable

F13E  4C 58 C5  JMP #C558       Back to the interpreter


  Execute the Command 'RUN'
  -------------------------

- Sets the free space pointer at (#23) to TOP at (#D) and then jumps to
- the continuation at #CE83.

F141  A5 0D     LDA #D          Get LSB TOP
F143  85 23     STA #23         ..and set the LSB Free Space pointer
F145  A5 0E     LDA #E          Get MSB TOP
F147  85 24     STA #24         ..and set the MSB Free Space pointer
F149  4C 83 CE  JMP #CE83       Set the text pointer to the start of text
                                and jump to the interpreter at #C55B


  Execute the Command 'WAIT'
  --------------------------

  - Returns to the main interpreter at #C558.

F14C  20 E4 C4  JSR #C4E4       Do the interpreter post test
F14F  20 66 FE  JSR #FE66       Wait for next complete VDU flyback
F152  4C 5B C5  JMP #C558       ..back to the interpreter



  Table of Compressed Assembler Mnemonic (MSB)
  --------------------------------------------

F155                 1C 8A 1C 23 5D 8B 1B A1 9D 8A 1D
F160  23 9D 8B 1D A1 00 29 19 AE 69 A8 19 23 24 53 1B
F170  23 24 53 19 A1 00 1A 5B 5B A5 69 24 24 AE AE A8
F180  AD 29 00 7C 00 15 9C 6D 9C A5 69 29 53 84 13 34
F190  11 A5 69 23 A0


  Table of Compressed Assembler Mnemonic (LSB)
  --------------------------------------------

F195                 D8 62 5A 48 26 62 94 88 54 44 C8
F1A0  54 68 44 E8 94 00 B4 08 84 74 B4 28 6E 74 F4 CC
F1B0  4A 72 F2 A4 8A 00 AA A2 A2 74 74 74 72 44 68 B2
F1C0  32 B2 00 22 00 1A 1A 26 26 72 72 88 C8 C4 CA 26
F1D0  48 44 44 A2 C8


  Table of Bit Masks for Address Modes (LSB)
  ------------------------------------------

F1D5                 00 02 00 08 F2 FF 80 01 C0 E2 C0
F1E0  C0 FF 00 00


  Table of Bit Masks for Address Modes (MSB)
  ------------------------------------------

F1E4              08 00 10 80 40 C0 00 C0 00 40 00 00
F1F0  E4 20 80


  Table of Offset from Base for Address Modes
  -------------------------------------------

F1F3           00 FC 00 08 08 F8 FC F4 0C 10 04 F4 00
F200  20 10 00 00 0F 01 01 01 11 11 02 02 11 11 02 12
F210  02


  Table of Base Address Value for Mnemonics Modes
  -----------------------------------------------

F211     00 08 10 18 20 28 30 38 40 48 50 58 60 68 70
F220  78 80 88 90 98 A0 A8 B0 B8 C0 C8 D0 D8 E0 E8 F0
F230  F8 0C 2C 4C 4C 8C AC CC EC 8A 9A AA BA CA DA EA
F240  FA 0E 2E 4E 6E 8E AE CE EE 0D 2D 4D 6D 8D AD CD
F250  ED


  Table of Base Address Value for Mnemonics
  -----------------------------------------

F251     0D 0D 0C 0D 0E 0D 0C 0D 0D 0D 0C 0D 0D 0D 0C
F260  0D 0F 0D 0C 0D 09 0D 0C 0D 08 0D 0C 0D 08 0D 0C
F270  0D 0F 06 0B 0B 04 0A 08 08 0D 0D 0D 0D 0D 0F 0D
F280  0F 07 07 07 07 05 09 03 03 01 01 01 01 02 01 01
F290  01


  Get to the First Non-Space Character subroutine
  -----------------------------------------------

 - Gets the first non-space character into the accumulator using the (5),Y
   pointer where Y=?3.
 - Returns with (5),Y pointing to the following character and ?3 updated.

F291  A4 03     LDY #3          Get the interpreter pointer
F293  B1 05     LDA (#5),Y      Get character from text
F295  E6 03     INC #3          Increment interpreter pointer
F297  C9 20     CMP @#20        Is this character a <SPC> ?
F299  F0 F6     BEQ #F291       ..yes, keep searching
F29B  60        RTS


  Execute the Command ']'
  -----------------------

F29C  E6 03     INC #3          Skip past the ']' symbol
F29E  4C 1B C3  JMP #C31B       ..and return to the main interpreter


  Execute the Command '['
  -----------------------

F2A1  B1 05     LDA (#5),Y      Get the current character from text
F2A3  C9 5D     CMP @#5D        Is it the assembler terminator ']' ?
F2A5  F0 F5     BEQ #F29C       ..yes, return to the main interpreter

F2A7  20 F6 C4  JSR #C4F6       Consolidate the (5),Y pointer, check <ESC>
F2AA  C6 03     DEC #3          Point to the current character
F2AC  20 8E F3  JSR #F38E       Interpret the assembly statement into w/s
F2AF  C6 03     DEC #3          Decrement the interpreter pointer
F2B1  A5 52     LDA #52
F2B3  48        PHA             Save the LSB current assembly address
F2B4  A5 53     LDA #53
F2B6  48        PHA             Save the MSB current assembly address

                                PRINT THE TEXT LINE NUMBER

F2B7  AD 21 03  LDA #321        Get print field width, LSB variable '@'
F2BA  48        PHA             ..and save it
F2BB  A9 00     LDA @#0
F2BD  85 34     STA #34         Clear second MSB lowest level of w/s stack
F2BF  85 43     STA #43         Clear MSB lowest level of w/s stack
F2C1  A9 05     LDA @#5         ) Set the print field width in order to
F2C3  8D 21 03  STA #321        ) print the text line number
F2C6  A5 01     LDA #1          Get the LSB text line number
F2C8  85 16     STA #16         ..into LSB lowest level of w/s stack
F2CA  A5 02     LDA #2          Get the MSB text line number
F2CC  85 25     STA #25         ..into second LSB lowest level of w/s stack
F2CE  20 89 C5  JSR #C589       Print line number in decimal in field @
F2D1  20 79 F3  JSR #F379       Print a space
F2D4  68        PLA
F2D5  8D 21 03  STA #321        Restore origional print field width
F2D8  68        PLA             Restore the LSB current assembly address
F2D9  20 7E F3  JSR #F37E       ..and print it in hex
F2DC  68        PLA             Restore the MSB current assembly address
F2DD  20 76 F3  JSR #F376       ..and print it in hex followed by a space

                                PRINT ASSEMBLED CODE IN HEX

F2E0  A0 00     LDY @#0         Initialise code byte pointer
F2E2  C4 00     CPY #0          printed all the code bytes ?
F2E4  F0 09     BEQ #F2EF       ..yes
F2E6  B9 66 00  LDA #66,Y       get byte of code
F2E9  20 76 F3  JSR #F376       ..and print it in hex followed by a space
F2EC  C8        INY             Point to the next byte of code
F2ED  D0 F3     BNE #F2E2       ..and loop round to deal with that
F2EF  C0 03     CPY @#3
F2F1  F0 0C     BEQ #F2FF
F2F3  20 79 F3  JSR #F379       Print a space
F2F6  20 4C CA  JSR #CA4C
F2F9  20 4C CA  JSR #CA4C
F2FC  C8        INY
F2FD  D0 F0     BNE #F2EF
F2FF  A0 00     LDY @#0
F301  B1 05     LDA (#5),Y      Get character from text
F303  C9 3B     CMP @#3B        Is it ';' statement separator ?
F305  F0 0A     BEQ #F311       ..yes,
F307  C9 0D     CMP @#D         Is it <CR> line terminator ?
F309  F0 06     BEQ #F311       ..yes,
F30B  20 4C CA  JSR #CA4C
F30E  C8        INY
F30F  D0 F0     BNE #F301
F311  20 54 CD  JSR #CD54
F314  20 E4 C4  JSR #C4E4
F317  88        DEY
F318  B1 05     LDA (#5),Y      Get character from text
F31A  C8        INY             Point to next character
F31B  C9 3B     CMP @#3B        Is it ';' statement separator ?
F31D  F0 0C     BEQ #F32B       ..yes,
F31F  A5 06     LDA #6
F321  C9 01     CMP @#1
F323  D0 03     BNE #F328
F325  4C CF C2  JMP #C2CF

F328  20 1D C5  JSR #C51D
F32B  4C A1 F2  JMP #F2A1


  Deal with Assembler Label Definition
  ------------------------------------

- Interprets a label (array variable) and sets the label to the current
  value of the assembler memory pointer P.
- Enter with the ":" having been interpreted, and with (5),?3 pointing
  to the first character of the array variable.

F32E  20 91 F2  JSR #F291       Get the next non-space character
F331  85 66     STA #66         Store this - it's the first array
                                character
F333  20 91 F2  JSR #F291       Get the next non-space character
F336  C5 66     CMP #66         Is the second array character the same as
                                the first - ie is it a valid array ?
F338  D0 10     BNE #F34A       ..no, invalid label - execute BRK
F33A  C9 40     CMP @#40        Is the label character < '`' ?
F33C  90 0C     BCC #F34A       ..yes, invalid label - execute BRK
F33E  C9 5B     CMP @#5B        Is the label character >= '[' ?
F340  B0 08     BCS #F34A       ..yes, invalid label - execute BRK
F342  38        SEC
F343  20 8E F0  JSR #F08E       Evaluate array address onto the w/s stack
F346  20 CB C3  JSR #C3CB       Copy last level of w/s stack to #52..#55
F349  A0 00     LDY @#0
F34B  AD 31 03  LDA #331        Get LSB variable 'P' (memory pointer)
F34E  91 52     STA (#52),Y     ..and set LSB label
F350  AD 4C 03  LDA #34C        Get the second LSB of integer variable 'P'
                                (assembler memory pointer)
F353  C8        INY
F354  91 52     STA (#52),Y     ..and set second LSB label
F356  A9 00     LDA @#0
F358  C8        INY
F359  91 52     STA (#52),Y     Clear second MSB label
F35B  C8        INY
F35C  91 52     STA (#52),Y     Clear MSB label
F35E  D0 36     BNE #F396       Go on to interpret assembler statement


  Deal with Assembler Comments
  ----------------------------

  - Only returns to the assembler interpreter at the end of the text line
    or when the asssembler statement separator ';' is encountered.

F360  20 91 F2  JSR #F291       Get the next non-space character from text
F363  C9 3B     CMP @#3B        Is it the statement separator ';' ?
F365  F0 04     BEQ #F36B       ..yes, set up the memory pointer , and go

                                on to interpret the next statement
F367  C9 0D     CMP @#D         Is the text line terminator <CR> ?
F369  D0 F5     BNE #F360       No, so character is skipped as a comment


  Get the Integer Variable 'P' into the Workspace Stack subroutine
  ----------------------------------------------------------------

  - Puts the two LSBs of integer variable 'P' into workspace #52, #53.

F36B  AD 31 03  LDA #331        Get LSB integer variable 'P'
F36E  85 52     STA #52         ..into w/s
F370  AD 4C 03  LDA #34C        Get second LSB integer variable 'P'
F373  85 53     STA #53         ..into w/s
F375  60        RTS


  Print Accumulator in Hexadecimal followed by a Space subroutine
  ---------------------------------------------------------------

  - Prints the accumulator as two hex digits followed by a space.
  - COUNT is incremented 3 times.
  - Returns with Acc=#20, X=#FD, Y preserved.

F376  20 7E F3  JSR #F37E       Print the accumulator as two hex digits
F379  A9 20     LDA @#20        Get <SPC>
F37B  4C 4C CA  JMP #CA4C       Increment COUNT and send char to OSWRCH


  Print Accumulator in Hexadecimal subroutine
  -------------------------------------------

  - Prints the accumulator as two hex digits.
  - COUNT is incremented twice.
  - Returns with X=#FD, Y preserved.

F37E  A2 FF     LDX @#FF        Required to return from #C5F9
F380  48        PHA             Save number
F381  4A        LSR A           )
F382  4A        LSR A           )
F383  4A        LSR A           )
F384  4A        LSR A           ) Bring upper nibble to lower
F385  20 F9 C5  JSR #C5F9       Convert to hex and print
F388  68        PLA             Restore number
F389  29 0F     AND @#F         Clear upper nibble
F38B  4C F9 C5  JMP #C5F9       Convert to hex and print


  Deal with Assembler Statement
  -----------------------------

F38E  A2 00     LDX @#0
F390  86 00     STX #0          Clear error number
F392  86 64     STX #64         Clear w/s
F394  86 65     STX #65         Clear w/s

                                GET OPCODE

F396  20 91 F2  JSR #F291       Get the next non-space chracter from text
F399  C9 3A     CMP @#3A        Is it ':', indicating label definition ?
F39B  F0 91     BEQ #F32E       ..yes, set up label to memory pointer P
F39D  C9 3B     CMP @#3B        Is it statement separator ';' ?
F39F  F0 CA     BEQ #F36B       ..yes, set up the memory pointer P
F3A1  C9 0D     CMP @#D         Is it the text line terminator <CR> ?
F3A3  F0 C6     BEQ #F36B       ..yes, set up the memory pointer P
F3A5  C9 5C     CMP @#5C        Is it '\', indicating a comment field ?
F3A7  F0 B7     BEQ #F360       ..yes, skip to end of comment field

                                ENCODE CHARACTER OF OPCODE INTO #6A, #69

F3A9  A0 05     LDY @#5
F3AB  38        SEC
F3AC  69 00     ADC @#0         Add 1 and clear carry
F3AE  0A        ASL A           )
F3AF  0A        ASL A           ) Shift into upper nibble, with MS bit of
F3B0  0A        ASL A           ) lower nibble clear
F3B1  0A        ASL A           )
F3B2  26 6A     ROL #6A         )
F3B4  26 69     ROL #69         )
F3B6  88        DEY             ) Shift it 5 bits into #6A, #69
F3B7  D0 F8     BNE #F3B1       )
F3B9  E8        INX             Increment opcode character counter
F3BA  E0 03     CPX @#3         Fetched all 3 characters of opcode ?
F3BC  D0 D8     BNE #F396       ..no, fetch & encode the next character
F3BE  06 6A     ASL #6A
F3C0  26 69     ROL #69

                                TRY TO MATCH OPCODE AGAINST TABLES

F3C2  A2 40     LDX @#40        Pointer to compressed mnemonic tables
F3C4  A5 69     LDA #69         Get LSB compressed encoded opcode
F3C6  DD 54 F1  CMP #F154,X     Match in table ?
F3C9  F0 04     BEQ #F3CF       ..yes, now try to match MSB
F3CB  CA        DEX             ..no, decrement the  table counter
F3CC  D0 F8     BNE #F3C6       ..and try to match the next tabled opcode
F3CE  00        BRK             ..unless run out of table !
F3CF  BC 94 F1  LDY #F194,X     Get MSB code from table
F3D2  C4 6A     CPY #6A         Match MSB compressed encoded opcode ?
F3D4  D0 F5     BNE #F3CB       ..no, try the next code from the table

                                SUCCESSFUL OPCODE MATCH

F3D6  BD 10 F2  LDA #F210,X     Get Base address value (???) from table
F3D9  85 66     STA #66         ...into w/s
F3DB  BC 50 F2  LDY #F250,X     Get Base address value (???) from table
F3DE  84 0F     STY #F          ...into w/s
F3E0  66 64     ROR #64
F3E2  66 65     ROR #65
F3E4  88        DEY
F3E5  D0 F9     BNE #F3E0
F3E7  A4 0F     LDY #F
F3E9  C0 0D     CPY @#D
F3EB  D0 05     BNE #F3F2
F3ED  A2 00     LDX @#0
F3EF  4C 9B F4  JMP #F49B       Construct opcode and data


  Get Assembler Addressing Mode Data and Type
  -------------------------------------------

F3F2  20 91 F2  JSR #F291       Get the next non-space character from text
F3F5  C9 40     CMP @#40        Is it '@', signifying immediate address ?
F3F7  F0 5B     BEQ #F454       ..yes, deal with immediate address mode
F3F9  C9 28     CMP @#28        Is it '(', signifying indirect address ?
F3FB  F0 65     BEQ #F462       ..yes, deal with indirect address mode
F3FD  A2 01     LDX @#1
F3FF  C9 41     CMP @#41        Is it 'A', signifying accumulator
                                addressing mode ?
F401  F0 EC     BEQ #F3EF       ..yes, construct opcode
F403  C6 03     DEC #3
F405  20 8B C7  JSR #C78B       Evaluate address onto the w/s stack
F408  20 91 F2  JSR #F291       Get next non-space character from text
F40B  C9 2C     CMP @#2C        Is it ',', signifying indexed addressing ?
F40D  D0 31     BNE #F440       ..no,

                                DEAL WITH INDEXED ADDRESSING

F40F  20 91 F2  JSR #F291       ..yes, Get the next non-space character
                                from text
F412  A4 25     LDY #25
F414  F0 15     BEQ #F42B
F416  A2 09     LDX @#9
F418  C9 58     CMP @#58        Is the index 'X' ?
F41A  F0 7F     BEQ #F49B       ..yes, construct opcode and data
F41C  CA        DEX
F41D  C9 59     CMP @#59        Is the index 'Y'
F41F  D0 79     BNE #F49A       ..no, but nothing else is valid ! - BRK
F421  A5 0F     LDA #F
F423  C9 09     CMP @#9
F425  D0 74     BNE #F49B       Construct opcode and data
F427  A2 0E     LDX @#E
F429  D0 70     BNE #F49B       Construct opcode and data
F42B  A2 04     LDX @#4
F42D  C9 58     CMP @#58
F42F  F0 6A     BEQ #F49B       Construct opcode and data
F431  C9 59     CMP @#59
F433  D0 65     BNE #F49A
F435  CA        DEX
F436  A4 0F     LDY #F
F438  C0 03     CPY @#3
F43A  B0 5F     BCS #F49B       Construct opcode and data
F43C  A2 08     LDX @#8
F43E  D0 5B     BNE #F49B       Construct opcode and data

  Act on Assembler ??? Mode
  -------------------------

F440  C6 03     DEC #3
F442  A2 02     LDX @#2
F444  A4 0F     LDY #F
F446  C0 0C     CPY @#C
F448  F0 51     BEQ #F49B       Construct opcode and data
F44A  A2 05     LDX @#5
F44C  A5 25     LDA #25
F44E  F0 4B     BEQ #F49B       Construct opcode and data
F450  A2 0C     LDX @#C
F452  D0 47     BNE #F49B       Construct opcode and data


  Act on Assembler Immediate Mode
  -------------------------------

F454  20 8B C7  JSR #C78B
F457  A5 0F     LDA #F
F459  A2 06     LDX @#6
F45B  C9 01     CMP @#1
F45D  F0 3C     BEQ #F49B       Construct opcode and data
F45F  E8        INX
F460  D0 39     BNE #F49B       Construct opcode and data


  Act on Assembler Indirect Mode
  ------------------------------

F462  20 8B C7  JSR #C78B
F465  20 91 F2  JSR #F291
F468  C9 29     CMP @#29
F46A  F0 16     BEQ #F482
F46C  C9 2C     CMP @#2C
F46E  D0 2A     BNE #F49A
F470  20 91 F2  JSR #F291
F473  C9 58     CMP @#58
F475  D0 23     BNE #F49A
F477  20 91 F2  JSR #F291
F47A  C9 29     CMP @#29
F47C  D0 1C     BNE #F49A
F47E  A2 0B     LDX @#B
F480  D0 19     BNE #F49B       Construct opcode and data
F482  A2 0D     LDX @#D
F484  A5 0F     LDA #F
F486  C9 0B     CMP @#B
F488  F0 11     BEQ #F49B       Construct opcode and data
F48A  A2 0A     LDX @#A
F48C  20 91 F2  JSR #F291
F48F  C9 2C     CMP @#2C
F491  D0 07     BNE #F49A
F493  20 91 F2  JSR #F291
F496  C9 59     CMP @#59
F498  F0 01     BEQ #F49B       Construct opcode and data
F49A  00        BRK


  Construct Assembler Opcode and Data
  -----------------------------------

F49B  20 60 F3  JSR #F360
F49E  BD D5 F1  LDA #F1D5,X
F4A1  F0 04     BEQ #F4A7
F4A3  25 64     AND #64
F4A5  D0 07     BNE #F4AE
F4A7  BD E4 F1  LDA #F1E4,X
F4AA  25 65     AND #65
F4AC  F0 EC     BEQ #F49A
F4AE  18        CLC
F4AF  BD F3 F1  LDA #F1F3,X
F4B2  65 66     ADC #66
F4B4  85 66     STA #66
F4B6  BD 02 F2  LDA #F202,X
F4B9  A2 00     LDX @#0
F4BB  86 04     STX #4
F4BD  A4 16     LDY #16
F4BF  84 67     STY #67
F4C1  A4 25     LDY #25
F4C3  84 68     STY #68
F4C5  C9 0F     CMP @#F
F4C7  F0 23     BEQ #F4EC
F4C9  29 0F     AND @#F
F4CB  A8        TAY
F4CC  C8        INY
F4CD  84 00     STY #0
F4CF  C0 02     CPY @#2
F4D1  D0 04     BNE #F4D7
F4D3  A4 68     LDY #68
F4D5  D0 C3     BNE #F49A
F4D7  A0 00     LDY @#0
F4D9  B9 66 00  LDA #66,Y
F4DC  91 52     STA (#52),Y
F4DE  C8        INY
F4DF  EE 31 03  INC #331
F4E2  D0 03     BNE #F4E7
F4E4  EE 4C 03  INC #34C
F4E7  C4 00     CPY #0
F4E9  D0 EE     BNE #F4D9
F4EB  60        RTS


  Handle Assembler Relative Addressing
  ------------------------------------

F4EC  A9 02     LDA @#2
F4EE  85 00     STA #0
F4F0  38        SEC
F4F1  A5 67     LDA #67
F4F3  ED 31 03  SBC #331
F4F6  85 67     STA #67
F4F8  A5 68     LDA #68
F4FA  ED 4C 03  SBC #34C
F4FD  85 68     STA #68
F4FF  38        SEC
F500  A5 67     LDA #67
F502  E9 02     SBC @#2
F504  85 67     STA #67
F506  A8        TAY
F507  A5 68     LDA #68
F509  E9 00     SBC @#0
F50B  F0 1F     BEQ #F52C
F50D  C9 FF     CMP @#FF
F50F  F0 16     BEQ #F527
F511  20 D1 F7  JSR #F7D1

F514  4F 55 54 20 4F 46 20 52 41 4E 47 45 3A 0A 0D     OUT OF RANGE:..


  Execute the Command 'OLD'
  -------------------------

  - Exits to END at #CD98 and hence to Direct Mode.

F531  20 E4 C4  JSR #C4E4       Do the interpreter post test
F534  88        DEY             Now Y=0
F535  84 52     STY #52         Set w/s to LSB start of text
F537  A5 12     LDA #12         Get text page
F539  85 53     STA #53         Set w/s to MSB start of text
F53B  98        TYA             Clear accumulator
F53C  C8        INY             Point to the MSB first line number
F53D  91 52     STA (#52),Y     ..and clear it, killing any previous NEW
F53F  4C 9B CD  JMP #CD9B       Evaluate END, updating TOP, and returning
                                to the Direct Mode.


  Execute the Command 'DRAW'
  --------------------------

  - Executes PLOT 5,X,Y.

F542  A2 05     LDX @#5         DRAW is PLOT 5
F544  D0 02     BNE #F548       ..so dump the PLOT number to the w/s
                                stack , interpret the (X,Y) coordinates
                                and execute as per the PLOT routine


  Execute the Command 'MOVE'
  --------------------------

  - Executes PLOT 12,X,Y.

F546  A2 0C     LDX @#C         MOVE is PLOT 12
F548  86 16     STX #16         ..so dump the PLOT number to the w/s stack
F54A  E6 04     INC #4          Increment w/s stack pointer
F54C  D0 06     BNE #F554       Interpret the (X,Y) coordinates and
                                execute as per the PLOT routine


  Execute the Command 'PLOT'
  --------------------------

                                EVALUATE PLOT NUMBER INTO #16, AND THE
                                X & Y COORDINATES INTO (#5A,#5B),(#5C,#5D)

F54E  20 BC C8  JSR #C8BC       Evaluate PLOT number onto the w/s stack
F551  20 31 C2  JSR #C231       Search for ',', executing BRK if failure
F554  20 BC C8  JSR #C8BC       Evaluate X coordinate onto the w/s stack
F557  20 31 C2  JSR #C231       Search for ',', executing BRK if failure
F55A  20 BC C8  JSR #C8BC       Evaluate Y coordinate onto the w/s stack
F55D  20 E4 C4  JSR #C4E4       Do the interpreter post test
F560  B5 15     LDA #15,X       Get LSB Y coordinate from the w/s stack
F562  85 5C     STA #5C         ..into w/s
F564  B5 24     LDA #24,X       Get MSB Y coordinate from the w/s stack
F566  85 5D     STA #5D         ..into w/s
F568  B5 14     LDA #14,X       Get LSB X coordinate from the w/s stack
F56A  85 5A     STA #5A         ..into w/s
F56C  B5 23     LDA #23,X       Get MSB X coordinate from the w/s stack
F56E  85 5B     STA #5B         ..into w/s
F570  A2 00     LDX @#0
F572  86 04     STX #4          Clear w/s stack pointer

                                GET LAST PLOTTED COORDINATE INTO
                                (#52,#53) FOR X, AND (#54,#55) FOR Y

F574  A2 03     LDX @#3
F576  BD C1 03  LDA #3C1,X      )
F579  95 52     STA #52,X       )
F57B  CA        DEX             ) Get data from the LPP stack #3C1..#3C4
F57C  10 F8     BPL #F576       ) and store in w/s #52..#55

                                DEAL WITH ABSOLUTE AND RELATIVE PLOTS

F57E  A5 16     LDA #16         Get PLOT number
F580  29 04     AND @#4         Is it MOVE/DRAW to an absolute position ?
F582  D0 13     BNE #F597       ..yes, so the LPP is not used

                                ADD OLD (X,Y) COORDINATE TO NEW (X,Y)
                                COORDINATE FOR RELATIVE PLOTS

F584  A2 02     LDX @#2
F586  18        CLC
F587  B5 5A     LDA #5A,X       Get new X or Y LSB coordinate
F589  75 52     ADC #52,X       Add to old X or Y LSB coordinate
F58B  95 5A     STA #5A,X       ..and store resultant relative coordinate
F58D  B5 5B     LDA #5B,X       Get new X or Y MSB coordinate
F58F  75 53     ADC #53,X       Add to old X or Y LSB coordinate
F591  95 5B     STA #5B,X       ..and store resultant relative coordinate
F593  CA        DEX
F594  CA        DEX
F595  10 EF     BPL #F586       ..do both X and Y coordinates

                                COPY NEW PLOT POSITION TO THE
                                LAST PLOTTED POINT STACK

F597  A2 03     LDX @#3         )
F599  B5 5A     LDA #5A,X       )
F59B  9D C1 03  STA #3C1,X      )
F59E  CA        DEX             ) Get data from w/s #5A..#5D
F59F  10 F8     BPL #F599       ) and store in the LPP stack #3C1..#3C4

                                EXECUTE POINT PLOT OR LINE DRAW AS RQD

F5A1  A5 16     LDA #16         Get PLOT number
F5A3  29 03     AND @#3         Is it just a MOVE ?
F5A5  F0 0B     BEQ #F5B2       ..yes, return to interpreter
F5A7  85 5E     STA #5E         Save these 3 bits as Clear/Set/Invert flag
F5A9  A5 16     LDA #16         Get PLOT number
F5AB  29 08     AND @#8         Is it a point plot or a line draw ?
F5AD  F0 06     BEQ #F5B5       Branch if it's a line draw
F5AF  20 78 F6  JSR #F678       Otherwise plot a point
F5B2  4C 5B C5  JMP #C55B       ..and return to the interpreter


  Draw a Line Routine
  -------------------

- Uses the point plot routine at (#3FE).
- Returns to the interpreter at #C55B.
- Entry: Old position X coordinate (#52,#53)
         Old position Y coordinate (#54,#55)
         New position X coordinate (#5A,#5B)
         New position Y coordinate (#5C,#5D)
         #5E=0,1,2 to Clear, Set or Invert the line.

- Uses:  Change  in   X coordinate (#52,#53)
         Change  in   Y coordinate (#54,#55)
         Old position X coordinate (#5A,#5B)
         Old position Y coordinate (#5C,#5D)

                                CALCULATE (NEW X) - (OLD X) INTO (#56,#57)
                                CALCULATE (NEW Y) - (OLD Y) INTO (#58,#59)

F5B5  A2 02     LDX @#2
F5B7  38        SEC
F5B8  B5 5A     LDA #5A,X       Get LSB new X or Y
F5BA  F5 52     SBC #52,X       Subtract LSB old X or Y
F5BC  B4 52     LDY #52,X       Get LSB old X or Y
F5BE  94 5A     STY #5A,X       ..and store LSB X or Y in new w/s
F5C0  95 52     STA #52,X       Store LSB X or Y change in w/s
F5C2  B4 53     LDY #53,X       Get MSB old X or Y
F5C4  B5 5B     LDA #5B,X       Get MSB new X or Y
F5C6  F5 53     SBC #53,X       Subtract MSB old X or Y
F5C8  94 5B     STY #5B,X       ..and store MSB old X or Y in new w/s
F5CA  95 53     STA #53,X       Store MSB X or Y change in w/s
F5CC  95 56     STA #56,X       Keep a copy of MSB change for testing
F5CE  10 0D     BPL #F5DD       Branch if New >= Old

                                OFFSET IS NEGATIVE - NEGATE IT

F5D0  A9 00     LDA @#0
F5D2  38        SEC
F5D3  F5 52     SBC #52,X       Negate LSB change
F5D5  95 52     STA #52,X       ..and store it
F5D7  A9 00     LDA @#0
F5D9  F5 53     SBC #53,X       Negate MSB change
F5DB  95 53     STA #53,X       ..and store it
F5DD  CA        DEX
F5DE  CA        DEX
F5DF  10 D6     BPL #F5B7       ..deal with both X and Y coordinates

F5E1  A5 54     LDA #54         Get LSB Y change
F5E3  C5 52     CMP #52         Clear carry if LSB Y < LSB X
F5E5  A5 55     LDA #55         Get MSB X change
F5E7  E5 53     SBC #53         Subtract  MSB Y change
F5E9  90 31     BCC #F61C       ..deal with Y change < X change


  Plot a Line with (X change) <= (Y change)
  -----------------------------------------

F5EB  A9 00     LDA @#0
F5ED  E5 54     SBC #54
F5EF  85 57     STA #57
F5F1  A9 00     LDA @#0
F5F3  E5 55     SBC #55
F5F5  38        SEC
F5F6  6A        ROR A
F5F7  85 59     STA #59
F5F9  66 57     ROR #57
F5FB  20 78 F6  JSR #F678
F5FE  A5 5C     LDA #5C
F600  CD C3 03  CMP #3C3
F603  D0 0A     BNE #F60F
F605  A5 5D     LDA #5D
F607  CD C4 03  CMP #3C4
F60A  D0 03     BNE #F60F
F60C  4C 5B C5  JMP #C55B

F60F  20 55 F6  JSR #F655
F612  A5 59     LDA #59
F614  30 E5     BMI #F5FB
F616  20 44 F6  JSR #F644
F619  4C FB F5  JMP #F5FB


  Plot a Line with (X change) > (Y change)
  ----------------------------------------

F61C  A5 53     LDA #53
F61E  4A        LSR A
F61F  85 59     STA #59
F621  A5 52     LDA #52
F623  6A        ROR A
F624  85 57     STA #57
F626  20 78 F6  JSR #F678
F629  A5 5A     LDA #5A
F62B  CD C1 03  CMP #3C1
F62E  D0 07     BNE #F637
F630  A5 5B     LDA #5B
F632  CD C2 03  CMP #3C2
F635  F0 D5     BEQ #F60C
F637  20 44 F6  JSR #F644
F63A  A5 59     LDA #59
F63C  10 E8     BPL #F626
F63E  20 55 F6  JSR #F655
F641  4C 26 F6  JMP #F626


F644  38        SEC
F645  A5 57     LDA #57
F647  E5 54     SBC #54
F649  85 57     STA #57
F64B  A5 59     LDA #59
F64D  E5 55     SBC #55
F64F  85 59     STA #59
F651  A2 00     LDX @#0
F653  F0 0F     BEQ #F664
F655  18        CLC
F656  A5 57     LDA #57
F658  65 52     ADC #52
F65A  85 57     STA #57
F65C  A5 59     LDA #59
F65E  65 53     ADC #53
F660  85 59     STA #59
F662  A2 02     LDX @#2
F664  B5 56     LDA #56,X
F666  10 09     BPL #F671


  Decrement the Vector (#5A),X subroutine
  ---------------------------------------

F668  B5 5A     LDA #5A,X
F66A  D0 02     BNE #F66E
F66C  D6 5B     DEC #5B,X
F66E  D6 5A     DEC #5A,X
F670  60        RTS


  Increment the Vector (#5A),X subroutine
  ---------------------------------------

F671  F6 5A     INC #5A,X
F673  D0 FB     BNE #F670
F675  F6 5B     INC #5B,X
F677  60        RTS


  Plot a Point Subroutine
  -----------------------

F678  6C FE 03  JMP (#3FE)


  Execute the Command 'CLEAR'
  ---------------------------

- Sets up the appropriate word at #B000 for the 6847 VDG.
- Places the appropriate point plot routine address in vector #3FE, #3FF.

F67B  20 C8 C3  JSR #C3C8       Evaluate the Clear Mode number
F67E  A0 00     LDY @#0
F680  A5 52     LDA #52         Get the Mode number
F682  F0 3E     BEQ #F6C2       ..do CLEAR 0
F684  C9 05     CMP @#5         Is the Mode number>4 ?
F686  90 02     BCC #F68A       ..no
F688  A9 04     LDA @#4         ..yes, set it to 4
F68A  A2 80     LDX @#80
F68C  86 54     STX #54         Set MSB pointer to MSB start of screen
F68E  84 53     STY #53         Set LSB pointer to LSB start of screen
F690  85 52     STA #52         Save Mode number
F692  AA        TAX             Now X=Mode number
F693  BD CE F6  LDA #F6CE,X     Get page AFTER the last to be cleared

                                CHECK THAT TEXT IS NOT IN GRAPHICS AREA

F696  A6 12     LDX #12         Get text page
F698  10 04     BPL #F69E       Branch if in lower text space
F69A  C5 12     CMP #12         Otherwise test if Text is above Graphics
F69C  B0 E1     BCS #F67F       ..no, Text is in graphics area - BRK
F69E  AA        TAX             This is the page AFTER the last to clear
F69F  98        TYA             Clear accumulator

                                CLEAR GRAPHICS MEMORY - A PAGE AT A TIME

F6A0  91 53     STA (#53),Y     Clear graphics memory byte to zero
F6A2  88        DEY
F6A3  D0 FB     BNE #F6A0       ..do the complete page
F6A5  E6 54     INC #54         Point to the next page
F6A7  E4 54     CPX #54         Cleared all the graphics pages ?
F6A9  D0 F5     BNE #F6A0       ..no, so clear this page too

                                SET UP POINT PLOT VECTORS & INITIALISE VDG

F6AB  A4 52     LDY #52         Get the graphics Mode number
F6AD  B9 D8 F6  LDA #F6D8,Y     Get the MSB point plot routine address
F6B0  8D FF 03  STA #3FF        ..into the MSB point plot vector
F6B3  B9 D3 F6  LDA #F6D3,Y     Get the LSB point plot routine address
F6B6  8D FE 03  STA #3FE        ..into the LSB point plot vector
F6B9  B9 DD F6  LDA #F6DD,Y     Get the 6847 VDG Control Byte
F6BC  8D 00 B0  STA #B000       ..and set up the VDG graphic mode
F6BF  4C 58 C5  JMP #C558       ..back to the interpreter


  Perform 'CLEAR 0'
  -----------------

- Enter with Y=0

F6C2  A9 40     LDA @#40        Get graphics space character
F6C4  99 00 80  STA #8000,Y     Clear byte of upper screen page
F6C7  99 00 81  STA #8100,Y     Clear byte of lower screen page
F6CA  88        DEY
F6CB  D0 F7     BNE #F6C4       ..clear all 512 bytes of the screen
F6CD  F0 DC     BEQ #F6AB       Set up point plot vectors & initialise VDG


  Graphics Mode Control Data
  --------------------------

  Graphics Page Limit used by CLEAR 1 to Clear 4
  ----------------------------------------------

F6CF  84 86 8C 98

  Point Plot Routine LSBs for Graphic Modes 0 to 4
  ------------------------------------------------

F6D3  E2 3B 54 6D AA

  Point Plot Routine MSBs for Graphic Modes 0 to 4
  ------------------------------------------------

F6D8  F6 F7 F7 F7 F7

  VDG Control Byte for Graphic Modes 0 to 4
  -----------------------------------------

F6DD  00 30 70 B0 F0


  Mode 0 Point PLot Routine
  -------------------------

- Screen Resolution: X=0 to 63, Y=0 TO 47.
- Requires : #5A, #5B = X coordinate.
             #5C, #5D = Y coordinate.
             #5E=0,1,2  to clear, set, or invert the point.
- Destroys A,X,Y registers.

F6E2  A5 5B     LDA #5B         If MSB X>0..
F6E4  05 5D     ORA #5D         ..and MSB Y>0..
F6E6  D0 52     BNE #F73A       ..then RTS, since out of range
F6E8  A5 5A     LDA #5A         Get X coordinate
F6EA  C9 40     CMP @#40        Is it >=64 ?
F6EC  B0 4C     BCS #F73A       ..yes, out of range - return
F6EE  4A        LSR A           Divide by 2 to get X byte
F6EF  85 5F     STA #5F         Save byte in the X direction
F6F1  A9 2F     LDA @#2F        Get Ymax = 47
F6F3  38        SEC
F6F4  E5 5C     SBC #5C         ..and subtract the Y coordinate
F6F6  C9 30     CMP @#30        Is the Y coordinate out of range ?
F6F8  B0 40     BCS #F73A       ..yes, return

                                DIVIDE Y COORDINATE BY 3 BY SUBTRACTION

F6FA  A2 FF     LDX @#FF
F6FC  38        SEC
F6FD  E8        INX             Y byte counter
F6FE  E9 03     SBC @#3         Subtract 3, since there are 3 pixels to
                                a byte in the Y direction
F700  B0 FB     BCS #F6FD
F702  69 03     ADC @#3
F704  85 61     STA #61         Save remainder - this is the bit in the
                                graphics byte block
F706  8A        TXA             This is the byte in the Y direction
F707  0A        ASL A           )
F708  0A        ASL A           )
F709  0A        ASL A           )
F70A  0A        ASL A           ) Multiply by 16 to get the row offset
F70B  0A        ASL A           )       (32 bytes to a row)
F70C  05 5F     ORA #5F         Includes the bytes in the Y direction
F70E  85 5F     STA #5F         ..and save the LSB screen byte
F710  A9 80     LDA @#80        Get the MSB first screen address
F712  69 00     ADC @#0         Include any carry from the previous shifts
F714  85 60     STA #60         ..and save the MSB screen byte
F716  A5 5A     LDA #5A         Get the X coordinate
F718  4A        LSR A           If it's odd, set the Carry flag
F719  A5 61     LDA #61         Get the Y byte remainder
F71B  2A        ROL A           Include the X position
F71C  A8        TAY             ..and use as pointer to the bit mask table
F71D  B9 CB F7  LDA #F7CB,Y     Get the appropriate bit mask from table


  Point Clear/Set/Invert subroutine
  ---------------------------------

- Entry: (#5F) = Byte address
         Acc = Bit mask
         #5E = 0, 1, 2 to clear, set, or invert the point

F720  A0 00     LDY @#0
F722  A6 5E     LDX #5E
F724  CA        DEX
F725  F0 0F     BEQ #F736       ..branch to set the point
F727  CA        DEX
F728  F0 07     BEQ #F731       ..branch to invert the point


                                Clear point subroutine
                                ----------------------

F72A  49 FF     EOR @#FF
F72C  31 5F     AND (#5F),Y
F72E  91 5F     STA (#5F),Y
F730  60        RTS


                                Invert point subroutine
                                -----------------------

F731  51 5F     EOR (#5F),Y
F733  91 5F     STA (#5F),Y
F735  60        RTS


                                Set point sbroutine
                                -------------------

F736  11 5F     ORA (#5F),Y
F738  91 5F     STA (#5F),Y
F73A  60        RTS


  Mode 1 Point Plot subroutine
  ----------------------------

- Screen Resolution: X=0 to 127, Y=0 TO 64.
- Requires : #5A, #5B = X coordinate
             #5C, #5D = Y coordinate
             #5E=0,1,2  to clear, set, or invert the point.
- Destroys A,X,Y registers.

F73B  A5 5B     LDA #5B         If MSB X>0..
F73D  05 5D     ORA #5D         ..and MSB Y>0..
F73F  D0 F9     BNE #F73A       ..then RTS, since out of range
F741  A5 5A     LDA #5A         Get X coordinate
F743  30 F5     BMI #F73A       If >127 then RTS, since out of range
F745  4A        LSR A           )
F746  4A        LSR A           )
F747  4A        LSR A           ) Divide by 8 to get X
F748  85 5F     STA #5F         Save the byte in the X direction
F74A  A9 3F     LDA @#3F        Get Ymax = 63
F74C  38        SEC
F74D  E5 5C     SBC #5C         ..and subtract the Y coordinate
F74F  C9 40     CMP @#40        Is the Y coordinate out of range ?
F751  90 32     BCC #F785       ..no, multiply Y offset by 16 to get
                                bytes/row, calculate byte address, get bit
                                mask and clear/set/invert as appropriate
F753  60        RTS


  Mode 2 Point Plot subroutine
  ----------------------------

- Screen Resolution: X=0 to 127, Y=0 TO 95.
- Requires : #5A, #5B = X coordinate
             #5C, #5D = Y coordinate
             #5E=0,1,2  to clear, set, or invert the point.
- Destroys A,X,Y registers.

F754  A5 5B     LDA #5B         If MSB X>0..
F756  05 5D     ORA #5D         ..and MSB Y>0..
F758  D0 E0     BNE #F73A       ..then RTS, since out of range
F75A  A5 5A     LDA #5A         Get X coordinate
F75C  30 DC     BMI #F73A       If >127 then RTS, since out of range
F75E  4A        LSR A           )
F75F  4A        LSR A           )
F760  4A        LSR A           ) Divide by 8 to get X
F763  A9 5F     LDA @#5F        Get Ymax = 95
F765  38        SEC
F766  E5 5C     SBC #5C         ..and subtract the Y coordinate
F768  C9 60     CMP @#60        Is the Y coordinate out of range ?
F76A  90 19     BCC #F785       ..no, multiply Y offset by 16 to get
                                bytes/row, calculate byte address, get bit
                                mask and clear/set/invert as appropriate
F76C  60        RTS


  Mode 3 Point Plot subroutine
  ----------------------------

- Screen Resolution: X=0 to 127, Y=0 TO 191.
- Requires : #5A, #5B = X coordinate
             #5C, #5D = Y coordinate
             #5E=0,1,2  to clear, set, or invert the point.
- Destroys A,X,Y registers.

F76D  A5 5B     LDA #5B         If MSB X>0..
F76F  05 5D     ORA #5D         ..and MSB Y>0..
F771  D0 C7     BNE #F73A       ..then RTS, since out of range
F773  A5 5A     LDA #5A         Get X coordinate
F775  30 C3     BMI #F73A       If >127 then RTS, since out of range
F777  4A        LSR A           )
F778  4A        LSR A           )
F779  4A        LSR A           ) Divide by 8 to get X
F77A  85 5F     STA #5F         Save the byte in the X direction
F77C  A9 BF     LDA @#BF        Get Ymax = 191
F77E  38        SEC
F77F  E5 5C     SBC #5C         ..and subtract the Y coordinate
F781  C9 C0     CMP @#C0        Is the Y coordinate out of range ?
F783  B0 B5     BCS #F73A       ..yes, RTS

                                HERE: ACC = Y IN ROWS DOWN FROM SCREEN TOP
                                      ?#5F = X BYTE
                                      ?#5A = X BIT IN THE BYTE

                                MULTIPLY Y BY 16 TO GET ROW OFFSET

F785  A0 00     LDY @#0
F787  84 60     STY #60          Clear w/s
F789  0A        ASL A           ) LSB * 2
F78A  26 60     ROL #60         ) ..and MSB * 2
F78C  0A        ASL A           ) LSB * 4
F78D  26 60     ROL #60         ) ..and MSB * 4
F78F  0A        ASL A           ) LSB * 8
F790  26 60     ROL #60         ) ..and MSB * 8
F792  0A        ASL A           ) LSB * 16
F793  26 60     ROL #60         ) ..and MSB * 16
F795  65 5F     ADC #5F         Add X byte to LSB total address
F797  85 5F     STA #5F         ..and store it
F799  A5 60     LDA #60         Get MSB Y offset
F79B  69 80     ADC @#80        Add MSB screen start address
F79D  85 60     STA #60         ..and store it
F79F  A5 5A     LDA #5A         Get LSB X coordinate
F7A1  29 07     AND @#7         Clear all but the 3 LSBs
F7A3  A8        TAY             ..which is the index to the bit mask table
F7A4  B9 C9 F7  LDA #F7C9,Y     Get the appropriate bit mask
F7A7  4C 20 F7  JMP #F720       ..and clear/set/invert the bit as required


  Mode 4 Point Plot subroutine
  ----------------------------

- Screen Resolution: X=0 to 255, Y=0 TO 191.
- Requires : #5A, #5B = X coordinate
             #5C, #5D = Y coordinate
             #5E=0,1,2  to clear, set, or invert the point.
- Destroys A,X,Y registers.

F7AA  A5 5B     LDA #5B         If MSB X>0..   LSR A
F7AC  05 5D     ORA #5D         ..and MSB Y>0..
F7AE  D0 BC     BNE #F76C       ..then RTS, since out of range
F7B0  A5 5A     LDA #5A         Get X coordinate
F7B2  4A        LSR A           )
F7B3  4A        LSR A           )
F7B4  4A        LSR A           )
F7B5  85 5F     STA #5F         Save the byte in the X direction
F7B7  A9 BF     LDA @#BF        Get Ymax = 191
F7B9  38        SEC
F7BA  E5 5C     SBC #5C         ..and subtract the Y coordinate
F7BC  C9 C0     CMP @#C0        Is the Y coordinate out of range ?
F7BE  B0 AC     BCS #F76C       ..yes, RTS
F7C0  A0 00     LDY @#0
F7C2  84 60     STY #60         Clear MSB Y offset
F7C4  0A        ASL A           Multiply row LSB by 2
F7C5  26 60     ROL #60         and multiply row MSB by 2
F7C7  10 C0     BPL #F789       Multiply Y offset by 16 to get 32
                                bytes/row, calculate byte address, get bit
                                mask and clear/set/invert as appropriate


  Graphics Bit Mask Table
  -----------------------

- Used by Mode 1 to 4 point plot routines.

F7C9  80 40 20 10  8  4  2  1


  Print ASCII String subroutine
  -----------------------------

- Prints the string following the subroutine call up to a negative byte
  at which execution is recommenced.

F7D1  68        PLA             Get the return address LSB from stack
F7D2  85 E8     STA #E8         ..into w/s
F7D4  68        PLA             Get the return address MSB from stack
F7D5  85 E9     STA #E9         ..into w/s
F7D7  A0 00     LDY @#0
F7D9  E6 E8     INC #E8         Point to the next byte of embedded text
F7DB  D0 02     BNE #F7DF
F7DD  E6 E9     INC #E9         Increment MSB text pointerif carried over
F7DF  B1 E8     LDA (#E8),Y     Get the next character of embedded text
F7E1  30 06     BMI #F7E9       ..reached terminator - execute from here
F7E3  20 F4 FF  JSR #FFF4       Send character to OSWRCH
F7E6  4C D7 F7  JMP #F7D7       ..and go for the next character

F7E9  6C E8 00  JMP (#E8)       Continue execution from the negative byte


   Print the (#D4) Word in Hexadecimal Followed by a space subroutine
  -------------------------------------------------------------------

- Prints ?#D5, ?#D4 in hex, then a space, ?#D7, ?#D6 in hex, then another
  space.
- Returns with X=#D8, Y register preserved.

F7EC  A2 D4     LDX @#D4


  Print a 4 Byte Word in Hexadecimal followed by a Space subroutine
  -----------------------------------------------------------------

- Prints a word in hex in the order X+1, X, space, X+3, X+2, space.
- Preserves the Y resister and increments the X register 4 times.

F7EE  20 F1 F7  JSR #F7F1       print 1st vector in hex


  Print a 2 Byte Vector in Hexadecimal followed by a Space subroutine
  -------------------------------------------------------------------

- Prints in hex a vector in the order X+1, X and then a space.
- Preserves the Y resister and increments the X register twice.

F7F1  B5 01     LDA #1,X        Get MSB of vector
F7F3  20 02 F8  JSR #F802       Print in hex followed by a space
F7F6  E8        INX
F7F7  E8        INX
F7F8  B5 FE     LDA #FE,X       Get LSB of vector


  Print a Byte in Hexadecimal followed by a Space subroutine
  ----------------------------------------------------------

- Prints the contents of the accumulator in hex followed by a space.
- X and Y registers preserved.

F7FA  20 02 F8  JSR #F802       Print character in acc in hex via OSWRCH


  Print a Space subroutine
  ------------------------

F7FD  A9 20     LDA @#20        Get <SPC>
F7FF  4C F4 FF  JMP #FFF4       Print via OSWRCH


  Print a Byte in Hexadecimal subroutine
  --------------------------------------

- Prints the contents of the accumulator in hex
- X and Y registers preserved.

F802  48        PHA             Save number
F803  4A        LSR A           (
F804  4A        LSR A           (
F805  4A        LSR A           ( Shift the upper nibble down to the
F806  4A        LSR A           ( lower
F807  20 0B F8  JSR #F80B       Print nibble in hex via OSWRCH
F80A  68        PLA             Restore number
F80B  29 0F     AND @#F         Clear upper nibble
F80D  C9 0A     CMP @#A         Is it a letter ?
F80F  90 02     BCC #F813       ..yes
F811  69 06     ADC @#6         ..no, it's a numeric digit
F813  69 30     ADC @#30        Convert to ASCII
F815  4C F4 FF  JMP #FFF4       ..and print via OSWRCH


  Copy String from #100 Buffer to #140 Buffer subroutine
  ------------------------------------------------------

- Copies a quoted string from the Direct Mode buffer at #100 to the String
  Buffer at #140, terminating the string with #D.
- If <"> is not the first non-space character found, returns with
  a null string at #140.
- Sets up the pointer (#C9) to point to the start of the string at #140.
- Enter with Y register pointing to (spaces leading to) the quotes at the
  start of the string.
- Returns with Y pointing to the string termination quotes.
- Returns with Acc=1, X=#C9.

F818  30 76 F8  JSR #F876       Get to the first non-space character
F81B  A2 00     LDX @#0         Clear pointer to #140 buffer
F81D  C9 22     CMP @#22        Is the 1st non-space character '"' ?
F81F  F0 06     BEQ #F827       ..yes, found start of string
F821  E8        INX             ..no, point to #140
F822  D0 1B     BNE #F83F       ..and terminate the string there with #D
F824  4C 7D FA  JMP #FA7D       ..unless ran out of buffer - 'SYN?' & BRK

                                COPY STRING FROM #100 TO #140

F827  C8        INY             Point to next character in #100 buffer
F828  B9 00 01  LDA #100,Y      ..and get it
F82B  C9 0D     CMP @#D         Is it <CR> ?
F82D  F0 F5     BEQ #F824       ..yes, run out of buffer - 'SYN?' & BRK
F82F  9D 40 01  STA #140,X      Copy to #140 buffer
F832  E8        INX             Point to next position in #140 buffer
F833  C9 22     CMP @#22        Was this the '"' string terminator ?
F835  D0 F0     BNE #F827       ..no, keep copying until it's reached
F837  C8        INY             Point past the '"' in the #100 buffer
F838  B9 00 01  LDA #100,Y      ..and get this character
F83B  C9 22     CMP @#22        Is this '"' as well ?
F83D  F0 E8     BEQ #F827       ..yes, double quotes mean use single
                                quotes in string - NOT the end of string
                                so keep searching

                                TERMINATE #140 STRING AND RETURN

F83F  A9 0D     LDA @#D         Get <CR>
F841  9D 3F 01  STA #13F,X      ..and terminate the #140 string
F844  A9 40     LDA @#40        )
F846  85 C9     STA #C9         )
F848  A9 01     LDA @#1         ) Set (#CA) to point to start of #140
F84A  85 CA     STA #CA         ) string
F84C  A2 C9     LDX @#C9
F84E  60        RTS


  Transfer Tape File Control Block and Test Name subroutine
  ---------------------------------------------------------

- Transfers the 10 bytes in zero page starting at X to workspace starting
  at #C9.
- Checks that the filename at (#C9) is less than 14 bytes long - if it
  exceeds this length, the message 'NAME' is printed, and BRK executed.
- Returns with zero flag set if the string length is zero.

F84F  A0 00     LDY @#0
F851  B5 00     LDA #0,X        Get byte from here..
F853  99 C9 00  STA #C9,Y       ..into there
F856  E8        INX
F857  C8        INY
F858  C0 0A     CPY @#A         Done all 10 bytes ?
F85A  90 F5     BCC #F851       ..no, keep copying
F85C  A0 FF     LDY @#FF        Initialise string pointer
F85E  A9 0D     LDA @#D         Get <CR> string terminator
F860  C8        INY             Point to next character in filename
F861  C0 0E     CPY @#E         Exceeded allowing string length ?
F863  B0 07     BCS #F86C       ..yes, print 'NAME' and execute BRK
F865  D1 C9     CMP (#C9),Y     ..no, but is this char the terminator ?
F867  D0 F7     BNE #F860       ..no, keep checking
F869  C0 00     CPY @#0         Set zero flag if string length is zero
F86B  60        RTS

F86C  20 D1 F7  JSR #F7D1       Print the following text string

F86F  4E 41 4D 45                                       NAME

F872  EA        NOP             String terminator
F874  00        BRK


  Get Next Non-Space Character from #100 Buffer subroutine
  --------------------------------------------------------

- Increments Y to return pointing to the first non-space character in the
  Direct Mode Buffer at #100.
- Enter at #F876.

F875  C8        INY             Point to next character
F876  B9 00 01  LDA #100,Y      Get character from Direct Mode Buffer
F879  C9 20     CMP @#20        Is it <SPC> ?
F87B  F0 F8     BEQ #F875       ..no, try the next character
F87D  60        RTS


  Convert ASCII Hexadecimal Digit to Binary subroutine
  ----------------------------------------------------

- Converts an ASCII Hexadecimal character in the accumulator to its binary
  value.
- If valid hex, returns with binary value in accumulator and Carry clear.
- X and Y registers preserved.

F87E  C9 30     CMP @#30        Is it > '0' ?
F880  90 0F     BCC #F891       ..no, invalid hex character - return
F882  C9 3A     CMP @#3A        Is it < '9' ?
F884  90 08     BCC #F88E       ..yes, valid hex character
F886  E9 07     SBC @#7         Convert so 'A'=#3A to 'F'=#3F
F888  90 07     BCC #F891       Invalid if it was < 'A' but not a number
F88A  C9 40     CMP @#40        Is it a letter higher than 'F' ?
F88C  B0 02     BCS #F890       ..yes, invalid hex character - return
F88E  29 0F     AND @#F         Mask off top nibble
F890  60        RTS             Return with carry clear

F891  38        SEC
F892  60        RTS             Return with carry set


  Read 4 Hexadecimal Characters from #100 buffer subroutine
  ---------------------------------------------------------

- Reads a hex number as an ASCII string in the Direct Mode buffer pointed
  to by #100,Y and stores the 2 byte result in the zero page vector
  X (LSB) to X+1 (MSB).
- Interpretation stops at the first invalid hex digit, and returns with
  the Y register pointing to this character.
- The zero page byte X+2 is used for workspace.
- Sets Zero flag if the first character is invalid.

F893  A9 00     LDA @#0
F895  95 00     STA #0,X        Clear LSB vector
F897  95 01     STA #1,X        Clear MSB vector
F899  95 02     STA #2,X        Clear w/s
F89B  20 76 F8  JSR #F876       Get to next non-space char in #100 buffer
F89E  B9 00 01  LDA #100,Y      Get character from buffer
F8A1  20 7E F8  JSR #F87E       Convert ASCII hex digit to binary nibble
F8A4  B0 15     BCS #F8BB       ..invalid hex, quit
F8A6  0A        ASL A           )
F8A7  0A        ASL A           )
F8A8  0A        ASL A           )
F8A9  0A        ASL A           ) Transfer lower nibble to upper nibble
F8AA  94 02     STY #2,X        Save current state of buffer pointer

                                SHIFT NEW NIBBLE INTO THE VECTOR

F8AC  A0 04     LDY @#4         4 bits to a nibble
F8AE  0A        ASL A           Shift into carry..
F8AF  36 00     ROL #0,X        ..into LSB vector..
F8B1  36 01     ROL #1,X        ..and into MSB vector
F8B3  88        DEY
F8B4  D0 F8     BNE #F8AE       ..do all 4 bits

F8B6  B4 02     LDY #2,X        Restore buffer pointer
F8B8  C8        INY             Point to next character
F8B9  D0 E3     BNE #F89E       ..and try to decode that too

F8BB  B5 02     LDA #2,X        This will be zero if failed to decode
                                the first hex digit successfully
F8BD  60        RTS


  COS Interpreter Command Table
  -----------------------------

F8BE                                            43 41                CA
F8C0  54 FA 2A 4C 4F 41 44 F9 58 53 41 56 45 FA BB 52  T..LOAD..SAVE..R
F8D0  55 4E FA 20 4D 4F 4E FA 1A 4E 4F 4D 4F 4E FA 19  UN..MON..NOMON..
F8E0  46 4C 4F 41 44 F9 55 44 4F 53 0D E0 00 F9 26     FLOAD..DOS.....


  COS Interpreter subroutine
  --------------------------

- All '*' prefixed commands are interpreted here.
- Exits to all COS routines with carry clear, decimal mode flag cleared
  and X register = 0
- Jumps to default COS error handler at #F926 if cannot match command.
- Clears the FLOAD flag #DD to zero.

F8EF  A2 FF     LDX @#FF        Initialise the command table pointer
F8F1  D8        CLD
F8F2  A0 00     LDY @#0
F8F4  84 DD     STY #DD         Clear FLOAD flag (to not FLOAD mode)
F8F6  20 76 F8  JSR #F876       Get next non-space char from #100 buffer
F8F9  88        DEY
F8FA  C8        INY             Point to next character in #100 buffer
F8FB  E8        INX
F8FC  BD BE F8  LDA #F8BE,X     Get next character of the command word
                                under comparison from the command table
F8FF  30 18     BMI #F919       ..reached MSB command address - success !
F901  D9 00 01  CMP #100,Y      Same as character under interpretation ?
F904  F0 F4     BEQ #F8FA       ..yes, now try to match the next character

                                COMMAND WORD MATCH FAILED - SKIP TO
                                THE END OF THE WORD IN THE TABLE

F906  CA        DEX
F907  E8        INX             Point to next character of failed word
F908  BD BE F8  LDA #F8BE,X     ..and get it
F90B  10 FA     BPL #F907       ..not reached MSB address - keep searching
F90D  E8        INX             Point to LSB address in command table
F90E  B9 00 01  LDA #100,Y      Get the failed character from the buffer
F911  C9 2E     CMP @#2E        Is it the command abbreviator '.' ?
F913  D0 DD     BNE #F8F2       ..no, so try to match the next command

                                SUCCESSFUL MATCH OF ABBREVIATED COMMAND

F915  C8        INY             Skip past the '.' abbreviator
F916  CA        DEX             Point to the MSB address in command table
F917  B0 E3     BCS #F8FC       ..and fetch it

                                COMMAND WORD MATCH ( OR OUT OF TABLE )

F919  85 CA     STA #CA         Store MSB address in w/s
F91B  BD BF F8  LDA #F8BF,X     Get LSB address from command table
F91E  85 C9     STA #C9         Store LSB address in w/s
F920  18        CLC
F921  A2 00     LDX @#0         Clear X register before exit
F923  6C C9 00  JMP (#C9)       Jump to execute the COS command


  Default COS Error Handler
  -------------------------

- Sends the string 'COM?' to OSWRCH and then executes BRK.

F926  20 D1 F7  JSR #F7D1       Send the following string to WRCHAR

F929  43 4F 4D 3F                                      COM?

F92D  EA        NOP             Negative string termination byte
F92E  00        BRK


  Load an Un-Named File subroutine
  --------------------------------
File format : <MSB file  end  address>
                <LSB file  end  address>
                <MSB file start address>
                <LSB file start address>
                <.........data.........>

- Used by OSLOAD.
- Entry: #CB = LSB User specified load address
         #CC = MSB User specified load address
         #CD = *LOAD flag - if bit 7 is set then the load address at
               (#CB) is to be used instead of the file's load address
- Uses:  #D4 = LSB Data start address from header
         #D5 = MSB Data start address from header
         #D6 = LSB Data  end  address from header
         #D7 = MSB Data  end  address from header

F92F  20 8E FB  JSR #FB8E       Wait for high tone leader, read the 4 byte
                                header preamble, and test it for '****'
F932  50 FA     BVC #F92E       ..<CTRL> key was pressed - execute BRK
F934  F0 F9     BEQ #F92F       ..found '****' - skip this named file

                                FOUND UN-NAMED FILE

F936  20 2B FC  JSR #FC2B       Get file start address to (#CB)

                                GET DATA FROM TAPE INTO MEMORY

F939  A0 00     LDY @#0         Clear memory pointer
F93B  20 D4 FF  JSR #FFD4       Get byte of data from tape via OSBGET
F93E  91 CB     STA (#CB),Y     ..and dump to memory
F940  E6 CB     INC #CB         Increment LSB memory pointer
F942  D0 02     BNE #F946
F944  E6 CC     INC #CC         Increment MSB memory pointer if overflow
F946  A2 D4     LDX @#D4        Point to start address
F948  20 08 FA  JSR #FA08       Increment start address, test to see if
                                have reached the end address
F94B  D0 EE     BNE #F93B       ..not loaded all the file, get next byte

                                FILE LOADED - RETURN

F94D  38        SEC             )
F94E  66 DD     ROR #DD         )
F950  18        CLC             )
F951  66 DD     ROR #DD         ) Set bit 6 and clear bit 7 of FLOAD flag
F953  28        PLP             Restore interrupt status, pushed by OSLOAD
F954  60        RTS


  Execute the Command '*FLOAD' subroutine
  ---------------------------------------

F955  38        SEC
F956  66 DD     ROR #DD         Set bit 7 of FLOAD flag, indicating FLOAD


  Execute the Command '*LOAD' subroutine
  --------------------------------------

- Exits via the LODVEC (#20C)

F958  20 18 F8  JSR #F818       Copy quoted filename from #100 buffer to
                                the #140 buffer
F95B  A2 CB     LDX @#CB        Point to the vector at #CB, #CC
F95D  20 93 F8  JSR #F893       ..and interpret the load address to store
                                it here
F960  F0 04     BEQ #F966       ..can't interpret load address - so the
                                file's own load address is to be used
F962  A9 FF     LDA @#FF
F964  85 CD     STA #CD         Set the load flag, so that the interpreted
                                start address is used, not the file's one
F966  20 76 FA  JSR #FA76       Do COS interpreter post test
F969  A2 C9     LDX @#C9        File data starts at #C9
F96B  6C 0C 02  JMP (#20C)      Jump to OSLOAD


  OSLOAD Load File subroutine
  ---------------------------

- Entry: 0,X = LSB File name string address
         1,X = MSB File name string address
         2,X = LSB Data dump start address
         3,X = MSB Data dump start address
         4,X : If bit 7 is clear, then the file's own start address is
               to be used
         #DD = FLOAD flag - bit 7 is set if in FLOAD mode

- Uses:  #C9 = LSB File name string address
         #CA = MSB File name string address
         #CB = LSB Data dump start address
         #CC = MSB Data dump start address
         #CD = load flag - if bit 7 is set, then the load address at
               (#CB) is to be used instead of the file's load address
         #D0 = MSB Current block number
         #D1 = LSB Current block number

- Header format: <*>                      )
                 <*>                      )
                 <*>                      )
                 <*>                      ) Header preamble
                 <Filename>               ) Name is 1 to 13 bytes long
                 <Status Flag>            ) Bit 7 clear if last block
                                          ) Bit 6 clear to skip block
                                          ) Bit 5 clear if first block
                 <LSB block number>
                 <MSB block number>       ) Always zero
                 <Bytes in block>
                 <MSB run address>
                 <LSB run address>
                 <MSB block load address>
                 <LSB block load address>

- Data format:   <....data....>           ) 1 to #FF bytes
                 <Checksum>               ) LSB sum of all data bytes

F96E  08        PHP             Save interrupt status
F96F  78        SEI             No interrupts !
F970  20 4F F8  JSR #F84F       Transfer file data to w/s starting at #C9
                                and test length of filename
F973  08        PHP             Save result of filename test
F974  20 3E FC  JSR #FC3E       Send message 'PLAY TAPE' to WRCHAR & wait
                                for keypress
F977  28        PLP             Restore result of filename test
F978  F0 B5     BEQ #F92F       ..it's zero - load un-named file
F97A  A9 00     LDA @#0
F97C  85 D0     STA #D0         Clear LSB current block number
F97E  85 D1     STA #D1         Clear MSB current block number
F980  20 A2 F9  JSR #F9A2       Load the block into memory
F983  90 C9     BCC #F94E       ..done last block - exit
F985  E6 D0     INC #D0         Increment LSB current block number
F987  E6 CC     INC #CC         Increment MSB data dump address
F989  D0 F5     BNE #F980       ..and load the next block
F98B  18        CLC             ..unless overflowed address range
F98C  90 C0     BCC #F94E       Exit to clear bit 6 of FLOAD flag to
                                indicate failure


  Print Filename subroutine
  -------------------------

- Enter at #F992 with Y=0.
- Prints the filename starting at #ED and terminated with <CR>.
- Pads out the filename with spaces to a length of 15 characters.
- Returns with carry set.

F98E  20 F4 FF  JSR #FFF4       Send character to WRCHAR
F991  C8        INY             Point to next character of filename

                                ENTER HERE

F992  B9 ED 00  LDA #ED,Y       Get character of filename
F995  C9 0D     CMP @#D         Is it the filename terminator, <CR> ?
F997  D0 F5     BNE #F98E       ..no, print it & fetch the next character

                                PAD OUT PRINT LINE TO 15 CHARACTERS

F999  C8        INY             Increment character counter
F99A  20 FD F7  JSR #F7FD       Send a space to WRCHAR
F99D  C0 0E     CPY @#E         Reached a count of 14 ?
F99F  90 F8     BCC #F999       ..no, send another space to WRCHAR
F9A1  60        RTS


  Load Current Block subroutine
  -----------------------------

- Entry: #C9 = LSB File name string address
         #CA = MSB File name string address
         #CB = LSB Data dump start  address
         #CC = MSB Data dump start  address
         #CD = load flag - if bit 7 is set, then the load address at
               (#CB) is to be used instead of the file's load address
         #D0 = MSB Current block number
         #D1 = LSB Current block number
         #DD = FLOAD flag - bit 7 is set if in FLOAD mode

Uses:    #D4 = MSB block address of block under examination
         #D5 = MSB block address of block under examination
         #D6 = LSB  run  address of block under examination
         #D7 = MSB  run  address of block under examination
         #D8 = Number of  bytes  in block under examination
         #D9 = LSB block  number of block under examination
         #DA = MSB block  number of block under examination
         #DB = Status flag of block under examination
         #DC = Computed checksum of block loaded into memory
         #ED = Start of filename of block under examination

F9A2  A9 00     LDA @#0
F9A4  85 DC     STA #DC         Clear checksum

                                GET HEADER PREAMBLE OF 4 ASTERISKS

F9A6  20 8E FB  JSR #FB8E       Wait for high tone leader, read the 4 byte
                                header preamble, and test it for '****'
F9A9  50 F8     BVC #F9A3       ..<CTRL> key was pressed - execute BRK
F9AB  D0 F5     BNE #F9A2       Preamble not correct - try again

                                GET FILENAME AND TEST IT'S THE RIGHT ONE

F9AD  20 C9 FB  JSR #FBC9       Get filename from tape, and check it
                                against the reference at (#C9)
F9B0  08        PHP             Save the result of the filename test
F9B1  20 E2 FB  JSR #FBE2       Get the remaining 8 bytes of the header
F9B4  28        PLP             Restore the result of the filename test
F9B5  F0 10     BEQ #F9C7       ..it's correct

                                DEAL WITH INCORRECT FILENAME ENCOUNTERED

F9B7  A5 DB     LDA #DB         Get the header status flag
F9B9  29 20     AND @#20        Is bit 5 Clear, indicating 1st block ?
F9BB  05 EA     ORA #EA
                                ENTER HERE

F992  B9 ED 00  LDA #ED,Y       Get character of filename
F995  C9 0D     CMP @#D         Is it the filename terminator, <CR> ?
F997  D0 F5     BNE #F98E       ..no, print it & fetch the next character

                                PAD OUT PRINT LINE TO 15 CHARACTERS

F999  C8        INY             Increment character counter
F99A  20 FD F7  JSR #F7FD       Send a space to WRCHAR
F99D  C0 0E     CPY @#E         Reached a count of 14 ?
F99F  90 F8     BCC #F999       ..no, send another space to WRCHAR
F9A1  60        RTS


  Load Current Block subroutine
  -----------------------------

- Entry: #C9 = LSB File name string address
         #CA = MSB File name string address
         #CB = LSB Data dump start  address
         #CC = MSB Data dump start  address
         #CD = load flag - if bit 7 is set, then the load address at
               (#CB) is to be used instead of the file's load address
         #D0 = MSB Current block number
         #D1 = LSB Current block number
         #DD = FLOAD flag - bit 7 is set if in FLOAD mode

Uses:    #D4 = MSB block address of block under examination
         #D5 = MSB block address of block under examination
         #D6 = LSB  run  address of block under examination
         #D7 = MSB  run  address of block under examination
         #D8 = Number of  bytes  in block under examination
         #D9 = LSB block  number of block under examination
         #DA = MSB block  number of block under examination
         #DB = Status flag of block under examination
         #DC = Computed checksum of block loaded into memory
         #ED = Start of filename of block under examination

F9A2  A9 00     LDA @#0
F9A4  85 DC     STA #DC         Clear checksum

                                GET HEADER PREAMBLE OF 4 ASTERISKS

F9A6  20 8E FB  JSR #FB8E       Wait for high tone leader, read the 4 byte
                                header preamble, and test it for '****'
F9A9  50 F8     BVC #F9A3       ..<CTRL> key was pressed - execute BRK
F9AB  D0 F5     BNE #F9A2       Preamble not correct - try again

                                GET FILENAME AND TEST IT'S THE RIGHT ONE

F9AD  20 C9 FB  JSR #FBC9       Get filename from tape, and check it
                                against the reference at (#C9)
F9B0  08        PHP             Save the result of the filename test
F9B1  20 E2 FB  JSR #FBE2       Get the remaining 8 bytes of the header
F9B4  28        PLP             Restore the result of the filename test
F9B5  F0 10     BEQ #F9C7       ..it's correct

                                DEAL WITH INCORRECT FILENAME ENCOUNTERED

F9B7  A5 DB     LDA #DB         Get the header status flag
F9B9  29 20     AND @#20        Is bit 5 Clear, indicating 1st block ?
F9BB  05 EA     ORA #EA         ..and is the NOMON flag clear ?
F9BD  D0 E3     BNE #F9A2       ..no, go on to try the next block
F9BF  20 92 F9  JSR #F992       ..yes, print the erroneous filename
F9C2  20 ED FF  JSR #FFED       ..followed by <CR><LF>
F9C5  D0 DB     BNE #F9A2       ..and go on to try the next block

                                CHECK BLOCK NUMBER

F9C7  A2 02     LDX @#2         Point to LSB block number
F9C9  A5 DD     LDA #DD         In FLOAD mode ?
F9CB  30 13     BMI #F9E0       ..yes, load block no matter what it is
F9CD  B5 CF     LDA #CF,X       Get LSB OR MSB current block number
F9CF  D5 D8     CMP #D8,X       Is this the block under examination ?
F9D1  B0 08     BCS #F9DB       ..Perhaps, it's less than or equal to

                                BLOCK NUMBER LARGER THAN THAT REQUIRED

F9D3  A9 05     LDA @#5
F9D5  20 40 FC  JSR #FC40       Print message 'REWIND TAPE'
F9D8  20 3E FC  JSR #FC3E       Print message 'PLAY TAPE'
F9DB  D0 C5     BNE #F9A2       ..and try the next block

F9DD  CA        DEX
F9DE  D0 ED     BNE #F9CD       ..test the MSB block number too

                                LOAD BLOCK INTO MEMORY

F9E0  20 2B FC  JSR #FC2B       Set up file loading address
F9E3  24 DB     BIT #DB         Test status - allowed to load this block ?
F9E5  50 0B     BVC #F9F2       ..no, do 'SUM' error
F9E7  88        DEY
F9E8  C8        INY             Point to next data memory location
F9E9  20 D4 FF  JSR #FFD4       Get data byte from tape via OSBGET
F9EC  91 CB     STA (#CB),Y     ..and dump to memory
F9EE  C4 D8     CPY #D8         Got all the bytes in the block ?
F9F0  D0 F6     BNE #F9E8       ..no, keep loading
F9F2  A5 DC     LDA #DC         Get checksum
F9F4  85 CE     STA #CE         ..into w/s
F9F6  20 D4 FF  JSR #FFD4       Get checksum from tape via OSBGET
F9F9  C5 CE     CMP #CE         Same as checksum calculated during load ?
F9FB  F0 08     BEQ #FA05       ..yes, test for last block and return

                                DEAL WITH CHECKSUM ERROR

F9FD  20 D1 F7  JSR #F7D1       Send the follwing string to WRCHAR

FA00  53 55 4D                                          SUM

FA03  EA        NOP             String termination byte
FA04  00        BRK

FA05  26 DB     ROL #DB         Clear carry if last block flag clear
FA07  60        RTS





  Increment and Test Vector subroutine
  ------------------------------------

- Increments the 2 byte vector at (0),X and compares with (2),X.
- Returns with Zero flag set if the two vectors are equal.

FA08  F6 00     INC #0,X        Increment LSB vector 1
FA0A  D0 02     BNE #FA0E
FA0C  F6 01     INC #1,X        Increment MSB vector 1 if overflow
FA0E  B5 00     LDA #0,X        Get LSB vector 1
FA10  D5 02     CMP #2,X        Same as LSB vector 2 ?
FA12  D0 04     BNE #FA18       ..no, return with Z flag clear
FA14  B5 01     LDA #1,X        Get MSB vector 1
FA16  D5 03     CMP #3,X        Same as MSB vector 2 ?
FA18  60        RTS


  Execute the Command '*NOMON' subroutine
  ---------------------------------------

- Sets all the bits of the NOMON flag at #EA.
- Enter with X=0.

FA19  CA        DEX             Now X=#FF


  Execute the Command '*MON' subroutine
  -------------------------------------

- Clears all the bits of the NOMON flag at #EA.
- Enter with X=0.

FA1A  20 76 FA  JSR #FA76       Do COS interpreter post test
FA1D  86 EA     STX #EA         Set/clear the NOMON flag as appropriate
FA1F  60        RTS


  Execute the Command '*RUN'
  --------------------------

FA20  20 58 F9  JSR #F958       Execute '*LOAD'
FA23  24 DD     BIT #DD
FA25  70 4C     BVS #FA73       If bit 6 of #DD is set then jump via (#CB)
FA27  6C D6 00  JMP (#D6)       ..otherwise


  Execute the Command '*CAT'
  --------------------------

FA2A  08        PHP             Save status
FA2B  20 76 FA  JSR #FA76       Do COS interpreter post test
FA2E  20 3E FC  JSR #FC3E       Print message 'PLAY TAPE' & get keypress
FA31  20 8E FB  JSR #FB8E       Wait for high tone leader, read the 4 byte
                                header preamble, and test it
FA34  70 02     BVS #FA38       ..if <CTRL> not pressed, print header
FA36  28        PLP             Restore status
FA37  60        RTS

FA38  F0 0A     BEQ #FA44        ..deal with named block

                                DEAL WITH UN-NAMED FILE

FA3A  A0 00     LDY @#0
FA3C  20 99 F9  JSR #F999       Print blank filename
FA3F  20 EC F7  JSR #F7EC       Print start & last+1 address in hex
FA42  D0 19     BNE #FA5D       Send <CR><LF> to WRCHAR, go for next block

                                DEAL WITH NAMED BLOCK

FA44  20 C9 FB  JSR #FBC9       Get filename from tape via OSBGET
FA47  20 E2 FB  JSR #FBE2       Get rest of header from tape via OSBGET
FA4A  20 92 F9  JSR #F992       Print header, padded out to 15 characters
FA4D  20 EC F7  JSR #F7EC       Print the block address at (#D4), a space,
                                then the run address at (#D6) in hex
FA50  26 DB     ROL #DB         If bit 6 of the block status flag is clear
FA52  10 09     BPL #FA5D       ..then omit printing the block number
FA54  E8        INX             Now X=#D9
FA55  20 F1 F7  JSR #F7F1       Print the block number at (#D9) in hex
FA58  B5 FD     LDA #FD,X       Get the number of bytes in the block (#D8)
FA5A  20 02 F8  JSR #F802       ..and print it in hex
FA5D  20 ED FF  JSR #FFED       Send <CR><LF> to WRCHAR
FA60  D0 CF     BNE #FA31       ..and go on to read the next header


FA62  4C ED FF  JMP #FFED


  Read 4 Hex Characters from #100 buffer with Invalid Test subroutine
  -------------------------------------------------------------------

- Reads a hex number as an ASCII string in the Direct Mode buffer pointed
  to by #100,Y and stores the 2 byte result in the zero page vector
  X (LSB) to X+1 (MSB).
- Interpretation stops at the first invalid hex digit, and returns with
  the Y register pointing to this character.
- The zero page byte X+2 is used for workspace.
- The Zero flag is set if the first character is invalid.
- 'SYN?' is printed and BRK executed if the first character is invalid.

FA65  20 93 F8  JSR #F893       Interpret hex number into vector X, X+1
FA68  F0 13     BEQ #FA7D       ..failed - print 'SYN?' and execute BRK
FA6A  60        RTS


  Get a Hexadecimal Number and Jump There
  ---------------------------------------

FA6B  A2 CB     LDX @#CB        Point to vector at #CB, #CC
FA6D  20 65 FA  JSR #FA65       ..and interpret the hex number at #100,Y
FA70  20 76 FA  JSR #FA76       Do the interpreter post test
FA73  6C CB 00  JMP (#CB)       Jump to the address just interpreted


  COS Post Test subroutine
  ------------------------

- Checks for <CR> or spaces leading to a <CR> in the #100 buffer after the
  current position pointed to by the Y register on entry.
- Prints 'SYN?' and executes BRK on failure.

FA76  20 76 F8  JSR #F876       Get the first non-space character from the
                                #100,Y buffer
FA79  C9 0D     CMP @#D         Is it <CR> ?
FA7B  F0 A2     BEQ #FA1F       ..yes, RTS
FA7D  20 D1 F7  JSR #F7D1       ..no, send the following string to WRCHAR

FA80  53 59 4E 3F                                       SYN?

FA84  EA        NOP             String termination byte
FA85  00        BRK


  Save an Un-Named File subroutine
  --------------------------------

- File format : <MSB file  end  address>
                <LSB file  end  address>
                <MSB file start address>
                <LSB file start address>
                <.........data.........>

- Used by OSSAVE.
- Entry: #CB = LSB File reload start address
         #CC = MSB File reload start address
         #CD = LSB File reload end address+1
         #CE = MSB File reload end address+1
         #CF = LSB File start address
         #D0 = MSB File start address
         #D1 = LSB File  end  address+1
         #D2 = MSB File  end  address+1

                                CALCULATE RELOAD ADDRESSES

FA86  38        SEC
FA87  A5 D1     LDA #D1         Get LSB end address+1
FA89  E5 CF     SBC #CF         Subtract LSB start address
FA8B  48        PHA             ..and save LSB file length
FA8C  A5 D2     LDA #D2         Get MSB end address+1
FA8E  E5 D0     SBC #D0         Subtract MSB start address
FA90  A8        TAY             ..and save MSB file length
FA91  68        PLA             Restore LSB file length
FA92  18        CLC
FA93  65 CB     ADC #CB         Add LSB file reload address
FA95  85 CD     STA #CD         ..and store LSB last reloaded byte+1
FA97  98        TYA             Restore MSB file length
FA98  65 CC     ADC #CC         Add MSB file reload address
FA9A  85 CE     STA #CE         ..and store MSB last reloaded byte+1

                                SEND FILE HEADER TO TAPE

FA9C  A0 04     LDY @#4         Set up byte counter - 4 bytes in header
FA9E  B9 CA 00  LDA #CA,Y       Get file reload start and end addresses
FAA1  20 D1 FF  JSR #FFD1       ..and send to tape via OSBPUT
FAA4  88        DEY             Point to next address byte
FAA5  D0 F7     BNE #FA9E       ..and send all 4 bytes

                                SEND DATA AS ONE CONTINUOUS FILE

FAA7  B1 CF     LDA (#CF),Y     Get data from memory
FAA9  20 D1 FF  JSR #FFD1       ..and send it to tape via OSBPUT
FAAC  E6 CF     INC #CF         Increment LSB memory address
FAAE  D0 02     BNE #FAB2
FAB0  E6 D0     INC #D0         Increment MSB memory address if overflow
FAB2  A2 CB     LDX @#CB        Point to vectors (#CB) and (#CD)
FAB4  20 08 FA  JSR #FA08       Increment (#CB) and compare with (#CD)
FAB7  D0 EE     BNE #FAA7       ..not reached end of file
FAB9  28        PLP             Restore interrupt status pushed by OSSAVE
FABA  60        RTS


  Execute the Command '*SAVE'
  ---------------------------

- Sets up the file address data from #C9 to #D1, and then calls the file
  save routine indirected by SAVVEC at (#20E), which is normally #FAE5.

- Uses:  #C9 = LSB File name string address
         #CA = MSB File name string address
         #CB = LSB Data Reload address
         #CC = MSB Data Reload address
         #CD = LSB Data Execution address
         #CE = MSB Data Execution address
         #CF = LSB Data start address
         #D0 = MSB Data start address
         #D1 = LSB Data end address + 1
         #D2 = MSB Data end address + 1

FABB  20 18 F8  JSR #F818       Copy filename string from #100 buffer to
                                the #140 buffer
FABE  A2 CB     LDX @#CB        Point to vector at #CB, #CC
FAC0  20 65 FA  JSR #FA65       ..and interpret start address to this
                                vector, printing 'SYN?' & BRK if fail
FAC3  A2 D1     LDX @#D1        Point to vector at #D1, #D2
FAC5  20 65 FA  JSR #FA65       ..and interpret end address to this
                                vector, printing 'SYN?' & BRK if fail
FAC8  A2 CD     LDX @#CD        Point to vector at #CD, #CE
FACA  20 93 F8  JSR #F893       ..and interpret run address to this
                                vector, if it has been specified
FACD  08        PHP             Save success/failure flag for the run
                                address interpretation
FACE  A5 CB     LDA #CB         Get LSB start address
FAD0  A6 CC     LDX #CC         Get MSB start address
FAD2  28        PLP             Restore run address success/failure flag
FAD3  D0 04     BNE #FAD9       ..run address was specified

                                FILE RUN ADDRESS NOT SPECIFIED - SET RUN
                                ADDRESS TO FILE START ADDRESS AS DEFAULT

FAD5  85 CD     STA #CD         Set LSB run address = LSB start address
FAD7  86 CE     STX #CE         Set MSB run address = MSB start address

                                SET FILE START ADDRESS = RELOAD ADDRESS

FAD9  85 CF     STA #CF         Set LSB start address = LSB reload address
FADB  86 D0     STX #D0         Set MSB start address = MSB reload address
FADD  20 76 FA  JSR #FA76       Do COS interpreter post test
FAE0  A2 C9     LDX @#C9        Point to file address data starting at #C9
FAE2  6C 0E 02  JMP (#20E)      ..and jump to OSSAVE


  Save File subroutine
  --------------------

- Enter with X pointing to the start of the file address data.
  Note: X=#52 when OSSAVE is called by the SAVE routine at #CF0A.
        X=#C9 when OSSAVE is called by the *SAVE routine at #FABB.

- Entry: 0,X = LSB File name string address
         1,X = MSB File name string address
         2,X = LSB Data Reload address
         3,X = MSB Data Reload address
         4,X = LSB Data Execution address
         5,X = MSB Data Execution address
         6,X = LSB Data start address
         7,X = MSB Data start address
         8,X = LSB Data end address + 1
         9,X = MSB Data end address + 1

- Uses:  #CF = Number of bytes in current block
         #D0 = LSB current block number
         #D1 = MSB current block number
         #D2 = Block flag - Bit 7 clear if last block
                            Bit 6 clear if block not to be loadable
                            Bit 5 set if first block
         #D3 = LSB current data start address
         #D4 = MSB current data start address
         #D5 = LSB current data  end  address
         #D6 = MSB current data  end  address
         #DC = LSB current data block arithmetic checksum

- Header format: <*>                     )
                 <*>                     )
                 <*>                     )
                 <*>                     ) Header preamble
                 <Filename>              ) Name is 1 to 13 bytes long
                 <Status Flag>           ) Bit 7 clear if last block
                                         ) Bit 6 clear to skip block
                                         ) Bit 5 clear if first block
                 <LSB block number>
                 <MSB block number>      ) Always zero
                 <Bytes in block>
                 <MSB run address>
                 <LSB run address>
                 <MSB block load address>
                 <LSB block load address>

- Data format:   <....data....>          ) 1 to #FF bytes
                 <Checksum>              ) LSB sum of all data bytes

FAE5  08        PHP             Save flags
FAE6  78        SEI             No interrupts !
FAE7  20 4F F8  JSR #F84F       Transfer file data to w/s starting at #C9
                                Test filename - set Zero flag if length
                                of filename is zero
FAEA  08        PHP             Save filename test flag
FAEB  A9 06     LDA @#6         Code to print 'RECORD TAPE'
FAED  20 40 FC  JSR #FC40       Start high tone, print 'RECORD TAPE' and
                                wait for a keypress before return

                                SEND 2 SECONDS OF HIGH TONE LEADER

FAF0  A2 07     LDX @#7         Get code to set 3 LSB's of port B high
FAF2  20 7A FB  JSR #FB7A       Wait 2 seconds with high tone enabled
FAF5  28        PLP             Restore result of filename test
FAF6  F0 8E     BEQ #FA86       ..deal with un-named file

                                COPY DATA START & END ADDRESSES TO W/S

FAF8  A2 04     LDX @#4
FAFA  B5 CE     LDA #CE,X       Get data from here
FAFC  95 D2     STA #D2,X       ..and store it there
FAFE  CA        DEX             Decrement counter
FAFF  D0 F9     BNE #FAFA       ..copy all 4 bytes

                                CLEAR BLOCK NUMBER

FB01  86 D0     STX #D0         Clear LSB block number
FB03  86 D1     STX #D1         Clear MSB block number

                                DECREMENT (END ADDRESS + 1) TO GET THE
                                CORRECT END ADDRESS

FB05  A5 D5     LDA #D5         Get LSB end address + 1
FB07  D0 02     BNE #FB0B       ..it's not zero
FB09  C6 D6     DEC #D6         If LSB is zero, decrement MSB too
FB0B  C6 D5     DEC #D5         Decrement LSB end address + 1

FB0D  18        CLC             Clear block flag bit to indicate 1st block
FB0E  66 D2     ROR #D2         This gets shifted down to bit 5

                                CALCULATE BLOCK SIZE

FB10  38        SEC
FB11  A2 FF     LDX @#FF        Get the default block size
FB13  A5 D5     LDA #D5         Get the LSB end address
FB15  E5 D3     SBC #D3         ..and subtract the LSB current address
FB17  85 CF     STA #CF         This is the number of bytes in the block
                                ONLY IF it's the last block
FB19  A5 D6     LDA #D6         Get the MSB end address
FB1B  E5 D4     SBC #D4         ..and subtract the MSB current address
FB1D  08        PHP             Save Carry flag
FB1E  66 D2     ROR #D2         ..and shift into block flag, to be shifted
                                to bit 6 - if clear block will not load !
FB20  28        PLP             Restore Carry flag
FB21  90 06     BCC #FB29       ..it's the last block, so clear bit 7 of
                                the block flag to indicate this
FB23  18        CLC
FB24  F0 03     BEQ #FB29       ..it's the last block, so clear bit 7 of
                                the block flag to indicate this
FB26  86 CF     STX #CF         Otherwise set block length to default #FF
FB28  38        SEC             Indicate that it's NOT the last block
FB29  66 D2     ROR #D2         Set/clear last block flag - bit 7 of the
                                block flag - as appropriate
FB2B  E8        INX             Unnecessary !!!
FB2C  20 3B FB  JSR #FB3B       Send header and data block to tape
FB2F  E6 D0     INC #D0         Increment LSB current block number
FB31  E6 D4     INC #D4         Increment MSB current data start address
FB33  E6 CC     INC #CC         Increment MSB current data reload address
FB35  26 D2     ROL #D2         Was the previous block the last block ?
FB37  B0 D5     BCS #FB0E       ..no, go to send the next block, with
                                Carry set to set bit 5 of block flag
                                since this block will not be first block
FB39  28        PLP             ..yes, restore interrupt status
FB3A  60        RTS             ..and return





  Send Header and Data Block to Tape subroutine
  ---------------------------------------------

FB3B  A2 07     LDX @#7         Code for tone on
FB3D  20 7A FB  JSR #FB7A       Wait 2 seconds with tone on
FB40  86 DC     STX #DC         Clear checksum

                                SEND HEADER PREAMBLE OF 4 ASTERISKS

FB42  A0 04     LDY @#4         Number of asterisks in preamble
FB44  A9 2A     LDA @#2A        Get '*'
FB46  20 D1 FF  JSR #FFD1       ..and send to tape via OSBPUT
FB49  88        DEY             Decrement asterisk counter
FB4A  D0 F8     BNE #FB44       ..and send all 4 asterisks

                                SEND FILENAME

FB4C  B1 C9     LDA (#C9),Y     Get character of filename
FB4E  20 D1 FF  JSR #FFD1       ..and send to tape via OSBPUT
FB51  C8        INY             Point to the next character of filename
FB52  C9 0D     CMP @#D         Reached <CR> filename terminator ?
FB54  D0 F6     BNE #FB4C       ..no, go for the next character

                                SEND REMAINS OF HEADER

FB56  A0 08     LDY @#8         Get number of bytes of header data to send
FB58  B9 CA 00  LDA #CA,Y       Get header data byte
FB5B  20 D1 FF  JSR #FFD1       ..and send it to tape via OSBPUT
FB5E  88        DEY             Point to the next byte
FB5F  D0 F7     BNE #FB58       ..and send all 8 bytes
FB61  20 81 FB  JSR #FB81       Wait 0.5 seconds between header and data
FB64  24 D2     BIT #D2         If bit 6 of block flag is clear..
FB66  50 0B     BVC #FB73       ..then don't send the block !

                                SEND DATA

FB68  88        DEY
FB69  C8        INY             Point to the next byte of data
FB6A  B1 D3     LDA (#D3),Y     ..and fetch it
FB6C  20 D1 FF  JSR #FFD1       Send byte to tape via OSBPUT
FB6F  C4 CF     CPY #CF         Sent all the bytes in the block ?
FB71  D0 F6     BNE #FB69       ..no, go for the next byte
FB73  A5 DC     LDA #DC         Get checksum
FB75  20 D1 FF  JSR #FFD1       ..and send it to tape via OSBPUT


  Wait 2 Seconds with Tape Tone Off subroutine
  --------------------------------------------

FB78  A2 04     LDX @#4         Get code to set PC0 and PC1 low


  Wait 2 Seconds subroutine
  -------------------------

- Tone to tape set by X register.
- If X=4, tone is off.
- If X=7, tone is on.

FB7A  8E 02 B0  STX #B002       Set bits of 8255 PIA port C
FB7D  A2 78     LDX @#78        Set counter to 180 60ths of a second
FB7F  D0 02     BNE #FB83       ..and count this many CRT flybacks


  Wait 0.5 Second subroutine
  --------------------------

FB81  A2 1E     LDX @#1E        Set counter to 30 60ths of a second


  Wait up to 4.25 Seconds subroutine
  ----------------------------------

- Waits X 60ths of a second.

FB83  20 66 FE  JSR #FE66       Wait for CRT flyback (one 60th of second)
FB86  CA        DEX             Decrement 60ths of a second counter
FB87  D0 FA     BNE #FB83
FB89  60        RTS


  Wait 0.1 second subroutine
  --------------------------

FB8A  A2 06     LDX @#6         Set counter to 6 60ths of a second
FB8C  D0 F5     BNE #FB83       ..and count this many CRT flybacks


  Read Header from Tape and Test for Un-Named File subroutine
  -----------------------------------------------------------


- Waits for 2 seconds of uninterrupted high tone leader, and then loads
  the first 4 data bytes into workspace #D3..#D6.
- If these 4 bytes are a valid header preamble '****', returns with Z set
  and Y=0.
- If <CTRL> key pressed during leader search, returns with V clear.
- If <SHIFT> key pressed during leader search, leader search is skipped.

                                WAIT FOR <SHIFT> & <CTRL> KEYS UNTOUCHED

FB8E  2C 01 B0  BIT #B001       Test keyboard
FB91  10 FB     BPL #FB8E       ..wait until <SHIFT> key not pressed
FB93  50 F9     BVC #FB8E       ..and until <CTRL> key not pressed

                                WAIT FOR HIGH TONE LEADER

FB95  A0 00     LDY @#0         )
FB97  85 C3     STA #C3         ) Set counter to #1000
FB99  A9 10     LDA @#10        ) Must detect 4096 cycles of high tone
FB9B  85 C2     STA #C2         ) leader
FB9D  2C 01 B0  BIT #B001       Test keyboard
FBA0  10 0F     BPL #FBB1       If <SHIFT> pressed, skip leader search
FBA2  50 0D     BVC #FBB1       If <CTRL> pressed, return now
FBA4  20 BD FC  JSR #FCBD       Count duration of tape pulse
FBA7  B0 EC     BCS #FB95       ..low tone detected - reset the leader
                                counter and start searching again
FBA9  C6 C3     DEC #C3         Decrement LSB leader counter
FBAB  D0 F0     BNE #FB9D
FBAD  C6 C2     DEC #C2         Decrement MSB leader counter if overflow
FBAF  D0 EC     BNE #FB9D       ..keep going until counted down to zero
FBB1  70 01     BVS #FBB4       If <CTRL> not pressed, go on to load the
                                header preamble
FBB3  60        RTS

                                LOAD HEADER PREAMBLE

FBB4  A0 04     LDY @#4         Set byte counter to load 4 bytes
FBB6  08        PHP             Save state of overflow flag (it's clear)
FBB7  20 E4 FB  JSR #FBE4       Read 4 bytes from tape via OSBGET
FBBA  28        PLP             Restore state of overflow flag (clear)

                                TEST HEADER PREAMBLE IS IT '****' ?

FBBB  A0 04     LDY @#4         Set preamble byte counter
FBBD  A9 2A     LDA @#2A        Get '*'
FBBF  D9 D3 00  CMP #D3,Y       Is this byte of the preamble an asterisk ?
FBC2  D0 03     BNE #FBC7       ..no, return with Carry clear - failure
FBC4  88        DEY             ..yes, point to next byte of preamble
FBC5  D0 F8     BNE #FBBF       ..and test all 4 bytes
FBC7  60        RTS


  Read Name from Tape and Compare Names subroutine
  ------------------------------------------------

- Reads bytes from tape up to filename terminator #D (<CR>), and stores
  the filename in workspace starting at #ED.
- Compares the read filename with the filename at (#C9), and returns with
  Z set if filenames match.
- Enter with Y=0 at #FBC9.

                                GET FILENAME FROM TAPE

FBC8  C8        INY             Point to the next byte of w/s
FBC9  20 D4 FF  JSR #FFD4       Get byte from tape via OSBGET
FBCC  99 ED 00  STA #ED,Y       ..and copy to w/s
FBCF  C9 0D     CMP @#D         Was it filename terminator <CR> ?
FBD1  D0 F5     BNE #FBC8       ..no, keep loading

                                COMPARE LOADED FILENAME WITH EXPECTED

FBD3  A0 FF     LDY @#FF        Set filename character pointer
FBD5  C8        INY             Point to the next character
FBD6  B1 C9     LDA (#C9),Y     Get character of source filename
FBD8  D9 ED 00  CMP #ED,Y       ..and compare with loaded filename
FBDB  D0 EA     BNE #FBC7       ..mismatch - return with Zero flag clear
FBDD  C9 0D     CMP @#D         Reached the filename terminator ?
FBDF  D0 F4     BNE #FBD5       ..no, keep testing
FBE1  60        RTS             ..yes, return with Zero flag set


  Get 8 Bytes from Tape into Workspace subroutine
  -----------------------------------------------

- Gets 8 bytes from tape via OSBGET into workspace starting at #DB
  backwards to #D4.
- Returns with Y=0 and zero flag set.

FBE2  A0 08     LDY @#8         Set byte counter
FBE4  20 D4 FF  JSR #FFD4       Get byte from tape via OSBGET
FBE7  99 D3 00  STA #D3,Y       ..and store in w/s
FBEA  88        DEY             Decrement byte counter
FBEB  D0 F7     BNE #FBE4       ..fetch and store all 8 bytes
FBED  60        RTS


  OSBGET Get Byte from Tape subroutine
  --------------------------------------

- Reads a byte from tape at 300 baud into the accumulator and adds its
  value to the arithmetic checksum at #DC.
- Preserves X,Y registers and flags.
- Uses:  #C3 = Temporary storage for Y register
         #EC = Temporary storage for X register


FBEE  86 EC     STX #EC         Save the X register
FBF0  84 C3     STY #C3         Save the Y register
FBF2  08        PHP             Save interrupt status
FBF3  78        SEI             No interrupts !

                                GET 0 START BIT

FBF4  A9 78     LDA @#78        Count 8 half cycles - from #78 to #80
FBF6  85 C0     STA #C0         Set transition counter
FBF8  20 BD FC  JSR #FCBD       Count duration of tape pulse
FBFB  90 F7     BCC #FBF4       ..duration less than 8, so it's a 1 bit
FBFD  E6 C0     INC #C0         Increment transition counter
FBFF  10 F7     BPL #FBF8       ..count 8 half cycles of 1.2 KHz = a 0 bit

                                GET 8 BIT BYTE FROM TAPE INTO #C0
                                ENTER WITH ?#C0=#80

FC01  A9 53     LDA @#53        Loop counter - this many passes through
                                the loop takes 3.3mS
FC03  85 C4     STA #C4         Set loop counter
FC05  A2 00     LDX @#0         Clear input transition counter
FC07  AC 02 B0  LDY #B002       Get input pulse
FC0A  20 CD FC  JSR #FCCD       ..and test state of the input pulse
FC0D  F0 00     BEQ #FC0F       ..no change   ( takes same time whether )
FC0F  F0 01     BEQ #FC12       ..no change   (      equal or not       )
FC11  E8        INX             Increment input pulse transition counter
FC12  C6 C4     DEC #C4         Decrement loop counter
FC14  D0 F4     BNE #FC0A       ..test for one bit time
FC16  E0 0C     CPX @#C         Test whether the bit is 0 or 1
                                - a 0 should give 8 transitions, and a
                                  a 1 should give 16 transitions, so this
                                  tests against the average of 12 - giving
                                  a large error margin !
FC18  66 C0     ROR #C0         Rotate bit into the partial byte
FC1A  90 E5     BCC #FC01       ..have done all the 8 bits when the
                                origionally set MSB of #C0 shifts down to
                                the Carry flag
FC1C  A5 C0     LDA #C0         Get the resulting complete byte
FC1E  28        PLP             Restore interrupt status
FC1F  A4 C3     LDY #C3         Restore the X register
FC21  A6 EC     LDX #EC         Restore the Y register


  Add Byte to Checksum subroutine
  -------------------------------

- Adds the contents of the accumulator to the arithmetic checksum at #DC.
- A,X,Y registers preserved.

FC23  48        PHA             Save the byte fetched from tape
FC24  18        CLC
FC25  65 DC     ADC #DC         ..and add it to the checksum
FC27  85 DC     STA #DC         Update the checksum
FC29  68        PLA             Restore the byte fetched from tape
FC2A  60        RTS


  Set up Block Load Address subroutine
  ------------------------------------

- If bit 7 of start address flag #CD is clear, then the vector #D4, #D5
  is copied to #CB, #CC.

FC2B  A5 CD     LDA #CD         Is file's own load address to be used ?
FC2D  30 08     BMI #FC37       ..no, return
FC2F  A5 D4     LDA #D4         Get the LSB load address from header w/s
FC31  85 CB     STA #CB         ..and set the LSB data dump address
FC33  A5 D5     LDA #D5         Get the MSB load address from header w/s
FC35  85 CC     STA #CC         ..and set the MSB data dump address
FC37  60        RTS


  Print "PLAY TAPE" or "RECORD TAPE" subroutine
  ---------------------------------------------

- Does full test for MON/NOMON, flagged by #EA.
- Entry: Carry clear - Prints 'RECORD TAPE' if bits 1 & 2 of #EA are clear
         Carry set   - Prints 'PLAY TAPE' if bit 2 of #EA is clear
- Entry with Acc=5 at #FC40 prints 'REWIND TAPE' if bits 0, 1 & 2 of #EA
  are clear.
- Waits for keypress before return.

FC38  B0 04     BCS #FC3E       ..deal with 'PLAY TAPE'
FC3A  A9 06     LDA @#6         Get 'RECORD TAPE' NOMON mask
FC3C  D0 02     BNE #FC40       ..and go to test
FC3E  A9 04     LDA @#4         Get 'PLAY TAPE' NOMON mask
FC40  A2 07     LDX @#7
FC42  8E 02 B0  STX #B002       Enable high tone leader to tape output
FC45  24 EA     BIT #EA         Is NOMON set for this function ?
FC47  D0 2D     BNE #FC76       ..yes, skip message printing
FC49  C9 05     CMP @#5         Is it 'REWIND TAPE' ?
FC4B  F0 16     BEQ #FC63       ..yes
FC4D  B0 09     BCS #FC58       ..no, it's 'RECORD'
FC4F  20 D1 F7  JSR #F7D1       Send the following string to OSWRCH

FC52  50 4C 41 59                                       PLAY

FC56  D0 15     BNE #FC6D       Print 'TAPE'


FC58  20 D1 F7  JSR #F7D1       Send the following string to OSWRCH

FC5B  52 45 43 4F 52 44                                 RECORD

FC61  D0 0A     BNE #FC6D       Print 'TAPE'


  Print "REWIND TAPE" subroutine
  ------------------------------

- Waits for keypress before return.

FC63  20 D1 F7  JSR #F7D1       Send the following string to OSWRCH

FC66  52 45 57 49 4E 44                                 REWIND

FC6C  EA        NOP             String termination byte
FC6D  20 D1 F7  JSR #F7D1       Send the following string to OSWRCH

FC70  20 54 41 50 45                                     TAPE

FC75  EA        NOP             String termination byte


  Wait for Keypress and Print <CR><LF> subroutine
  -----------------------------------------------

FC76  20 E3 FF  JSR #FFE3       Get keypress via OSRDCH
FC79  4C ED FF  JMP #FFED       Send <CR><LF> to OSWRCH


  OSBPUT Put Byte to Tape subroutine
  ----------------------------------

- Sends the byte in the accumulator to tape at 300 baud and adds it to the
  checksum at #DC.
- Byte format consists of: 1 '0' start bit
                           8     data bits
                           1 '1' stop bit
- Preserves A,X,Y registers and flags.

FC7C  86 EC     STX #EC         Save the X register
FC7E  84 C3     STY #C3         Save the Y register
FC80  08        PHP             Save interrupt status
FC81  78        SEI             No interrupts !
FC82  48        PHA             Save byte to be sent
FC83  20 23 FC  JSR #FC23       Add byte to checksum at #DC
FC86  85 C0     STA #C0         Save byte to be sent in w/s
FC88  20 D8 FC  JSR #FCD8       Wait for 1 falling edge of 2.4 KHz
FC8B  A9 0A     LDA @#A         Number of bits = 1 start + 8 data + 1 stop
FC8D  85 C1     STA #C1         Set bit counter
FC8F  18        CLC
FC90  90 0A     BCC #FC9C       Send '0' start bit then 8 data bits

                                SEND 8 CYCLES OF 2.4 KHz TO TAPE - '1' BIT

FC92  A2 07     LDX @#7         Set cycle counter
FC94  8E 02 B0  STX #B002       Set 3 LSB's of 8255 PIA port C high, thus
                                enabling the 2.4 KHz clock
FC97  20 DA FC  JSR #FCDA       Wait for 7 further falling edges
FC9A  30 13     BMI #FCAF       ..and go on to deal with the next bit

                                SEND 4 CYCLES OF 1.2 KHz TO TAPE - '1' BIT

FC9C  A0 04     LDY @#4         Set cycle counter
FC9E  A9 04     LDA @#4
FCA0  8D 02 B0  STA #B002       Clear the 2 LSB's of 8255 PIA port C, thus
                                disabling the 2.4 KHz clock
FCA3  20 D8 FC  JSR #FCD8       Wait for 1 falling edge of the 2.4 KHz
                                clock - tape output is high
FCA6  EE 02 B0  INC #B002       Set the LSB of 8255 PIA port C, so that
                                the 2.4 KHz is still disabled, but the
                                tape output is low
FCA9  20 D8 FC  JSR #FCD8       Wait for 1 falling edge of 2.4 KHz clock
FCAC  88        DEY             Decrement cycle counter
FCAD  D0 EF     BNE #FC9E       ..do all 4 cycles

                                DEAL WITH NEXT BIT

FCAF  38        SEC             Set Carry so 1 is shifted in and hence
                                the stop bit is '1'
FCB0  66 C0     ROR #C0         Shift the next bit for transmission into
                                the Carry flag
FCB2  C6 C1     DEC #C1         Decrement bit counter
FCB4  D0 DA     BNE #FC90       ..send this bit, unless sent all the bits
FCB6  A4 C3     LDY #C3         Restore the Y register
FCB8  A6 EC     LDX #EC         Restore the X register
FCBA  68        PLA             Restore accumulator
FCBB  28        PLP             Restore interrupt status
FCBC  60        RTS


  Count Duration of Tape Pulse subroutine
  ---------------------------------------

- Returns with Zero flag set if the total number of loops was 8.
- Returns with Carry set if total number of loops was > 7.
- Returns with Carry clear if total number of loops was < 8.
- Returns with X=count, but if X=0 then no change was detected in 256
  loops.
- Stores the on entry state of ?#B002 at #C5, returns with Y=new state.

FCBD  A2 00     LDX @#0         Clear loop counter
FCBF  AC 02 B0  LDY #B002       Get origional state of input pulse
FCC2  E8        INX             Increment loop counter
FCC3  F0 07     BEQ #FCCC       ..failed to detect change in 256 loops
FCC5  20 CD FC  JSR #FCCD       Has input pulse level changed ?
FCC8  F0 F8     BEQ #FCC2       ..no, increment counter & test again
FCCA  E0 08     CPX @#8         Compare loop counter with 8 before return
FCCC  60        RTS


  Test state of #B002 tape input pulse subroutine
  -----------------------------------------------

- Entry: Y = ?#B002
- Exit:  Y = new ?#B002
         ?#C5 = old #B002
- Returns with Z set if no change.

FCCD  84 C5     STY #C5         Save origional state of input pulse
FCCF  AD 02 B0  LDA #B002       Get current state of input pulse
FCD2  A8        TAY             ..and keep a copy of the new state
FCD3  45 C5     EOR #C5         Has it changed ?
FCD5  29 20     AND @#20        Mask off all but the input bit
FCD7  60        RTS             return with Z set if no change in level


  Wait for 1 Falling Edge of the 2.4KHz Clock subroutine
  ------------------------------------------------------

FCD8  A2 00     LDX @#0         Count 1 falling edge


  Wait for 1 to 127 Falling Edges of the 2.4KHz Clock subroutine
  --------------------------------------------------------------

- Waits for X+1 falling edges where 0<=X<=#80.

FCDA  A9 10     LDA @#10        Get mask for bit 4 of #B002 input port
FCDC  2C 02 B0  BIT #B002       Is clock input low ?
FCDF  F0 FB     BEQ #FCDC       ..yes, wait for it to go high
FCE1  2C 02 B0  BIT #B002       Is clock input high ?
FCE4  D0 FB     BNE #FCE1       ..yes, wait for it to go low
FCE6  CA        DEX             Decrement falling edge counter
FCE7  10 F3     BPL #FCDC       ..and count the required number of edges
FCE9  60        RTS


  Send ASCII Character to Screen subroutine
  -----------------------------------------

- Prints non-control codes (#20 to #FF) at the current cursor position on
  the screen.
- Executes the following control codes:

  <NUL><ACK><BEL><BS><HT><LF><VT><FF><CR><SO><SI><NAK><ESC>
    0    6    7   8   9   #A  #B  #C  #D  #E  #F  #15  #1B

                                TEST FOR CONTROL CODES

FCEA  C9 06     CMP @#6         Is it <ACK> ?
FCEC  F0 1D     BEQ #FD0B       ..yes, reset the 6847 VDG to alphanumeric
                                mode and clear the NAK flag
FCEE  C9 15     CMP @#15        Is it <NAK> ?
FCF0  F0 1F     BEQ #FD11       ..yes, set the NAK flag
FCF2  A4 E0     LDY #E0         Get cursor postion - is the NAK flag
                                bit 7 set ?
FCF4  30 23     BMI #FD19       ..yes, printing not allowed - return
FCF6  C9 1B     CMP @#1B        Is it <ESC> ?
FCF8  F0 11     BEQ #FD0B       ..yes, reset VDG to alphanumeric mode and
                                and clear NAK flag
FCFA  C9 07     CMP @#7         Is it <BEL> ?
FCFC  F0 1C     BEQ #FD1A       ..yes, sound a bleep
FCFE  20 44 FD  JSR #FD44       Invert char at current cursor position
FD01  A2 0A     LDX @#A         Point to the control code table at #FED5
FD03  20 C5 FE  JSR #FEC5       Test character for executable control code
FD06  D0 21     BNE #FD29       ..it's not an executable control code
                                so print it
                                it if >#1F, otherwise return
FD08  4C B7 FE  JMP #FEB7       ..executable control code - get the code's
                                execution address and jump to it


  Handle <ESC> subroutine
  -----------------------

- Resets the 6847 VDG to alphanumeric mode.
- Clears the NAK flag (bit 7 of #E0).

FD0B  18        CLC             ..to clear NAK flag
FD0C  A2 00     LDX @#0
FD0E  8E 00 B0  STX #B000       Reset the VDG to alphanumeric mode


  Handle <ACK> or <NAK> subroutine
  --------------------------------

- Entry: Carry clear to perform <NAK>
         Carry  set  to perform <ACK>
- Returns with Accumulator and Y registers preserved, and with X=2.

FD11  A2 02     LDX @#2
FD13  08        PHP             Save state of Carry flag
FD14  16 DE     ASL #DE,X       Get rid of old NAK flag (bit 7)
FD16  28        PLP             Restore state of Carry flag
FD17  76 DE     ROR #DE,X       ..and shift in the new NAK flag value
FD19  60        RTS


  Handle <BEL> subroutine
  -----------------------

- Returns with X=0, Y=128, and the sign flag set.

FD1A  A9 05     LDA @#5         Get control code to set 8255 PIA port bits
                                C0-C3 to input; A, B, and C4-C7 to output
FD1C  A8        TAY             Set up outer loop counter
FD1D  8D 03 B0  STA #B003       Set port C0-C3 to input, so speaker O/P=1
FD20  CA        DEX             )
FD21  D0 FD     BNE #FD20       ) ..a short delay
FD23  49 01     EOR @#1         Toggle C0-C3 between input and output
FD25  C8        INY             Increment outer loop counter
FD26  10 F5     BPL #FD1D       ..continue for 122 outer loop cycles
FD28  60        RTS


  Print an ASCII Character on the Screen subroutine
  -------------------------------------------------

- Control characters (codes less than #20) are ignored.
- Increments current cursor position, incrementing the print line and/or
  scrolling the screen as necessary.
- Entry: Accumulator contains ASCII code of character to be printed
         Y register contains current cursor position ?#E0.
- Accumulator preserved.

FD29  C9 20     CMP @#20        Is the character a control code ?
FD2B  90 17     BCC #FD44       ..yes, so don't print it
FD2D  69 1F     ADC @#1F        )
FD2F  30 02     BMI #FD33       )
FD31  49 60     EOR @#60        ) Convert to screen character
FD33  20 6B FE  JSR #FE6B       Wait for the next or current flyback
FD36  91 DE     STA (#DE),Y     Store character at current print position
FD38  C8        INY             Increment cursor position
FD39  C0 20     CPY @#20        Reached end of the current print line ?
FD3B  90 05     BCC #FD42       ..no, update cursor position and invert
                                the cursor at this position
FD3D  20 EC FD  JSR #FDEC       ..yes, do <CR><LF> first


  Reset Cursor to Start of Current Line Without Deletion subroutine
  -----------------------------------------------------------------

FD40  A0 00     LDY @#0         Point to start of current line
FD42  84 E0     STY #E0         Update current cursor position register


  Invert Character at Current Cursor Position subroutine
  ------------------------------------------------------

- EORs the character at the current cursor position with the cursor mask
  ?#E1.
- A, X, Y registers preserved.

FD44  48        PHA             Save character in accumulator
FD45  20 6B FE  JSR #FE6B       Wait for the next or current flyback
FD48  B1 DE     LDA (#DE),Y     Get character at current print position
FD4A  45 E1     EOR #E1         Mask it
FD4C  91 DE     STA (#DE),Y     ..and return it to the screen
FD4E  68        PLA             Restore character to accumulator
FD4F  60        RTS


  Handle <DEL> subroutine
  -----------------------

- Enter with Y containing the current cursor position ?#E1.

FD50  20 35 FE  JSR #FE35       Move cursor back one position if possible,
                                otherwise invert character at current
                                cursor position and return
FD53  A9 20     LDA @#20        Get <SPC>
FD55  20 6B FE  JSR #FE6B       Wait for the next or current flyback
FD58  91 DE     STA (#DE),      Blank character at previous cursor pos'n
FD5A  10 E6     BPL #FD42       Update cursor position and invert cursor


  Handle <BS> subroutine
  ----------------------

- Enter with Y containing the current cursor position ?#E1.

FD5C  20 35 FE  JSR #FE35       Move cursor back one position if possible,
                                otherwise invert character at the current
                                cursor position and return
FD5F  4C 42 FD  JMP #FD42       Update cursor position and invert cursor


  Handle <LF> subroutine
  ----------------------

FD62  20 EC FD  JSR #FDEC       Do <LF>, scrolling if necessary
FD65  A4 E0     LDY #E0         Get origional cursor position, which has
                                not changed although the line start
                                address may have
FD67  10 D9     BPL #FD42       Update cursor position and invert cursor


  Handle <FF> subroutine
  ----------------------

- Resets the 8647 VDG to the alphanumeric mode and clears the screen.
- Sets the cursor to the top left position.

FD69  A0 80     LDY @#80
FD6B  84 E1     STY #E1         Set the cursor mask to default
FD6D  A0 00     LDY @#0         Clear screen memory index
FD6F  8C 00 B0  STY #B000       Set 6847 VDG to alphanumeric mode
FD72  A9 20     LDA @#20        Get <SPC>
FD74  99 00 80  STA #8000,Y     Clear byte of upper page of screen
FD77  99 00 81  STA #8100,Y     Clear byte of lower page of screen
FD7A  C8        INY             Point to the next byte
FD7B  D0 F7     BNE #FD74       ..and clear both complete pages


  Handle <RS> subroutine
  ----------------------

- Sets cursor to top left position.

FD7D  A9 80     LDA @#80
FD7F  A0 00     LDY @#0         Clear current cursor position
FD81  85 DF     STA #DF         ) Set line start address to the top of
FD83  84 DE     STY #DE         ) the screen at #8000
FD85  F0 BB     BEQ #FD42       Update cursor position and invert cursor


  Handle <VT> subroutine
  ----------------------

- Enter with Y containing the current cursor position ?#E1.

FD87  20 3A FE  JSR #FE3A       Move the cursor position up a line
FD8A  4C 42 FD  JMP #FD42       Update cursor position and invert cursor


  Handle <SO> subroutine
  ----------------------

- Turns page mode on, and sets the number of lines left to 16.

FD8D  18        CLC
FD8E  A9 10     LDA @#10        Get number of lines in page = 16
FD90  85 E6     STA #E6         Indicate page mode by setting count


  Handle <SI> subroutine
  ----------------------

- Turns page mode off.
- Enter with Carry set.

FD92  A2 08     LDX @#8
FD94  20 13 FD  JSR #FD13       Set or clear bit 7 of #E6 according to
                                the state of the Carry flag
FD97  4C 44 FD  JMP #FD44       Invert character at current position


  Handle <LOCK> subroutine
  ------------------------

- Toggles the lock flag - #E7 = #60 Lock on
                          #E7 =   0 Lock off
- Enter with Carry set.

FD9A  A5 E7     LDA #E7         Get the lock flag
FD9C  49 60     EOR @#60        ..toggle it
FD9E  85 E7     STA #E7         ..and restore it
FDA0  B0 09     BCS #FDAB       Go fetch another keypress


  Handle Cursor Keys from Keyboard subroutine
  -------------------------------------------

- Sends the cursor control code to screen and then fetches another key.

FDA2  29 05     AND @#5
FDA4  2E 01 B0  ROL #B001
FDA7  2A        ROL A
FDA8  20 EA FC  JSR #FCEA       Send control character to screen
FDAB  4C 9A FE  JMP #FE9A       ..and fetch another key


  Handle <COPY> Key subroutine
  ----------------------------

FDAE  A4 E0     LDY #E0         Get the current cursor position
FDB0  20 6B FE  JSR #FE6B       Wait for the next or current flyback
FDB3  B1 DE     LDA (#DE),Y     Get character at current cursor position
FDB5  45 E1     EOR #E1         Get rid of the cursor mask
FDB7  30 02     BMI #FDBB       )
FDB9  49 60     EOR @#60        )
FDBB  E9 20     SBC @#20        ) Convert screen character to ASCII
FDBD  4C E9 FD  JMP #FDE9       Restore A,X,Y regs & status & return


  Handle <DEL> key #F (ASCII #7F) subroutine
  ------------------------------------------

FDC0  A9 5F     LDA @#5F


  Handle '[\]^_' keys #3B-#3F (ASCII #5B-#5F) subroutine
  ------------------------------------------------------

- Enter with accumulator = key number = #20 - ASCII value.

FDC2  49 20     EOR @#20
FDC4  D0 23     BNE #FDE9


  Handle 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' keys #21-#3A (ASCII #41-#5A) sub
  --------------------------------------------------------------------

- Enter with accumulator = key number = #20 - ASCII value.

FDC6  45 E7     EOR #E7         Invert if lock flag set to #60


  Handle '@' key #20 (ASCII #40) subroutine
  -----------------------------------------

FDC8  2C 01 B0  BIT #B001       Is the shift key being pressed ?
FDCB  30 02     BMI #FDCF       ..no, don't invert the character
FDCD  49 60     EOR @#60        ..yes, invert the character
FDCF  4C DF FD  JMP #FDDF       Convert to ASCII & test for <CTRL> key


  Handle '!"#$' keys 1-4 (ASCII #21-#24) subroutine
  -------------------------------------------------

- Enter with accumulator = key number = #20 - ASCII value.

FDD2  69 39     ADC @#39
FDD4  90 F2     BCC #FDC8


  Handle '<=>?>' keys #1C-#1F (ASCII #3C-#3F) subroutine
  ------------------------------------------------------

- Enter with accumulator = key number = #20 - ASCII value.

FDD6  49 10     EOR @#10


  Handle '123456789:;' keys #11-#1B (ASCII #31-#3B) subroutine
  ------------------------------------------------------------

- Enter with accumulator = key number = #20 - ASCII value.

FDD8  2C 01 B0  BIT #B001
FDDB  30 02     BMI #FDDF
FDDD  49 10     EOR @#10


  Handle <SPACE> key 0 (ASCII #10) subroutine
  -------------------------------------------

                                CONVERT TO ASCII & TEST FOR <CTRL> KEY

FDDF  18        CLC
FDE0  69 20     ADC @#20        Convert to ASCII
FDE2  2C 01 B0  BIT #B001       Is <CTRL> key pressed ?
FDE5  70 02     BVS #FDE9       ..no, restore X, Y & flags & return
FDE7  29 1F     AND @#1F        ..yes, mask to range 0-#1F
FDE9  4C 60 FE  JMP #FE60       Restore X, Y & flags & return


  Handle <LF>, Scrolling if Necessary subroutine
  ----------------------------------------------

- If in page mode, decrements page counter, and at the end of the page
  waits for a keypress before scrolling.

FDEC  A5 DE     LDA #DE         Get LSB start of line
FDEE  A4 DF     LDY #DF         Get MSB start of line
FDF0  C0 81     CPY @#81        In lower screen page ?
FDF2  90 38     BCC #FE2C       ..no, do <LF> - scrolling not required
FDF4  C9 E0     CMP @#E0        In last page..but is it the last line ?
FDF6  90 34     BCC #FE2C       ..no, do <LF> - scrolling not required

                                SCROLLING REQUIRED - CHECK IN PAGE MODE

FDF8  A4 E6     LDY #E6         Get page mode flag
FDFA  30 0C     BMI #FE08       ..not in page mode - scroll the screen
FDFC  88        DEY
FDFD  D0 07     BNE #FE06

                                IN PAGE MODE - GET KEYPRESS

FDFF  20 71 FE  JSR #FE71       Scan keyboard
FE02  B0 FB     BCS #FDFF       ..keep scanning until key pressed
FE04  A0 10     LDY @#10
FE06  84 E6     STY #E6         Reset page counter to 16 lines


  Scroll the Screen subroutine
  ----------------------------

FE08  A0 20     LDY @#20        Shift screen up 32 characters = 1 line


  Scroll Y lines of the Screen subroutine
  ---------------------------------------

- For every #20 in Y a top line of the screen is not scrolled.

FE0A  20 66 FE  JSR #FE66       Wait for the start of the next flyback
FE0D  B9 00 80  LDA #8000,Y     Get byte from upper text page
FE10  99 E0 7F  STA #7FE0,Y     ..and store it a line higher
FE13  C8        INY             Point to next screen byte
FE14  D0 F7     BNE #FE0D       ..and shift up all the upper text page
FE16  20 6B FE  JSR #FE6B       Wait for the next or current flyback
FE19  B9 00 81  LDA #8100,Y     Get byte from lower text page
FE1C  99 E0 80  STA #80E0,Y     ..and store it a line higher
FE1F  C8        INY             Point to next screen byte
FE20  D0 F7     BNE #FE19       ..and shift up all the lower text page


  Delete Current Line subroutine
  ------------------------------

- CLears the 32 character line based at (#DE) to black (<SPACE>).

FE22  A0 1F     LDY @#1F        Set character pointer to end of line
FE24  A9 20     LDA @#20        Get <SPACE>
FE26  91 DE     STA (#DE),Y     Clear the character to black
FE28  88        DEY             Point to the next character
FE29  10 FB     BPL #FE26       ..and clear the entire print line
FE2B  60        RTS


  Add One Line to the Cursor Position subroutine
  ----------------------------------------------

- Enter with the accumulator containing the LSB current cursor address
  #DE and Carry clear.

FE2C  69 20     ADC @#20        Add 32 characters = 1 print line
FE2E  85 DE     STA #DE         ..and update LSB cursor address
FE30  D0 02     BNE #FE34
FE32  E6 DF     INC #DF         Increment MSB cursor address if overflow
FE34  60        RTS


  Move the Cursor Back One Position subroutine
  --------------------------------------------

- Decrements the current cursor position, dealing with line underflow.
- If the cursor is at the top left of the screen, the character at this
  position is inverted before premature return.
- Used by the <BS> and <DEL> subroutines.
- Enter with Y register holding the current cursor position ?#31.

FE35  88        DEY             Point to the previous cursor position
FE36  10 19     BPL #FE51       ..still on current line, return

                                DEAL WITH LINE UNDERFLOW

FE38  A0 1F     LDY @#1F        Set cursor position to last char on line
FE3A  A5 DE     LDA #DE         Get LSB current line address
FE3C  D0 0B     BNE #FE49       ..not at top of screen, so can move line
                                address up a line
FE3E  A6 DF     LDX #DF         Get MSB current line address
FE40  E0 80     CPX @#80        Is it upper page ?
FE42  D0 05     BNE #FE49       ..no, move line address up a line

                                ALREADY AT TOP OF SCREEN - RETURN

FE44  68        PLA             )
FE45  68        PLA             ) Remove return address from stack
FE46  4C 65 FD  JMP #FD65       Invert char at current cursor position

                                MOVE CURRENT START ADDRESS UP A LINE

FE49  E9 20     SBC @#20        Move LSB current line back 32 characters
FE4B  85 DE     STA #DE         ..and update LSB line address
FE4D  B0 02     BCS #FE51
FE4F  C6 DF     DEC #DF         Decrement MSB line address if overflow
FE51  60        RTS


  Send Character to VIA and Screen subroutine
  -------------------------------------------

- Preserves all registers.

FE52  20 FB FE  JSR #FEFB       Send character in accumulator to the VIA


  Send Character to Screen subroutine
  -----------------------------------

- Preserves all registers.

FE55  08        PHP             Save flags
FE56  48        PHA             Save accumulator
FE57  D8        CLD
FE58  84 E5     STY #E5         Save Y register
FE5A  86 E4     STX #E4         Save X register
FE5C  20 EA FC  JSR #FCEA       Send character in accumulator to screen
FE5F  68        PLA             Restore accumulator
FE60  A6 E4     LDX #E4         Restore X register
FE62  A4 E5     LDY #E5         Restore Y register
FE64  28        PLP             Restore flags
FE65  60        RTS


  Wait Until Next CRT Field Flyback subroutine
  --------------------------------------------

Preserves Accumulator, X, Y registers

FE66  2C 02 B0  BIT #B002       In flyback ?
FE69  10 FB     BPL #FE66       ..yes, wait until finished
;
;  Wait Until Next or Current CRT Field Flyback subroutine
;  -------------------------------------------------------
FE6B  2C 02 B0  BIT #B002       In flyback ?
FE6E  30 FB     BMI #FE6B       ..no, wait for flyback
FE70  60        RTS
;
;  Scan Key Matrix subroutine
;  --------------------------
;- Does not examine the <CTRL>, <SHIFT>, or <REPT> keys.
;- Enter with the 4 LSBs of #B000 clear.
;- Returns with ASCII value minus #20 in Y register and Carry clear if successful.
;- Destroys A,X,Y registers.
;- Returns with Z flag set.

FE71  A0 3B     LDY @#3B        Set key counter
FE73  18        CLC
FE74  A9 20     LDA @#20        Initialise bit mask to examine bit 5
FE76  A2 0A     LDX @#A         Set row counter
FE78  2C 01 B0  BIT #B001       Is the key in this row & column pressed ?
FE7B  F0 08     BEQ #FE85       ..yes - success
FE7D  EE 00 B0  INC #B000       ..no, point to the next row
FE80  88        DEY             Decrement key counter
FE81  CA        DEX             Decrement row counter
FE82  D0 F4     BNE #FE78       ..and test this row in the same column
FE84  4A        LSR A           Tested all the rows - point to next column If failed, acc shifts to 0, Carry=1 - thus returns with Carry set if failed
FE85  08        PHP             Save flags - Z set if successful
FE86  48        PHA             Save column bit mask
FE87  AD 00 B0  LDA #B000       Get contents of VDG/row counter port
FE8A  29 F0     AND @#F0        Leave VDG bits unaltered, but clear row; counter so that <ESC> can be tested easily
FE8C  8D 00 B0  STA #B000       Update VDG/row counter port
FE8F  68        PLA             Restore column bit mask
FE90  28        PLP             Restore flags
FE91  D0 E3     BNE #FE76       ..keep testing
FE93  60        RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  OSRDCH Get Key subroutine
;  -------------------------;
;- Waits for a key to be pressed and returns with its ASCII value in the accumulator.
;- Executes control characters before return.
;- If <LOCK> or cursor control keys is pressed, the code is executed and another keypress fetched before return.
;- Preserves X,Y registers and flags.
FE94  08        PHP             Save flags
FE95  D8        CLD
FE96  86 E4     STX #E4         Save X register
FE98  84 E5     STY #E5         Save Y register
;     WAIT FOR KEYBOARD TO BE RELEASED
FE9A  2C 02 B0  BIT #B002       Is <REPT> key pressed ?
FE9D  50 05     BVC #FEA4       ..yes, no need to wait for keyboard to be released
FE9F  20 71 FE  JSR #FE71       Scan keyboard
FEA2  90 F6     BCC #FE9A       ..wait for key to be released
;     GET KEYPRESS
FEA4  20 8A FB  JSR #FB8A       Wait 0.1 second for debounce
FEA7  20 71 FE  JSR #FE71       Scan keyboard
FEAA  B0 FB     BCS #FEA7       ..keep scanning until key pressed
FEAC  20 71 FE  JSR #FE71       Scan keyboard again - still pressed ?
FEAF  B0 F6     BCS #FEA7       ..no, noise ? - try again
FEB1  98        TYA             Acc = ASCII value of key - #20
FEB2  A2 17     LDX @#17        Pointer to control code table at #FEE2
;     GET EXECUTION ADDRESS AND JUMP TO IT
FEB4  20 C5 FE  JSR #FEC5       Test for control code or otherwise
FEB7  BD E3 FE  LDA #FEE3,X     Get LSB execution address
FEBA  85 E2     STA #E2         ..into w/s
FEBC  A9 FD     LDA @#FD        Get MSB execution address
FEBE  85 E3     STA #E3         ..into w/s
FEC0  98        TYA             Acc = ASCII value of key - #20
FEC1  6C E2 00  JMP (#E2)       Jump to deal with char or control code 
;
;  Decode Control Character subroutine
;  -----------------------------------
;- Enter at #FEC5.
;- Enter with X pointing to control code table:
;    X=#A  for the WRCHAR table at #FED5
;    X=#17 for the RDCHAR table at #FEE2.
;- Returns with Carry set, and X pointing to matched code or last code.
;- Returns with Z flag set if control code matched.

FEC4  CA        DEX             Point to next control code in table
FEC5  DD CB FE  CMP #FECB,X     Is it this control code ?
FEC8  90 FA     BCC #FEC4       ..no, table value too large - try the next code
FECA  60        RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  WRCHAR Control Code Data Lookup Table
;  -------------------------------------
FECB  00 08 09 0A 0B 0C 0D 0E 0F 1E 7F
;  RDCHAR Control Code Data Lookup Table
;  -------------------------------------
FED6  00 01 05 06 08 0E 0F 10 11 1C 20 21 3B
;  WRCHAR Control Code Address Lookup Table
;  ----------------------------------------
FEE3  44 5C 38 62 87 69 40 8D 92 7D 50
;  RDCHAR Control Code Address Lookup Table
;  ----------------------------------------
FEEE  DF D2 9A A2 E2 AE C0 DF D8 D6 C8 C6 C2
;
;  Send Contents of Accumulator to VIA subroutine
;  ----------------------------------------------
;- Waits for the busy line VIA Port A bit 7 to go low, then dumps 7 bit
;  data to the 7 LSBs of Port A, and then strobes CA2 low for ~20uS.
;- Enter with CA2 output set high.
;- Preserves A,X,Y registers.
FEFB  48        PHA             Save a copy of data to be transmitted
FEFC  C9 02     CMP @#2         Is it <STX> ?
FEFE  F0 27     BEQ #FF27       ..yes, initialise the printer
FF00  C9 03     CMP @#3         Is it <EXT> ?
FF02  F0 34     BEQ #FF38       ..yes, disable the printer
FF04  C5 FE     CMP #FE         Is char allowed to be sent to printer ?
FF06  F0 2E     BEQ #FF36       ..no, return
FF08  AD 0C B8  LDA #B80C       Get the VIAs peripheral control register
FF0B  29 0E     AND @#E         Is it set up, ie <STX>ed ?
FF0D  F0 27     BEQ #FF36       ..no, can't send character - return
FF0F  68        PLA             Restore character to be sent
;     WAIT FOR PRINTER NOT BUSY
FF10  2C 01 B8  BIT #B801       Busy ?
FF13  30 FB     BMI #FF10       ..yes, wait for printer to be not busy
FF15  8D 01 B8  STA #B801       Dump character to printer output port A
FF18  48        PHA             Save a copy of data that was transmitted
FF19  AD 0C B8  LDA #B80C       Get 6522 VIA peripheral control register
FF1C  29 F0     AND @#F0        Don't affect CB1, CB2, Port B conditions
FF1E  09 0C     ORA @#C         ..but set CA2 low - NSTROBE
FF20  8D 0C B8  STA #B80C       Update the VIA peripheral control register
FF23  09 02     ORA @#2         Don't affect CB1, CB2 conditions, but set CA2 high
FF25  D0 0C     BNE #FF33       Update PCR, restore character and return
;    DO <STX>
FF27  A9 7F     LDA @#7F
FF29  8D 03 B8  STA #B803       Set 7 LSBs of 6522 VIA Port A as the data outputs and the MSB as the busy input
FF2C  AD 0C B8  LDA #B80C       Get 6522 VIA peripheral control register
FF2F  29 F0     AND @#F0        Don't affect CB1, CB2, Port B conditions
FF31  09 0E     ORA @#E         ..but set CA2 output high
FF33  8D 0C B8  STA #B80C       Update the VIA peripheral control register
FF36  68        PLA             Restore the data that was transmitted
FF37  60        RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
;  Do <EXT> subroutine
;  -------------------
FF38  AD 0C B8  LDA #B80C       Get the VIAs peripheral control register
FF3B  29 F0     AND @#F0        Don't affect CB1, CB2, Port B conditions
FF3D  B0 F4     BCS #FF33       Update PCR, restore character and return
;
;  RESET Routine
;  -------------
;- Indirected by the vector #FFFC on power-up or BREAK.
;  RESET PAGE 2 VECTORS TO DEFAULT
FF3F  A2 17     LDX @#17        Set vector table pointer
FF41  BD 9A FF  LDA #FF9A,X     Get byte from vector data table
FF44  9D 04 02  STA #204,X      ..and store in the vector table in RAM
FF47  CA        DEX             Point to next byte
FF48  10 F7     BPL #FF41       ..and set all 12 vectors = 24 bytes
FF4A  9A        TXS             Initialise stack pointer to #FF
FF4B  8A        TXA
FF4C  E8        INX             Now X=0
FF4D  86 EA     STX #EA         Clear NOMON flag
FF4F  86 E1     STX #E1         Clear cursor position
FF51  86 E7     STX #E7         Clear lock off
;     SET ALL THE ARRAY POINTERS TO #FFFF
FF53  A2 33     LDX @#33        Set array pointer
FF55  9D EB 02  STA #2EB,X      Set array pointer LSB/MSB to #FF
FF58  CA        DEX             Point to next byte
FF59  10 FA     BPL #FF55       ..and set all 26 array addresses

FF5B  A9 0A     LDA @#A         Get <LF>
FF5D  85 FE     STA #FE         Set character not to be sent to printer

;  SET UP VDG FOR ALPHANUMERIC MODE
FF5F  A9 8A     LDA @#8A
FF61  8D 03 B0  STA #B003
FF64  A9 07     LDA @#7
FF66  8D 02 B0  STA #B002
;  PRINT INITIALISATION MESSAGE
FF69  20 D1 F7  JSR #F7D1       Send the following string to WRCHAR
;
FF6C  06 0C 0F 41 43 4F 52 4E 20 41 54 4F 4D 0A 0A 0D  ...ACORN ATOM...
;
;   SET DEFAULT TEXT SPACE & ENABLE INTERRUPTS

FF7C  A9 82     LDA @#82        Default text space is #8200
FF7E  85 12     STA #12         ..so set it
FF80  58        CLI             ..before enabling interrupts
;
;  TEST TEXT SPACE AT #2900 FOR RAM FITTED
FF81  A9 55     LDA @#55        Get 1st test code
FF83  8D 01 29  STA #2901       ..and write to lower text space
FF86  CD 01 29  CMP #2901       Can it be read back ?
FF89  D0 0C     BNE #FF97       ..no, stick to default text space
FF8B  0A        ASL A           Get 2nd test code = #AA
FF8C  8D 01 29  STA #2901       ..and write to lower text space
FF8F  CD 01 29  CMP #2901       Can it be read back ?
FF92  D0 03     BNE #FF97       ..no, stick to default text space
FF94  4C B2 C2  JMP #C2B2       ..yes, initialise #2900 text space and Carry onto to the Direct Command Handler
FF97  4C B6 C2  JMP #C2B6       Initialise #8200 text space and carry on to the Direct Command Handler
;
;  Vector Data Table
;  -----------------
FF9A                                00 A0 EF F8 52 FE
FFA0  94 FE 6E F9 E5 FA AC C2 AC C2 EE FB 7C FC 38 FC
FFB0  78 C2
;
;  IRQ/BRK Handler
;  ---------------
;  - If IRQ, pushes the accumulator onto the stack before jumping to IRQVEC at (#204).
;  - If BRK, jumps to BRKVEC at (#202).
FFB2  85 FF     STA #FF         Save accumulator
FFB4  68        PLA             Get status
FFB5  48        PHA             Re-save status
FFB6  29 10     AND @#10        Is it IRQ or BRK ?
FFB8  D0 06     BNE #FFC0       ..it's BRK - deal with it
FFBA  A5 FF     LDA #FF         Restore accumulator
FFBC  48        PHA             Save accumulator onto stack
FFBD  6C 04 02  JMP (#204)      ..before jumping to IRQVEC
;
;  Execute BRK
;  -----------
FFC0  A5 FF     LDA #FF         Restore accumulator
FFC2  28        PLP             Restore flags
FFC3  08        PHP             Re-save flags
FFC4  6C 02 02  JMP (#202)      ..jump to BRKVEC
;
;  Execute NMI
;  -----------
; - Pushes accumulator onto stack before jumping to NMIVEC at (#200).
FFC7  48        PHA             Save accumulator onto stack
FFC8  6C 00 02  JMP (#200)      ..before jumping to NMIVEC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Operating System Jump Table
;  ---------------------------
FFCB  6C 1A 02  JMP (#21A)      OSSHUT - normally #C278
FFCE  6C 18 02  JMP (#218)      OSFIND - normally #FC38
FFD1  6C 16 02  JMP (#216)      OSBPUT - normally #FC7C
FFD4  6C 14 02  JMP (#214)      OSBGET - normally #FBEE
FFD7  6C 12 02  JMP (#212)      OSSTAR - normally #C2AC
FFDA  6C 10 02  JMP (#210)      OSRDAR - normally #C2AC
FFDD  6C 0E 02  JMP (#20E)      OSSAVE - normally #FAE5
FFE0  6C 0C 02  JMP (#20C)      OSLOAD - normally #F96E
FFE3  6C 0A 02  JMP (#20A)      OSRDCH - normally #FE94
FFE6  20 E3 FF  JSR #FFE3       OSECHO - normally #FE94 then FE52
FFE9  C9 0D     CMP @#D         OSASCI - #D causes <CR><LF>
FFEB  D0 07     BNE #FFF4
FFED  A9 0A     LDA @#A         OSCRLF - causes <CR><LF>
FFEF  20 F4 FF  JSR #FFF4
FFF2  A9 0D     LDA @#D
FFF4  6C 08 02  JMP (#208)      OSWRCH - normally #FE52
FFF7  6C 06 02  JMP (#206)      OSCLI  - normally #F8EF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FFFA  C7 FF                     NMI     Jump Address
FFFC  3F FF                     RESET   Jump Address
FFFE  B2 FF                     IRQ/BRK Jump Address
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
